"bundle";
System.registerDynamic("npm:jquery@3.1.1.json", [], false, function() {
  return {
    "main": "dist/jquery.js",
    "format": "amd",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

(function() {
var define = System.amdDefine;
(function(global, factory) {
  "use strict";
  if (typeof module === "object" && typeof module.exports === "object") {
    module.exports = global.document ? factory(global, true) : function(w) {
      if (!w.document) {
        throw new Error("jQuery requires a window with a document");
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
  "use strict";
  var arr = [];
  var document = window.document;
  var getProto = Object.getPrototypeOf;
  var slice = arr.slice;
  var concat = arr.concat;
  var push = arr.push;
  var indexOf = arr.indexOf;
  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var fnToString = hasOwn.toString;
  var ObjectFunctionString = fnToString.call(Object);
  var support = {};
  function DOMEval(code, doc) {
    doc = doc || document;
    var script = doc.createElement("script");
    script.text = code;
    doc.head.appendChild(script).parentNode.removeChild(script);
  }
  var version = "3.1.1",
      jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
      },
      rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
      rmsPrefix = /^-ms-/,
      rdashAlpha = /-([a-z])/g,
      fcamelCase = function(all, letter) {
        return letter.toUpperCase();
      };
  jQuery.fn = jQuery.prototype = {
    jquery: version,
    constructor: jQuery,
    length: 0,
    toArray: function() {
      return slice.call(this);
    },
    get: function(num) {
      if (num == null) {
        return slice.call(this);
      }
      return num < 0 ? this[num + this.length] : this[num];
    },
    pushStack: function(elems) {
      var ret = jQuery.merge(this.constructor(), elems);
      ret.prevObject = this;
      return ret;
    },
    each: function(callback) {
      return jQuery.each(this, callback);
    },
    map: function(callback) {
      return this.pushStack(jQuery.map(this, function(elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    slice: function() {
      return this.pushStack(slice.apply(this, arguments));
    },
    first: function() {
      return this.eq(0);
    },
    last: function() {
      return this.eq(-1);
    },
    eq: function(i) {
      var len = this.length,
          j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    end: function() {
      return this.prevObject || this.constructor();
    },
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };
  jQuery.extend = jQuery.fn.extend = function() {
    var options,
        name,
        src,
        copy,
        copyIsArray,
        clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[i] || {};
      i++;
    }
    if (typeof target !== "object" && !jQuery.isFunction(target)) {
      target = {};
    }
    if (i === length) {
      target = this;
      i--;
    }
    for (; i < length; i++) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && jQuery.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }
            target[name] = jQuery.extend(deep, clone, copy);
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }
    return target;
  };
  jQuery.extend({
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    isReady: true,
    error: function(msg) {
      throw new Error(msg);
    },
    noop: function() {},
    isFunction: function(obj) {
      return jQuery.type(obj) === "function";
    },
    isArray: Array.isArray,
    isWindow: function(obj) {
      return obj != null && obj === obj.window;
    },
    isNumeric: function(obj) {
      var type = jQuery.type(obj);
      return (type === "number" || type === "string") && !isNaN(obj - parseFloat(obj));
    },
    isPlainObject: function(obj) {
      var proto,
          Ctor;
      if (!obj || toString.call(obj) !== "[object Object]") {
        return false;
      }
      proto = getProto(obj);
      if (!proto) {
        return true;
      }
      Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
      return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
    },
    isEmptyObject: function(obj) {
      var name;
      for (name in obj) {
        return false;
      }
      return true;
    },
    type: function(obj) {
      if (obj == null) {
        return obj + "";
      }
      return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
    },
    globalEval: function(code) {
      DOMEval(code);
    },
    camelCase: function(string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    },
    nodeName: function(elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    },
    each: function(obj, callback) {
      var length,
          i = 0;
      if (isArrayLike(obj)) {
        length = obj.length;
        for (; i < length; i++) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      } else {
        for (i in obj) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      }
      return obj;
    },
    trim: function(text) {
      return text == null ? "" : (text + "").replace(rtrim, "");
    },
    makeArray: function(arr, results) {
      var ret = results || [];
      if (arr != null) {
        if (isArrayLike(Object(arr))) {
          jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }
      return ret;
    },
    inArray: function(elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },
    merge: function(first, second) {
      var len = +second.length,
          j = 0,
          i = first.length;
      for (; j < len; j++) {
        first[i++] = second[j];
      }
      first.length = i;
      return first;
    },
    grep: function(elems, callback, invert) {
      var callbackInverse,
          matches = [],
          i = 0,
          length = elems.length,
          callbackExpect = !invert;
      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);
        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }
      return matches;
    },
    map: function(elems, callback, arg) {
      var length,
          value,
          i = 0,
          ret = [];
      if (isArrayLike(elems)) {
        length = elems.length;
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      }
      return concat.apply([], ret);
    },
    guid: 1,
    proxy: function(fn, context) {
      var tmp,
          args,
          proxy;
      if (typeof context === "string") {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }
      if (!jQuery.isFunction(fn)) {
        return undefined;
      }
      args = slice.call(arguments, 2);
      proxy = function() {
        return fn.apply(context || this, args.concat(slice.call(arguments)));
      };
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    },
    now: Date.now,
    support: support
  });
  if (typeof Symbol === "function") {
    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
  }
  jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });
  function isArrayLike(obj) {
    var length = !!obj && "length" in obj && obj.length,
        type = jQuery.type(obj);
    if (type === "function" || jQuery.isWindow(obj)) {
      return false;
    }
    return type === "array" || length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj;
  }
  var Sizzle = (function(window) {
    var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,
        setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,
        expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        sortOrder = function(a, b) {
          if (a === b) {
            hasDuplicate = true;
          }
          return 0;
        },
        hasOwn = ({}).hasOwnProperty,
        arr = [],
        pop = arr.pop,
        push_native = arr.push,
        push = arr.push,
        slice = arr.slice,
        indexOf = function(list, elem) {
          var i = 0,
              len = list.length;
          for (; i < len; i++) {
            if (list[i] === elem) {
              return i;
            }
          }
          return -1;
        },
        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
        whitespace = "[\\x20\\t\\r\\n\\f]",
        identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
        attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
        pseudos = ":(" + identifier + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)",
        rwhitespace = new RegExp(whitespace + "+", "g"),
        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
        rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
        rpseudo = new RegExp(pseudos),
        ridentifier = new RegExp("^" + identifier + "$"),
        matchExpr = {
          "ID": new RegExp("^#(" + identifier + ")"),
          "CLASS": new RegExp("^\\.(" + identifier + ")"),
          "TAG": new RegExp("^(" + identifier + "|[*])"),
          "ATTR": new RegExp("^" + attributes),
          "PSEUDO": new RegExp("^" + pseudos),
          "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
          "bool": new RegExp("^(?:" + booleans + ")$", "i"),
          "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        },
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        rnative = /^[^{]+\{\s*\[native \w/,
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        rsibling = /[+~]/,
        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
        funescape = function(_, escaped, escapedWhitespace) {
          var high = "0x" + escaped - 0x10000;
          return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
        },
        rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
        fcssescape = function(ch, asCodePoint) {
          if (asCodePoint) {
            if (ch === "\0") {
              return "\uFFFD";
            }
            return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
          }
          return "\\" + ch;
        },
        unloadHandler = function() {
          setDocument();
        },
        disabledAncestor = addCombinator(function(elem) {
          return elem.disabled === true && ("form" in elem || "label" in elem);
        }, {
          dir: "parentNode",
          next: "legend"
        });
    try {
      push.apply((arr = slice.call(preferredDoc.childNodes)), preferredDoc.childNodes);
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {apply: arr.length ? function(target, els) {
          push_native.apply(target, slice.call(els));
        } : function(target, els) {
          var j = target.length,
              i = 0;
          while ((target[j++] = els[i++])) {}
          target.length = j - 1;
        }};
    }
    function Sizzle(selector, context, results, seed) {
      var m,
          i,
          elem,
          nid,
          match,
          groups,
          newSelector,
          newContext = context && context.ownerDocument,
          nodeType = context ? context.nodeType : 9;
      results = results || [];
      if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
        return results;
      }
      if (!seed) {
        if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
          setDocument(context);
        }
        context = context || document;
        if (documentIsHTML) {
          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
            if ((m = match[1])) {
              if (nodeType === 9) {
                if ((elem = context.getElementById(m))) {
                  if (elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } else {
                  return results;
                }
              } else {
                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                  results.push(elem);
                  return results;
                }
              }
            } else if (match[2]) {
              push.apply(results, context.getElementsByTagName(selector));
              return results;
            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
              push.apply(results, context.getElementsByClassName(m));
              return results;
            }
          }
          if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
            if (nodeType !== 1) {
              newContext = context;
              newSelector = selector;
            } else if (context.nodeName.toLowerCase() !== "object") {
              if ((nid = context.getAttribute("id"))) {
                nid = nid.replace(rcssescape, fcssescape);
              } else {
                context.setAttribute("id", (nid = expando));
              }
              groups = tokenize(selector);
              i = groups.length;
              while (i--) {
                groups[i] = "#" + nid + " " + toSelector(groups[i]);
              }
              newSelector = groups.join(",");
              newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
            }
            if (newSelector) {
              try {
                push.apply(results, newContext.querySelectorAll(newSelector));
                return results;
              } catch (qsaError) {} finally {
                if (nid === expando) {
                  context.removeAttribute("id");
                }
              }
            }
          }
        }
      }
      return select(selector.replace(rtrim, "$1"), context, results, seed);
    }
    function createCache() {
      var keys = [];
      function cache(key, value) {
        if (keys.push(key + " ") > Expr.cacheLength) {
          delete cache[keys.shift()];
        }
        return (cache[key + " "] = value);
      }
      return cache;
    }
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    function assert(fn) {
      var el = document.createElement("fieldset");
      try {
        return !!fn(el);
      } catch (e) {
        return false;
      } finally {
        if (el.parentNode) {
          el.parentNode.removeChild(el);
        }
        el = null;
      }
    }
    function addHandle(attrs, handler) {
      var arr = attrs.split("|"),
          i = arr.length;
      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    function siblingCheck(a, b) {
      var cur = b && a,
          diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
      if (diff) {
        return diff;
      }
      if (cur) {
        while ((cur = cur.nextSibling)) {
          if (cur === b) {
            return -1;
          }
        }
      }
      return a ? 1 : -1;
    }
    function createInputPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
      };
    }
    function createButtonPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
      };
    }
    function createDisabledPseudo(disabled) {
      return function(elem) {
        if ("form" in elem) {
          if (elem.parentNode && elem.disabled === false) {
            if ("label" in elem) {
              if ("label" in elem.parentNode) {
                return elem.parentNode.disabled === disabled;
              } else {
                return elem.disabled === disabled;
              }
            }
            return elem.isDisabled === disabled || elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled;
          }
          return elem.disabled === disabled;
        } else if ("label" in elem) {
          return elem.disabled === disabled;
        }
        return false;
      };
    }
    function createPositionalPseudo(fn) {
      return markFunction(function(argument) {
        argument = +argument;
        return markFunction(function(seed, matches) {
          var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length;
          while (i--) {
            if (seed[(j = matchIndexes[i])]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    function testContext(context) {
      return context && typeof context.getElementsByTagName !== "undefined" && context;
    }
    support = Sizzle.support = {};
    isXML = Sizzle.isXML = function(elem) {
      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== "HTML" : false;
    };
    setDocument = Sizzle.setDocument = function(node) {
      var hasCompare,
          subWindow,
          doc = node ? node.ownerDocument || node : preferredDoc;
      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      }
      document = doc;
      docElem = document.documentElement;
      documentIsHTML = !isXML(document);
      if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
        if (subWindow.addEventListener) {
          subWindow.addEventListener("unload", unloadHandler, false);
        } else if (subWindow.attachEvent) {
          subWindow.attachEvent("onunload", unloadHandler);
        }
      }
      support.attributes = assert(function(el) {
        el.className = "i";
        return !el.getAttribute("className");
      });
      support.getElementsByTagName = assert(function(el) {
        el.appendChild(document.createComment(""));
        return !el.getElementsByTagName("*").length;
      });
      support.getElementsByClassName = rnative.test(document.getElementsByClassName);
      support.getById = assert(function(el) {
        docElem.appendChild(el).id = expando;
        return !document.getElementsByName || !document.getElementsByName(expando).length;
      });
      if (support.getById) {
        Expr.filter["ID"] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            return elem.getAttribute("id") === attrId;
          };
        };
        Expr.find["ID"] = function(id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var elem = context.getElementById(id);
            return elem ? [elem] : [];
          }
        };
      } else {
        Expr.filter["ID"] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
            return node && node.value === attrId;
          };
        };
        Expr.find["ID"] = function(id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var node,
                i,
                elems,
                elem = context.getElementById(id);
            if (elem) {
              node = elem.getAttributeNode("id");
              if (node && node.value === id) {
                return [elem];
              }
              elems = context.getElementsByName(id);
              i = 0;
              while ((elem = elems[i++])) {
                node = elem.getAttributeNode("id");
                if (node && node.value === id) {
                  return [elem];
                }
              }
            }
            return [];
          }
        };
      }
      Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
        if (typeof context.getElementsByTagName !== "undefined") {
          return context.getElementsByTagName(tag);
        } else if (support.qsa) {
          return context.querySelectorAll(tag);
        }
      } : function(tag, context) {
        var elem,
            tmp = [],
            i = 0,
            results = context.getElementsByTagName(tag);
        if (tag === "*") {
          while ((elem = results[i++])) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }
          return tmp;
        }
        return results;
      };
      Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
        if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      rbuggyMatches = [];
      rbuggyQSA = [];
      if ((support.qsa = rnative.test(document.querySelectorAll))) {
        assert(function(el) {
          docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";
          if (el.querySelectorAll("[msallowcapture^='']").length) {
            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
          }
          if (!el.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
          }
          if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
            rbuggyQSA.push("~=");
          }
          if (!el.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          }
          if (!el.querySelectorAll("a#" + expando + "+*").length) {
            rbuggyQSA.push(".#.+[+~]");
          }
        });
        assert(function(el) {
          el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>";
          var input = document.createElement("input");
          input.setAttribute("type", "hidden");
          el.appendChild(input).setAttribute("name", "D");
          if (el.querySelectorAll("[name=d]").length) {
            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
          }
          if (el.querySelectorAll(":enabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          }
          docElem.appendChild(el).disabled = true;
          if (el.querySelectorAll(":disabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          }
          el.querySelectorAll("*,:x");
          rbuggyQSA.push(",.*:");
        });
      }
      if ((support.matchesSelector = rnative.test((matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)))) {
        assert(function(el) {
          support.disconnectedMatch = matches.call(el, "*");
          matches.call(el, "[s!='']:x");
          rbuggyMatches.push("!=", pseudos);
        });
      }
      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
      hasCompare = rnative.test(docElem.compareDocumentPosition);
      contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function(a, b) {
        if (b) {
          while ((b = b.parentNode)) {
            if (b === a) {
              return true;
            }
          }
        }
        return false;
      };
      sortOrder = hasCompare ? function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
        if (compare) {
          return compare;
        }
        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
        if (compare & 1 || (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {
          if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
            return -1;
          }
          if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
            return 1;
          }
          return sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
        }
        return compare & 4 ? -1 : 1;
      } : function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [a],
            bp = [b];
        if (!aup || !bup) {
          return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
        } else if (aup === bup) {
          return siblingCheck(a, b);
        }
        cur = a;
        while ((cur = cur.parentNode)) {
          ap.unshift(cur);
        }
        cur = b;
        while ((cur = cur.parentNode)) {
          bp.unshift(cur);
        }
        while (ap[i] === bp[i]) {
          i++;
        }
        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
      };
      return document;
    };
    Sizzle.matches = function(expr, elements) {
      return Sizzle(expr, null, null, elements);
    };
    Sizzle.matchesSelector = function(elem, expr) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      expr = expr.replace(rattributeQuotes, "='$1']");
      if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr);
          if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {}
      }
      return Sizzle(expr, document, null, [elem]).length > 0;
    };
    Sizzle.contains = function(context, elem) {
      if ((context.ownerDocument || context) !== document) {
        setDocument(context);
      }
      return contains(context, elem);
    };
    Sizzle.attr = function(elem, name) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      var fn = Expr.attrHandle[name.toLowerCase()],
          val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
    };
    Sizzle.escape = function(sel) {
      return (sel + "").replace(rcssescape, fcssescape);
    };
    Sizzle.error = function(msg) {
      throw new Error("Syntax error, unrecognized expression: " + msg);
    };
    Sizzle.uniqueSort = function(results) {
      var elem,
          duplicates = [],
          j = 0,
          i = 0;
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);
      if (hasDuplicate) {
        while ((elem = results[i++])) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }
      sortInput = null;
      return results;
    };
    getText = Sizzle.getText = function(elem) {
      var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;
      if (!nodeType) {
        while ((node = elem[i++])) {
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        if (typeof elem.textContent === "string") {
          return elem.textContent;
        } else {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      return ret;
    };
    Expr = Sizzle.selectors = {
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: true
        },
        " ": {dir: "parentNode"},
        "+": {
          dir: "previousSibling",
          first: true
        },
        "~": {dir: "previousSibling"}
      },
      preFilter: {
        "ATTR": function(match) {
          match[1] = match[1].replace(runescape, funescape);
          match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
          if (match[2] === "~=") {
            match[3] = " " + match[3] + " ";
          }
          return match.slice(0, 4);
        },
        "CHILD": function(match) {
          match[1] = match[1].toLowerCase();
          if (match[1].slice(0, 3) === "nth") {
            if (!match[3]) {
              Sizzle.error(match[0]);
            }
            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
            match[5] = +((match[7] + match[8]) || match[3] === "odd");
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }
          return match;
        },
        "PSEUDO": function(match) {
          var excess,
              unquoted = !match[6] && match[2];
          if (matchExpr["CHILD"].test(match[0])) {
            return null;
          }
          if (match[3]) {
            match[2] = match[4] || match[5] || "";
          } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          }
          return match.slice(0, 3);
        }
      },
      filter: {
        "TAG": function(nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === "*" ? function() {
            return true;
          } : function(elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        "CLASS": function(className) {
          var pattern = classCache[className + " "];
          return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
          });
        },
        "ATTR": function(name, operator, check) {
          return function(elem) {
            var result = Sizzle.attr(elem, name);
            if (result == null) {
              return operator === "!=";
            }
            if (!operator) {
              return true;
            }
            result += "";
            return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
          };
        },
        "CHILD": function(type, what, argument, first, last) {
          var simple = type.slice(0, 3) !== "nth",
              forward = type.slice(-4) !== "last",
              ofType = what === "of-type";
          return first === 1 && last === 0 ? function(elem) {
            return !!elem.parentNode;
          } : function(elem, context, xml) {
            var cache,
                uniqueCache,
                outerCache,
                node,
                nodeIndex,
                start,
                dir = simple !== forward ? "nextSibling" : "previousSibling",
                parent = elem.parentNode,
                name = ofType && elem.nodeName.toLowerCase(),
                useCache = !xml && !ofType,
                diff = false;
            if (parent) {
              if (simple) {
                while (dir) {
                  node = elem;
                  while ((node = node[dir])) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  }
                  start = dir = type === "only" && !start && "nextSibling";
                }
                return true;
              }
              start = [forward ? parent.firstChild : parent.lastChild];
              if (forward && useCache) {
                node = parent;
                outerCache = node[expando] || (node[expando] = {});
                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                cache = uniqueCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = nodeIndex && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];
                while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    uniqueCache[type] = [dirruns, nodeIndex, diff];
                    break;
                  }
                }
              } else {
                if (useCache) {
                  node = elem;
                  outerCache = node[expando] || (node[expando] = {});
                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                  cache = uniqueCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex;
                }
                if (diff === false) {
                  while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                      if (useCache) {
                        outerCache = node[expando] || (node[expando] = {});
                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                        uniqueCache[type] = [dirruns, diff];
                      }
                      if (node === elem) {
                        break;
                      }
                    }
                  }
                }
              }
              diff -= last;
              return diff === first || (diff % first === 0 && diff / first >= 0);
            }
          };
        },
        "PSEUDO": function(pseudo, argument) {
          var args,
              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
          if (fn[expando]) {
            return fn(argument);
          }
          if (fn.length > 1) {
            args = [pseudo, pseudo, "", argument];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
              var idx,
                  matched = fn(seed, argument),
                  i = matched.length;
              while (i--) {
                idx = indexOf(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function(elem) {
              return fn(elem, 0, args);
            };
          }
          return fn;
        }
      },
      pseudos: {
        "not": markFunction(function(selector) {
          var input = [],
              results = [],
              matcher = compile(selector.replace(rtrim, "$1"));
          return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
            var elem,
                unmatched = matcher(seed, null, xml, []),
                i = seed.length;
            while (i--) {
              if ((elem = unmatched[i])) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function(elem, context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results);
            input[0] = null;
            return !results.pop();
          };
        }),
        "has": markFunction(function(selector) {
          return function(elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        "contains": markFunction(function(text) {
          text = text.replace(runescape, funescape);
          return function(elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
          };
        }),
        "lang": markFunction(function(lang) {
          if (!ridentifier.test(lang || "")) {
            Sizzle.error("unsupported lang: " + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function(elem) {
            var elemLang;
            do {
              if ((elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),
        "target": function(elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        "root": function(elem) {
          return elem === docElem;
        },
        "focus": function(elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        "enabled": createDisabledPseudo(false),
        "disabled": createDisabledPseudo(true),
        "checked": function(elem) {
          var nodeName = elem.nodeName.toLowerCase();
          return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
        },
        "selected": function(elem) {
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }
          return elem.selected === true;
        },
        "empty": function(elem) {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }
          return true;
        },
        "parent": function(elem) {
          return !Expr.pseudos["empty"](elem);
        },
        "header": function(elem) {
          return rheader.test(elem.nodeName);
        },
        "input": function(elem) {
          return rinputs.test(elem.nodeName);
        },
        "button": function(elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === "button" || name === "button";
        },
        "text": function(elem) {
          var attr;
          return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
        },
        "first": createPositionalPseudo(function() {
          return [0];
        }),
        "last": createPositionalPseudo(function(matchIndexes, length) {
          return [length - 1];
        }),
        "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        "even": createPositionalPseudo(function(matchIndexes, length) {
          var i = 0;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "odd": createPositionalPseudo(function(matchIndexes, length) {
          var i = 1;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; --i >= 0; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; ++i < length; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        })
      }
    };
    Expr.pseudos["nth"] = Expr.pseudos["eq"];
    for (i in {
      radio: true,
      checkbox: true,
      file: true,
      password: true,
      image: true
    }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in {
      submit: true,
      reset: true
    }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }
    function setFilters() {}
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    tokenize = Sizzle.tokenize = function(selector, parseOnly) {
      var matched,
          match,
          tokens,
          type,
          soFar,
          groups,
          preFilters,
          cached = tokenCache[selector + " "];
      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
      while (soFar) {
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push((tokens = []));
        }
        matched = false;
        if ((match = rcombinators.exec(soFar))) {
          matched = match.shift();
          tokens.push({
            value: matched,
            type: match[0].replace(rtrim, " ")
          });
          soFar = soFar.slice(matched.length);
        }
        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
    };
    function toSelector(tokens) {
      var i = 0,
          len = tokens.length,
          selector = "";
      for (; i < len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }
    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir,
          skip = combinator.next,
          key = skip || dir,
          checkNonElements = base && key === "parentNode",
          doneName = done++;
      return combinator.first ? function(elem, context, xml) {
        while ((elem = elem[dir])) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }
        return false;
      } : function(elem, context, xml) {
        var oldCache,
            uniqueCache,
            outerCache,
            newCache = [dirruns, doneName];
        if (xml) {
          while ((elem = elem[dir])) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while ((elem = elem[dir])) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});
              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
              if (skip && skip === elem.nodeName.toLowerCase()) {
                elem = elem[dir] || elem;
              } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                return (newCache[2] = oldCache[2]);
              } else {
                uniqueCache[key] = newCache;
                if ((newCache[2] = matcher(elem, context, xml))) {
                  return true;
                }
              }
            }
          }
        }
        return false;
      };
    }
    function elementMatcher(matchers) {
      return matchers.length > 1 ? function(elem, context, xml) {
        var i = matchers.length;
        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }
        return true;
      } : matchers[0];
    }
    function multipleContexts(selector, contexts, results) {
      var i = 0,
          len = contexts.length;
      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }
    function condense(unmatched, map, filter, context, xml) {
      var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;
      for (; i < len; i++) {
        if ((elem = unmatched[i])) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function(seed, results, context, xml) {
        var temp,
            i,
            elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,
            elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
            matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
            matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);
          i = temp.length;
          while (i--) {
            if ((elem = temp[i])) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }
        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if ((elem = matcherOut[i])) {
                  temp.push((matcherIn[i] = elem));
                }
              }
              postFinder(null, (matcherOut = []), temp, xml);
            }
            i = matcherOut.length;
            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          }
        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext,
          matcher,
          j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,
          matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true),
          matchAnyContext = addCombinator(function(elem) {
            return indexOf(checkContext, elem) > -1;
          }, implicitRelative, true),
          matchers = [function(elem, context, xml) {
            var ret = (!leadingRelative && (xml || context !== outermostContext)) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
      for (; i < len; i++) {
        if ((matcher = Expr.relative[tokens[i].type])) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
          if (matcher[expando]) {
            j = ++i;
            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({value: tokens[i - 2].type === " " ? "*" : ""})).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens((tokens = tokens.slice(j))), j < len && toSelector(tokens));
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function(seed, context, xml, results, outermost) {
            var elem,
                j,
                matcher,
                matchedCount = 0,
                i = "0",
                unmatched = seed && [],
                setMatched = [],
                contextBackup = outermostContext,
                elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                len = elems.length;
            if (outermost) {
              outermostContext = context === document || context || outermost;
            }
            for (; i !== len && (elem = elems[i]) != null; i++) {
              if (byElement && elem) {
                j = 0;
                if (!context && elem.ownerDocument !== document) {
                  setDocument(elem);
                  xml = !documentIsHTML;
                }
                while ((matcher = elementMatchers[j++])) {
                  if (matcher(elem, context || document, xml)) {
                    results.push(elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if ((elem = !matcher && elem)) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i;
            if (bySet && i !== matchedCount) {
              j = 0;
              while ((matcher = setMatchers[j++])) {
                matcher(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount > 0) {
                  while (i--) {
                    if (!(unmatched[i] || setMatched[i])) {
                      setMatched[i] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push.apply(results, setMatched);
              if (outermost && !seed && setMatched.length > 0 && (matchedCount + setMatchers.length) > 1) {
                Sizzle.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    compile = Sizzle.compile = function(selector, match) {
      var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[selector + " "];
      if (!cached) {
        if (!match) {
          match = tokenize(selector);
        }
        i = match.length;
        while (i--) {
          cached = matcherFromTokens(match[i]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }
        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
        cached.selector = selector;
      }
      return cached;
    };
    select = Sizzle.select = function(selector, context, results, seed) {
      var i,
          tokens,
          token,
          type,
          find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize((selector = compiled.selector || selector));
      results = results || [];
      if (match.length === 1) {
        tokens = match[0] = match[0].slice(0);
        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
          if (!context) {
            return results;
          } else if (compiled) {
            context = context.parentNode;
          }
          selector = selector.slice(tokens.shift().value.length);
        }
        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
        while (i--) {
          token = tokens[i];
          if (Expr.relative[(type = token.type)]) {
            break;
          }
          if ((find = Expr.find[type])) {
            if ((seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);
              if (!selector) {
                push.apply(results, seed);
                return results;
              }
              break;
            }
          }
        }
      }
      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
      return results;
    };
    support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
    support.detectDuplicates = !!hasDuplicate;
    setDocument();
    support.sortDetached = assert(function(el) {
      return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
    });
    if (!assert(function(el) {
      el.innerHTML = "<a href='#'></a>";
      return el.firstChild.getAttribute("href") === "#";
    })) {
      addHandle("type|href|height|width", function(elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        }
      });
    }
    if (!support.attributes || !assert(function(el) {
      el.innerHTML = "<input/>";
      el.firstChild.setAttribute("value", "");
      return el.firstChild.getAttribute("value") === "";
    })) {
      addHandle("value", function(elem, name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === "input") {
          return elem.defaultValue;
        }
      });
    }
    if (!assert(function(el) {
      return el.getAttribute("disabled") == null;
    })) {
      addHandle(booleans, function(elem, name, isXML) {
        var val;
        if (!isXML) {
          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }
      });
    }
    return Sizzle;
  })(window);
  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;
  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  jQuery.escapeSelector = Sizzle.escape;
  var dir = function(elem, dir, until) {
    var matched = [],
        truncate = until !== undefined;
    while ((elem = elem[dir]) && elem.nodeType !== 9) {
      if (elem.nodeType === 1) {
        if (truncate && jQuery(elem).is(until)) {
          break;
        }
        matched.push(elem);
      }
    }
    return matched;
  };
  var siblings = function(n, elem) {
    var matched = [];
    for (; n; n = n.nextSibling) {
      if (n.nodeType === 1 && n !== elem) {
        matched.push(n);
      }
    }
    return matched;
  };
  var rneedsContext = jQuery.expr.match.needsContext;
  var rsingleTag = (/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i);
  var risSimple = /^.[^:#\[\.,]*$/;
  function winnow(elements, qualifier, not) {
    if (jQuery.isFunction(qualifier)) {
      return jQuery.grep(elements, function(elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }
    if (qualifier.nodeType) {
      return jQuery.grep(elements, function(elem) {
        return (elem === qualifier) !== not;
      });
    }
    if (typeof qualifier !== "string") {
      return jQuery.grep(elements, function(elem) {
        return (indexOf.call(qualifier, elem) > -1) !== not;
      });
    }
    if (risSimple.test(qualifier)) {
      return jQuery.filter(qualifier, elements, not);
    }
    qualifier = jQuery.filter(qualifier, elements);
    return jQuery.grep(elements, function(elem) {
      return (indexOf.call(qualifier, elem) > -1) !== not && elem.nodeType === 1;
    });
  }
  jQuery.filter = function(expr, elems, not) {
    var elem = elems[0];
    if (not) {
      expr = ":not(" + expr + ")";
    }
    if (elems.length === 1 && elem.nodeType === 1) {
      return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
    }
    return jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
      return elem.nodeType === 1;
    }));
  };
  jQuery.fn.extend({
    find: function(selector) {
      var i,
          ret,
          len = this.length,
          self = this;
      if (typeof selector !== "string") {
        return this.pushStack(jQuery(selector).filter(function() {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }
      ret = this.pushStack([]);
      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }
      return len > 1 ? jQuery.uniqueSort(ret) : ret;
    },
    filter: function(selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function(selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function(selector) {
      return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    }
  });
  var rootjQuery,
      rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
      init = jQuery.fn.init = function(selector, context, root) {
        var match,
            elem;
        if (!selector) {
          return this;
        }
        root = root || rootjQuery;
        if (typeof selector === "string") {
          if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
            match = [null, selector, null];
          } else {
            match = rquickExpr.exec(selector);
          }
          if (match && (match[1] || !context)) {
            if (match[1]) {
              context = context instanceof jQuery ? context[0] : context;
              jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
              if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                for (match in context) {
                  if (jQuery.isFunction(this[match])) {
                    this[match](context[match]);
                  } else {
                    this.attr(match, context[match]);
                  }
                }
              }
              return this;
            } else {
              elem = document.getElementById(match[2]);
              if (elem) {
                this[0] = elem;
                this.length = 1;
              }
              return this;
            }
          } else if (!context || context.jquery) {
            return (context || root).find(selector);
          } else {
            return this.constructor(context).find(selector);
          }
        } else if (selector.nodeType) {
          this[0] = selector;
          this.length = 1;
          return this;
        } else if (jQuery.isFunction(selector)) {
          return root.ready !== undefined ? root.ready(selector) : selector(jQuery);
        }
        return jQuery.makeArray(selector, this);
      };
  init.prototype = jQuery.fn;
  rootjQuery = jQuery(document);
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
      guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
      };
  jQuery.fn.extend({
    has: function(target) {
      var targets = jQuery(target, this),
          l = targets.length;
      return this.filter(function() {
        var i = 0;
        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function(selectors, context) {
      var cur,
          i = 0,
          l = this.length,
          matched = [],
          targets = typeof selectors !== "string" && jQuery(selectors);
      if (!rneedsContext.test(selectors)) {
        for (; i < l; i++) {
          for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
            if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
              matched.push(cur);
              break;
            }
          }
        }
      }
      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
    },
    index: function(elem) {
      if (!elem) {
        return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
      }
      if (typeof elem === "string") {
        return indexOf.call(jQuery(elem), this[0]);
      }
      return indexOf.call(this, elem.jquery ? elem[0] : elem);
    },
    add: function(selector, context) {
      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
    },
    addBack: function(selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });
  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {}
    return cur;
  }
  jQuery.each({
    parent: function(elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function(elem) {
      return dir(elem, "parentNode");
    },
    parentsUntil: function(elem, i, until) {
      return dir(elem, "parentNode", until);
    },
    next: function(elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function(elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function(elem) {
      return dir(elem, "nextSibling");
    },
    prevAll: function(elem) {
      return dir(elem, "previousSibling");
    },
    nextUntil: function(elem, i, until) {
      return dir(elem, "nextSibling", until);
    },
    prevUntil: function(elem, i, until) {
      return dir(elem, "previousSibling", until);
    },
    siblings: function(elem) {
      return siblings((elem.parentNode || {}).firstChild, elem);
    },
    children: function(elem) {
      return siblings(elem.firstChild);
    },
    contents: function(elem) {
      return elem.contentDocument || jQuery.merge([], elem.childNodes);
    }
  }, function(name, fn) {
    jQuery.fn[name] = function(until, selector) {
      var matched = jQuery.map(this, fn, until);
      if (name.slice(-5) !== "Until") {
        selector = until;
      }
      if (selector && typeof selector === "string") {
        matched = jQuery.filter(selector, matched);
      }
      if (this.length > 1) {
        if (!guaranteedUnique[name]) {
          jQuery.uniqueSort(matched);
        }
        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }
      return this.pushStack(matched);
    };
  });
  var rnothtmlwhite = (/[^\x20\t\r\n\f]+/g);
  function createOptions(options) {
    var object = {};
    jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {
      object[flag] = true;
    });
    return object;
  }
  jQuery.Callbacks = function(options) {
    options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
    var firing,
        memory,
        fired,
        locked,
        list = [],
        queue = [],
        firingIndex = -1,
        fire = function() {
          locked = options.once;
          fired = firing = true;
          for (; queue.length; firingIndex = -1) {
            memory = queue.shift();
            while (++firingIndex < list.length) {
              if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                firingIndex = list.length;
                memory = false;
              }
            }
          }
          if (!options.memory) {
            memory = false;
          }
          firing = false;
          if (locked) {
            if (memory) {
              list = [];
            } else {
              list = "";
            }
          }
        },
        self = {
          add: function() {
            if (list) {
              if (memory && !firing) {
                firingIndex = list.length - 1;
                queue.push(memory);
              }
              (function add(args) {
                jQuery.each(args, function(_, arg) {
                  if (jQuery.isFunction(arg)) {
                    if (!options.unique || !self.has(arg)) {
                      list.push(arg);
                    }
                  } else if (arg && arg.length && jQuery.type(arg) !== "string") {
                    add(arg);
                  }
                });
              })(arguments);
              if (memory && !firing) {
                fire();
              }
            }
            return this;
          },
          remove: function() {
            jQuery.each(arguments, function(_, arg) {
              var index;
              while ((index = jQuery.inArray(arg, list, index)) > -1) {
                list.splice(index, 1);
                if (index <= firingIndex) {
                  firingIndex--;
                }
              }
            });
            return this;
          },
          has: function(fn) {
            return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
          },
          empty: function() {
            if (list) {
              list = [];
            }
            return this;
          },
          disable: function() {
            locked = queue = [];
            list = memory = "";
            return this;
          },
          disabled: function() {
            return !list;
          },
          lock: function() {
            locked = queue = [];
            if (!memory && !firing) {
              list = memory = "";
            }
            return this;
          },
          locked: function() {
            return !!locked;
          },
          fireWith: function(context, args) {
            if (!locked) {
              args = args || [];
              args = [context, args.slice ? args.slice() : args];
              queue.push(args);
              if (!firing) {
                fire();
              }
            }
            return this;
          },
          fire: function() {
            self.fireWith(this, arguments);
            return this;
          },
          fired: function() {
            return !!fired;
          }
        };
    return self;
  };
  function Identity(v) {
    return v;
  }
  function Thrower(ex) {
    throw ex;
  }
  function adoptValue(value, resolve, reject) {
    var method;
    try {
      if (value && jQuery.isFunction((method = value.promise))) {
        method.call(value).done(resolve).fail(reject);
      } else if (value && jQuery.isFunction((method = value.then))) {
        method.call(value, resolve, reject);
      } else {
        resolve.call(undefined, value);
      }
    } catch (value) {
      reject.call(undefined, value);
    }
  }
  jQuery.extend({
    Deferred: function(func) {
      var tuples = [["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]],
          state = "pending",
          promise = {
            state: function() {
              return state;
            },
            always: function() {
              deferred.done(arguments).fail(arguments);
              return this;
            },
            "catch": function(fn) {
              return promise.then(null, fn);
            },
            pipe: function() {
              var fns = arguments;
              return jQuery.Deferred(function(newDefer) {
                jQuery.each(tuples, function(i, tuple) {
                  var fn = jQuery.isFunction(fns[tuple[4]]) && fns[tuple[4]];
                  deferred[tuple[1]](function() {
                    var returned = fn && fn.apply(this, arguments);
                    if (returned && jQuery.isFunction(returned.promise)) {
                      returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                    } else {
                      newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
                    }
                  });
                });
                fns = null;
              }).promise();
            },
            then: function(onFulfilled, onRejected, onProgress) {
              var maxDepth = 0;
              function resolve(depth, deferred, handler, special) {
                return function() {
                  var that = this,
                      args = arguments,
                      mightThrow = function() {
                        var returned,
                            then;
                        if (depth < maxDepth) {
                          return;
                        }
                        returned = handler.apply(that, args);
                        if (returned === deferred.promise()) {
                          throw new TypeError("Thenable self-resolution");
                        }
                        then = returned && (typeof returned === "object" || typeof returned === "function") && returned.then;
                        if (jQuery.isFunction(then)) {
                          if (special) {
                            then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));
                          } else {
                            maxDepth++;
                            then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                          }
                        } else {
                          if (handler !== Identity) {
                            that = undefined;
                            args = [returned];
                          }
                          (special || deferred.resolveWith)(that, args);
                        }
                      },
                      process = special ? mightThrow : function() {
                        try {
                          mightThrow();
                        } catch (e) {
                          if (jQuery.Deferred.exceptionHook) {
                            jQuery.Deferred.exceptionHook(e, process.stackTrace);
                          }
                          if (depth + 1 >= maxDepth) {
                            if (handler !== Thrower) {
                              that = undefined;
                              args = [e];
                            }
                            deferred.rejectWith(that, args);
                          }
                        }
                      };
                  if (depth) {
                    process();
                  } else {
                    if (jQuery.Deferred.getStackHook) {
                      process.stackTrace = jQuery.Deferred.getStackHook();
                    }
                    window.setTimeout(process);
                  }
                };
              }
              return jQuery.Deferred(function(newDefer) {
                tuples[0][3].add(resolve(0, newDefer, jQuery.isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));
                tuples[1][3].add(resolve(0, newDefer, jQuery.isFunction(onFulfilled) ? onFulfilled : Identity));
                tuples[2][3].add(resolve(0, newDefer, jQuery.isFunction(onRejected) ? onRejected : Thrower));
              }).promise();
            },
            promise: function(obj) {
              return obj != null ? jQuery.extend(obj, promise) : promise;
            }
          },
          deferred = {};
      jQuery.each(tuples, function(i, tuple) {
        var list = tuple[2],
            stateString = tuple[5];
        promise[tuple[1]] = list.add;
        if (stateString) {
          list.add(function() {
            state = stateString;
          }, tuples[3 - i][2].disable, tuples[0][2].lock);
        }
        list.add(tuple[3].fire);
        deferred[tuple[0]] = function() {
          deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
          return this;
        };
        deferred[tuple[0] + "With"] = list.fireWith;
      });
      promise.promise(deferred);
      if (func) {
        func.call(deferred, deferred);
      }
      return deferred;
    },
    when: function(singleValue) {
      var remaining = arguments.length,
          i = remaining,
          resolveContexts = Array(i),
          resolveValues = slice.call(arguments),
          master = jQuery.Deferred(),
          updateFunc = function(i) {
            return function(value) {
              resolveContexts[i] = this;
              resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
              if (!(--remaining)) {
                master.resolveWith(resolveContexts, resolveValues);
              }
            };
          };
      if (remaining <= 1) {
        adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject);
        if (master.state() === "pending" || jQuery.isFunction(resolveValues[i] && resolveValues[i].then)) {
          return master.then();
        }
      }
      while (i--) {
        adoptValue(resolveValues[i], updateFunc(i), master.reject);
      }
      return master.promise();
    }
  });
  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
  jQuery.Deferred.exceptionHook = function(error, stack) {
    if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
      window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
    }
  };
  jQuery.readyException = function(error) {
    window.setTimeout(function() {
      throw error;
    });
  };
  var readyList = jQuery.Deferred();
  jQuery.fn.ready = function(fn) {
    readyList.then(fn).catch(function(error) {
      jQuery.readyException(error);
    });
    return this;
  };
  jQuery.extend({
    isReady: false,
    readyWait: 1,
    holdReady: function(hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    },
    ready: function(wait) {
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      }
      jQuery.isReady = true;
      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      }
      readyList.resolveWith(document, [jQuery]);
    }
  });
  jQuery.ready.then = readyList.then;
  function completed() {
    document.removeEventListener("DOMContentLoaded", completed);
    window.removeEventListener("load", completed);
    jQuery.ready();
  }
  if (document.readyState === "complete" || (document.readyState !== "loading" && !document.documentElement.doScroll)) {
    window.setTimeout(jQuery.ready);
  } else {
    document.addEventListener("DOMContentLoaded", completed);
    window.addEventListener("load", completed);
  }
  var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
        len = elems.length,
        bulk = key == null;
    if (jQuery.type(key) === "object") {
      chainable = true;
      for (i in key) {
        access(elems, fn, i, key[i], true, emptyGet, raw);
      }
    } else if (value !== undefined) {
      chainable = true;
      if (!jQuery.isFunction(value)) {
        raw = true;
      }
      if (bulk) {
        if (raw) {
          fn.call(elems, value);
          fn = null;
        } else {
          bulk = fn;
          fn = function(elem, key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }
      if (fn) {
        for (; i < len; i++) {
          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
      }
    }
    if (chainable) {
      return elems;
    }
    if (bulk) {
      return fn.call(elems);
    }
    return len ? fn(elems[0], key) : emptyGet;
  };
  var acceptData = function(owner) {
    return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
  };
  function Data() {
    this.expando = jQuery.expando + Data.uid++;
  }
  Data.uid = 1;
  Data.prototype = {
    cache: function(owner) {
      var value = owner[this.expando];
      if (!value) {
        value = {};
        if (acceptData(owner)) {
          if (owner.nodeType) {
            owner[this.expando] = value;
          } else {
            Object.defineProperty(owner, this.expando, {
              value: value,
              configurable: true
            });
          }
        }
      }
      return value;
    },
    set: function(owner, data, value) {
      var prop,
          cache = this.cache(owner);
      if (typeof data === "string") {
        cache[jQuery.camelCase(data)] = value;
      } else {
        for (prop in data) {
          cache[jQuery.camelCase(prop)] = data[prop];
        }
      }
      return cache;
    },
    get: function(owner, key) {
      return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][jQuery.camelCase(key)];
    },
    access: function(owner, key, value) {
      if (key === undefined || ((key && typeof key === "string") && value === undefined)) {
        return this.get(owner, key);
      }
      this.set(owner, key, value);
      return value !== undefined ? value : key;
    },
    remove: function(owner, key) {
      var i,
          cache = owner[this.expando];
      if (cache === undefined) {
        return;
      }
      if (key !== undefined) {
        if (jQuery.isArray(key)) {
          key = key.map(jQuery.camelCase);
        } else {
          key = jQuery.camelCase(key);
          key = key in cache ? [key] : (key.match(rnothtmlwhite) || []);
        }
        i = key.length;
        while (i--) {
          delete cache[key[i]];
        }
      }
      if (key === undefined || jQuery.isEmptyObject(cache)) {
        if (owner.nodeType) {
          owner[this.expando] = undefined;
        } else {
          delete owner[this.expando];
        }
      }
    },
    hasData: function(owner) {
      var cache = owner[this.expando];
      return cache !== undefined && !jQuery.isEmptyObject(cache);
    }
  };
  var dataPriv = new Data();
  var dataUser = new Data();
  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      rmultiDash = /[A-Z]/g;
  function getData(data) {
    if (data === "true") {
      return true;
    }
    if (data === "false") {
      return false;
    }
    if (data === "null") {
      return null;
    }
    if (data === +data + "") {
      return +data;
    }
    if (rbrace.test(data)) {
      return JSON.parse(data);
    }
    return data;
  }
  function dataAttr(elem, key, data) {
    var name;
    if (data === undefined && elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
      data = elem.getAttribute(name);
      if (typeof data === "string") {
        try {
          data = getData(data);
        } catch (e) {}
        dataUser.set(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }
  jQuery.extend({
    hasData: function(elem) {
      return dataUser.hasData(elem) || dataPriv.hasData(elem);
    },
    data: function(elem, name, data) {
      return dataUser.access(elem, name, data);
    },
    removeData: function(elem, name) {
      dataUser.remove(elem, name);
    },
    _data: function(elem, name, data) {
      return dataPriv.access(elem, name, data);
    },
    _removeData: function(elem, name) {
      dataPriv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function(key, value) {
      var i,
          name,
          data,
          elem = this[0],
          attrs = elem && elem.attributes;
      if (key === undefined) {
        if (this.length) {
          data = dataUser.get(elem);
          if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
            i = attrs.length;
            while (i--) {
              if (attrs[i]) {
                name = attrs[i].name;
                if (name.indexOf("data-") === 0) {
                  name = jQuery.camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }
            dataPriv.set(elem, "hasDataAttrs", true);
          }
        }
        return data;
      }
      if (typeof key === "object") {
        return this.each(function() {
          dataUser.set(this, key);
        });
      }
      return access(this, function(value) {
        var data;
        if (elem && value === undefined) {
          data = dataUser.get(elem, key);
          if (data !== undefined) {
            return data;
          }
          data = dataAttr(elem, key);
          if (data !== undefined) {
            return data;
          }
          return;
        }
        this.each(function() {
          dataUser.set(this, key, value);
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function(key) {
      return this.each(function() {
        dataUser.remove(this, key);
      });
    }
  });
  jQuery.extend({
    queue: function(elem, type, data) {
      var queue;
      if (elem) {
        type = (type || "fx") + "queue";
        queue = dataPriv.get(elem, type);
        if (data) {
          if (!queue || jQuery.isArray(data)) {
            queue = dataPriv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },
    dequeue: function(elem, type) {
      type = type || "fx";
      var queue = jQuery.queue(elem, type),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = jQuery._queueHooks(elem, type),
          next = function() {
            jQuery.dequeue(elem, type);
          };
      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }
      if (fn) {
        if (type === "fx") {
          queue.unshift("inprogress");
        }
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }
      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    _queueHooks: function(elem, type) {
      var key = type + "queueHooks";
      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {empty: jQuery.Callbacks("once memory").add(function() {
          dataPriv.remove(elem, [type + "queue", key]);
        })});
    }
  });
  jQuery.fn.extend({
    queue: function(type, data) {
      var setter = 2;
      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }
      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }
      return data === undefined ? this : this.each(function() {
        var queue = jQuery.queue(this, type, data);
        jQuery._queueHooks(this, type);
        if (type === "fx" && queue[0] !== "inprogress") {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function(type) {
      return this.each(function() {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function(type) {
      return this.queue(type || "fx", []);
    },
    promise: function(type, obj) {
      var tmp,
          count = 1,
          defer = jQuery.Deferred(),
          elements = this,
          i = this.length,
          resolve = function() {
            if (!(--count)) {
              defer.resolveWith(elements, [elements]);
            }
          };
      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }
      type = type || "fx";
      while (i--) {
        tmp = dataPriv.get(elements[i], type + "queueHooks");
        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    }
  });
  var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
  var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
  var cssExpand = ["Top", "Right", "Bottom", "Left"];
  var isHiddenWithinTree = function(elem, el) {
    elem = el || elem;
    return elem.style.display === "none" || elem.style.display === "" && jQuery.contains(elem.ownerDocument, elem) && jQuery.css(elem, "display") === "none";
  };
  var swap = function(elem, options, callback, args) {
    var ret,
        name,
        old = {};
    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }
    ret = callback.apply(elem, args || []);
    for (name in options) {
      elem.style[name] = old[name];
    }
    return ret;
  };
  function adjustCSS(elem, prop, valueParts, tween) {
    var adjusted,
        scale = 1,
        maxIterations = 20,
        currentValue = tween ? function() {
          return tween.cur();
        } : function() {
          return jQuery.css(elem, prop, "");
        },
        initial = currentValue(),
        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
        initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
    if (initialInUnit && initialInUnit[3] !== unit) {
      unit = unit || initialInUnit[3];
      valueParts = valueParts || [];
      initialInUnit = +initial || 1;
      do {
        scale = scale || ".5";
        initialInUnit = initialInUnit / scale;
        jQuery.style(elem, prop, initialInUnit + unit);
      } while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);
    }
    if (valueParts) {
      initialInUnit = +initialInUnit || +initial || 0;
      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
      if (tween) {
        tween.unit = unit;
        tween.start = initialInUnit;
        tween.end = adjusted;
      }
    }
    return adjusted;
  }
  var defaultDisplayMap = {};
  function getDefaultDisplay(elem) {
    var temp,
        doc = elem.ownerDocument,
        nodeName = elem.nodeName,
        display = defaultDisplayMap[nodeName];
    if (display) {
      return display;
    }
    temp = doc.body.appendChild(doc.createElement(nodeName));
    display = jQuery.css(temp, "display");
    temp.parentNode.removeChild(temp);
    if (display === "none") {
      display = "block";
    }
    defaultDisplayMap[nodeName] = display;
    return display;
  }
  function showHide(elements, show) {
    var display,
        elem,
        values = [],
        index = 0,
        length = elements.length;
    for (; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      display = elem.style.display;
      if (show) {
        if (display === "none") {
          values[index] = dataPriv.get(elem, "display") || null;
          if (!values[index]) {
            elem.style.display = "";
          }
        }
        if (elem.style.display === "" && isHiddenWithinTree(elem)) {
          values[index] = getDefaultDisplay(elem);
        }
      } else {
        if (display !== "none") {
          values[index] = "none";
          dataPriv.set(elem, "display", display);
        }
      }
    }
    for (index = 0; index < length; index++) {
      if (values[index] != null) {
        elements[index].style.display = values[index];
      }
    }
    return elements;
  }
  jQuery.fn.extend({
    show: function() {
      return showHide(this, true);
    },
    hide: function() {
      return showHide(this);
    },
    toggle: function(state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }
      return this.each(function() {
        if (isHiddenWithinTree(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  var rcheckableType = (/^(?:checkbox|radio)$/i);
  var rtagName = (/<([a-z][^\/\0>\x20\t\r\n\f]+)/i);
  var rscriptType = (/^$|\/(?:java|ecma)script/i);
  var wrapMap = {
    option: [1, "<select multiple='multiple'>", "</select>"],
    thead: [1, "<table>", "</table>"],
    col: [2, "<table><colgroup>", "</colgroup></table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    _default: [0, "", ""]
  };
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;
  function getAll(context, tag) {
    var ret;
    if (typeof context.getElementsByTagName !== "undefined") {
      ret = context.getElementsByTagName(tag || "*");
    } else if (typeof context.querySelectorAll !== "undefined") {
      ret = context.querySelectorAll(tag || "*");
    } else {
      ret = [];
    }
    if (tag === undefined || tag && jQuery.nodeName(context, tag)) {
      return jQuery.merge([context], ret);
    }
    return ret;
  }
  function setGlobalEval(elems, refElements) {
    var i = 0,
        l = elems.length;
    for (; i < l; i++) {
      dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
    }
  }
  var rhtml = /<|&#?\w+;/;
  function buildFragment(elems, context, scripts, selection, ignored) {
    var elem,
        tmp,
        tag,
        wrap,
        contains,
        j,
        fragment = context.createDocumentFragment(),
        nodes = [],
        i = 0,
        l = elems.length;
    for (; i < l; i++) {
      elem = elems[i];
      if (elem || elem === 0) {
        if (jQuery.type(elem) === "object") {
          jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
        } else if (!rhtml.test(elem)) {
          nodes.push(context.createTextNode(elem));
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div"));
          tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
          j = wrap[0];
          while (j--) {
            tmp = tmp.lastChild;
          }
          jQuery.merge(nodes, tmp.childNodes);
          tmp = fragment.firstChild;
          tmp.textContent = "";
        }
      }
    }
    fragment.textContent = "";
    i = 0;
    while ((elem = nodes[i++])) {
      if (selection && jQuery.inArray(elem, selection) > -1) {
        if (ignored) {
          ignored.push(elem);
        }
        continue;
      }
      contains = jQuery.contains(elem.ownerDocument, elem);
      tmp = getAll(fragment.appendChild(elem), "script");
      if (contains) {
        setGlobalEval(tmp);
      }
      if (scripts) {
        j = 0;
        while ((elem = tmp[j++])) {
          if (rscriptType.test(elem.type || "")) {
            scripts.push(elem);
          }
        }
      }
    }
    return fragment;
  }
  (function() {
    var fragment = document.createDocumentFragment(),
        div = fragment.appendChild(document.createElement("div")),
        input = document.createElement("input");
    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");
    div.appendChild(input);
    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
  })();
  var documentElement = document.documentElement;
  var rkeyEvent = /^key/,
      rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
      rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }
  function on(elem, types, selector, data, fn, one) {
    var origFn,
        type;
    if (typeof types === "object") {
      if (typeof selector !== "string") {
        data = data || selector;
        selector = undefined;
      }
      for (type in types) {
        on(elem, type, selector, data, types[type], one);
      }
      return elem;
    }
    if (data == null && fn == null) {
      fn = selector;
      data = selector = undefined;
    } else if (fn == null) {
      if (typeof selector === "string") {
        fn = data;
        data = undefined;
      } else {
        fn = data;
        data = selector;
        selector = undefined;
      }
    }
    if (fn === false) {
      fn = returnFalse;
    } else if (!fn) {
      return elem;
    }
    if (one === 1) {
      origFn = fn;
      fn = function(event) {
        jQuery().off(event);
        return origFn.apply(this, arguments);
      };
      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
    }
    return elem.each(function() {
      jQuery.event.add(this, types, fn, data, selector);
    });
  }
  jQuery.event = {
    global: {},
    add: function(elem, types, handler, data, selector) {
      var handleObjIn,
          eventHandle,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.get(elem);
      if (!elemData) {
        return;
      }
      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }
      if (selector) {
        jQuery.find.matchesSelector(documentElement, selector);
      }
      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      }
      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function(e) {
          return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
        };
      }
      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        special = jQuery.event.special[type] || {};
        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn);
        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;
          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle);
            }
          }
        }
        if (special.add) {
          special.add.call(elem, handleObj);
          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }
        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }
        jQuery.event.global[type] = true;
      }
    },
    remove: function(elem, types, handler, selector, mappedTypes) {
      var j,
          origCount,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
      if (!elemData || !(events = elemData.events)) {
        return;
      }
      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
        origCount = j = handlers.length;
        while (j--) {
          handleObj = handlers[j];
          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
            handlers.splice(j, 1);
            if (handleObj.selector) {
              handlers.delegateCount--;
            }
            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }
        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }
          delete events[type];
        }
      }
      if (jQuery.isEmptyObject(events)) {
        dataPriv.remove(elem, "handle events");
      }
    },
    dispatch: function(nativeEvent) {
      var event = jQuery.event.fix(nativeEvent);
      var i,
          j,
          ret,
          matched,
          handleObj,
          handlerQueue,
          args = new Array(arguments.length),
          handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
          special = jQuery.event.special[event.type] || {};
      args[0] = event;
      for (i = 1; i < arguments.length; i++) {
        args[i] = arguments[i];
      }
      event.delegateTarget = this;
      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      }
      handlerQueue = jQuery.event.handlers.call(this, event, handlers);
      i = 0;
      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;
        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }
      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }
      return event.result;
    },
    handlers: function(event, handlers) {
      var i,
          handleObj,
          sel,
          matchedHandlers,
          matchedSelectors,
          handlerQueue = [],
          delegateCount = handlers.delegateCount,
          cur = event.target;
      if (delegateCount && cur.nodeType && !(event.type === "click" && event.button >= 1)) {
        for (; cur !== this; cur = cur.parentNode || this) {
          if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
            matchedHandlers = [];
            matchedSelectors = {};
            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i];
              sel = handleObj.selector + " ";
              if (matchedSelectors[sel] === undefined) {
                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
              }
              if (matchedSelectors[sel]) {
                matchedHandlers.push(handleObj);
              }
            }
            if (matchedHandlers.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matchedHandlers
              });
            }
          }
        }
      }
      cur = this;
      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: cur,
          handlers: handlers.slice(delegateCount)
        });
      }
      return handlerQueue;
    },
    addProp: function(name, hook) {
      Object.defineProperty(jQuery.Event.prototype, name, {
        enumerable: true,
        configurable: true,
        get: jQuery.isFunction(hook) ? function() {
          if (this.originalEvent) {
            return hook(this.originalEvent);
          }
        } : function() {
          if (this.originalEvent) {
            return this.originalEvent[name];
          }
        },
        set: function(value) {
          Object.defineProperty(this, name, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: value
          });
        }
      });
    },
    fix: function(originalEvent) {
      return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
    },
    special: {
      load: {noBubble: true},
      focus: {
        trigger: function() {
          if (this !== safeActiveElement() && this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function() {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: "focusout"
      },
      click: {
        trigger: function() {
          if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
            this.click();
            return false;
          }
        },
        _default: function(event) {
          return jQuery.nodeName(event.target, "a");
        }
      },
      beforeunload: {postDispatch: function(event) {
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }}
    }
  };
  jQuery.removeEvent = function(elem, type, handle) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle);
    }
  };
  jQuery.Event = function(src, props) {
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }
    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type;
      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
      this.target = (src.target && src.target.nodeType === 3) ? src.target.parentNode : src.target;
      this.currentTarget = src.currentTarget;
      this.relatedTarget = src.relatedTarget;
    } else {
      this.type = src;
    }
    if (props) {
      jQuery.extend(this, props);
    }
    this.timeStamp = src && src.timeStamp || jQuery.now();
    this[jQuery.expando] = true;
  };
  jQuery.Event.prototype = {
    constructor: jQuery.Event,
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    isSimulated: false,
    preventDefault: function() {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;
      if (e && !this.isSimulated) {
        e.preventDefault();
      }
    },
    stopPropagation: function() {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;
      if (e && !this.isSimulated) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function() {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;
      if (e && !this.isSimulated) {
        e.stopImmediatePropagation();
      }
      this.stopPropagation();
    }
  };
  jQuery.each({
    altKey: true,
    bubbles: true,
    cancelable: true,
    changedTouches: true,
    ctrlKey: true,
    detail: true,
    eventPhase: true,
    metaKey: true,
    pageX: true,
    pageY: true,
    shiftKey: true,
    view: true,
    "char": true,
    charCode: true,
    key: true,
    keyCode: true,
    button: true,
    buttons: true,
    clientX: true,
    clientY: true,
    offsetX: true,
    offsetY: true,
    pointerId: true,
    pointerType: true,
    screenX: true,
    screenY: true,
    targetTouches: true,
    toElement: true,
    touches: true,
    which: function(event) {
      var button = event.button;
      if (event.which == null && rkeyEvent.test(event.type)) {
        return event.charCode != null ? event.charCode : event.keyCode;
      }
      if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
        if (button & 1) {
          return 1;
        }
        if (button & 2) {
          return 3;
        }
        if (button & 4) {
          return 2;
        }
        return 0;
      }
      return event.which;
    }
  }, jQuery.event.addProp);
  jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function(orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function(event) {
        var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj;
        if (!related || (related !== target && !jQuery.contains(target, related))) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }
        return ret;
      }
    };
  });
  jQuery.fn.extend({
    on: function(types, selector, data, fn) {
      return on(this, types, selector, data, fn);
    },
    one: function(types, selector, data, fn) {
      return on(this, types, selector, data, fn, 1);
    },
    off: function(types, selector, fn) {
      var handleObj,
          type;
      if (types && types.preventDefault && types.handleObj) {
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }
      if (typeof types === "object") {
        for (type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if (selector === false || typeof selector === "function") {
        fn = selector;
        selector = undefined;
      }
      if (fn === false) {
        fn = returnFalse;
      }
      return this.each(function() {
        jQuery.event.remove(this, types, fn, selector);
      });
    }
  });
  var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
      rnoInnerhtml = /<script|<style|<link/i,
      rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
      rscriptTypeMasked = /^true\/(.*)/,
      rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
  function manipulationTarget(elem, content) {
    if (jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
      return elem.getElementsByTagName("tbody")[0] || elem;
    }
    return elem;
  }
  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }
  function restoreScript(elem) {
    var match = rscriptTypeMasked.exec(elem.type);
    if (match) {
      elem.type = match[1];
    } else {
      elem.removeAttribute("type");
    }
    return elem;
  }
  function cloneCopyEvent(src, dest) {
    var i,
        l,
        type,
        pdataOld,
        pdataCur,
        udataOld,
        udataCur,
        events;
    if (dest.nodeType !== 1) {
      return;
    }
    if (dataPriv.hasData(src)) {
      pdataOld = dataPriv.access(src);
      pdataCur = dataPriv.set(dest, pdataOld);
      events = pdataOld.events;
      if (events) {
        delete pdataCur.handle;
        pdataCur.events = {};
        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    }
    if (dataUser.hasData(src)) {
      udataOld = dataUser.access(src);
      udataCur = jQuery.extend({}, udataOld);
      dataUser.set(dest, udataCur);
    }
  }
  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase();
    if (nodeName === "input" && rcheckableType.test(src.type)) {
      dest.checked = src.checked;
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }
  function domManip(collection, args, callback, ignored) {
    args = concat.apply([], args);
    var fragment,
        first,
        scripts,
        hasScripts,
        node,
        doc,
        i = 0,
        l = collection.length,
        iNoClone = l - 1,
        value = args[0],
        isFunction = jQuery.isFunction(value);
    if (isFunction || (l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value))) {
      return collection.each(function(index) {
        var self = collection.eq(index);
        if (isFunction) {
          args[0] = value.call(this, index, self.html());
        }
        domManip(self, args, callback, ignored);
      });
    }
    if (l) {
      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
      first = fragment.firstChild;
      if (fragment.childNodes.length === 1) {
        fragment = first;
      }
      if (first || ignored) {
        scripts = jQuery.map(getAll(fragment, "script"), disableScript);
        hasScripts = scripts.length;
        for (; i < l; i++) {
          node = fragment;
          if (i !== iNoClone) {
            node = jQuery.clone(node, true, true);
            if (hasScripts) {
              jQuery.merge(scripts, getAll(node, "script"));
            }
          }
          callback.call(collection[i], node, i);
        }
        if (hasScripts) {
          doc = scripts[scripts.length - 1].ownerDocument;
          jQuery.map(scripts, restoreScript);
          for (i = 0; i < hasScripts; i++) {
            node = scripts[i];
            if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
              if (node.src) {
                if (jQuery._evalUrl) {
                  jQuery._evalUrl(node.src);
                }
              } else {
                DOMEval(node.textContent.replace(rcleanScript, ""), doc);
              }
            }
          }
        }
      }
    }
    return collection;
  }
  function remove(elem, selector, keepData) {
    var node,
        nodes = selector ? jQuery.filter(selector, elem) : elem,
        i = 0;
    for (; (node = nodes[i]) != null; i++) {
      if (!keepData && node.nodeType === 1) {
        jQuery.cleanData(getAll(node));
      }
      if (node.parentNode) {
        if (keepData && jQuery.contains(node.ownerDocument, node)) {
          setGlobalEval(getAll(node, "script"));
        }
        node.parentNode.removeChild(node);
      }
    }
    return elem;
  }
  jQuery.extend({
    htmlPrefilter: function(html) {
      return html.replace(rxhtmlTag, "<$1></$2>");
    },
    clone: function(elem, dataAndEvents, deepDataAndEvents) {
      var i,
          l,
          srcElements,
          destElements,
          clone = elem.cloneNode(true),
          inPage = jQuery.contains(elem.ownerDocument, elem);
      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        destElements = getAll(clone);
        srcElements = getAll(elem);
        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      }
      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);
          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }
      destElements = getAll(clone, "script");
      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      }
      return clone;
    },
    cleanData: function(elems) {
      var data,
          elem,
          type,
          special = jQuery.event.special,
          i = 0;
      for (; (elem = elems[i]) !== undefined; i++) {
        if (acceptData(elem)) {
          if ((data = elem[dataPriv.expando])) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type);
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            }
            elem[dataPriv.expando] = undefined;
          }
          if (elem[dataUser.expando]) {
            elem[dataUser.expando] = undefined;
          }
        }
      }
    }
  });
  jQuery.fn.extend({
    detach: function(selector) {
      return remove(this, selector, true);
    },
    remove: function(selector) {
      return remove(this, selector);
    },
    text: function(value) {
      return access(this, function(value) {
        return value === undefined ? jQuery.text(this) : this.empty().each(function() {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            this.textContent = value;
          }
        });
      }, null, value, arguments.length);
    },
    append: function() {
      return domManip(this, arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function() {
      return domManip(this, arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function() {
      return domManip(this, arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function() {
      return domManip(this, arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    empty: function() {
      var elem,
          i = 0;
      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem, false));
          elem.textContent = "";
        }
      }
      return this;
    },
    clone: function(dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function() {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function(value) {
      return access(this, function(value) {
        var elem = this[0] || {},
            i = 0,
            l = this.length;
        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        }
        if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
          value = jQuery.htmlPrefilter(value);
          try {
            for (; i < l; i++) {
              elem = this[i] || {};
              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }
            elem = 0;
          } catch (e) {}
        }
        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function() {
      var ignored = [];
      return domManip(this, arguments, function(elem) {
        var parent = this.parentNode;
        if (jQuery.inArray(this, ignored) < 0) {
          jQuery.cleanData(getAll(this));
          if (parent) {
            parent.replaceChild(elem, this);
          }
        }
      }, ignored);
    }
  });
  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function(name, original) {
    jQuery.fn[name] = function(selector) {
      var elems,
          ret = [],
          insert = jQuery(selector),
          last = insert.length - 1,
          i = 0;
      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems);
        push.apply(ret, elems.get());
      }
      return this.pushStack(ret);
    };
  });
  var rmargin = (/^margin/);
  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
  var getStyles = function(elem) {
    var view = elem.ownerDocument.defaultView;
    if (!view || !view.opener) {
      view = window;
    }
    return view.getComputedStyle(elem);
  };
  (function() {
    function computeStyleTests() {
      if (!div) {
        return;
      }
      div.style.cssText = "box-sizing:border-box;" + "position:relative;display:block;" + "margin:auto;border:1px;padding:1px;" + "top:1%;width:50%";
      div.innerHTML = "";
      documentElement.appendChild(container);
      var divStyle = window.getComputedStyle(div);
      pixelPositionVal = divStyle.top !== "1%";
      reliableMarginLeftVal = divStyle.marginLeft === "2px";
      boxSizingReliableVal = divStyle.width === "4px";
      div.style.marginRight = "50%";
      pixelMarginRightVal = divStyle.marginRight === "4px";
      documentElement.removeChild(container);
      div = null;
    }
    var pixelPositionVal,
        boxSizingReliableVal,
        pixelMarginRightVal,
        reliableMarginLeftVal,
        container = document.createElement("div"),
        div = document.createElement("div");
    if (!div.style) {
      return;
    }
    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";
    container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" + "padding:0;margin-top:1px;position:absolute";
    container.appendChild(div);
    jQuery.extend(support, {
      pixelPosition: function() {
        computeStyleTests();
        return pixelPositionVal;
      },
      boxSizingReliable: function() {
        computeStyleTests();
        return boxSizingReliableVal;
      },
      pixelMarginRight: function() {
        computeStyleTests();
        return pixelMarginRightVal;
      },
      reliableMarginLeft: function() {
        computeStyleTests();
        return reliableMarginLeftVal;
      }
    });
  })();
  function curCSS(elem, name, computed) {
    var width,
        minWidth,
        maxWidth,
        ret,
        style = elem.style;
    computed = computed || getStyles(elem);
    if (computed) {
      ret = computed.getPropertyValue(name) || computed[name];
      if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
        ret = jQuery.style(elem, name);
      }
      if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }
    return ret !== undefined ? ret + "" : ret;
  }
  function addGetHookIf(conditionFn, hookFn) {
    return {get: function() {
        if (conditionFn()) {
          delete this.get;
          return;
        }
        return (this.get = hookFn).apply(this, arguments);
      }};
  }
  var rdisplayswap = /^(none|table(?!-c[ea]).+)/,
      cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
      },
      cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
      },
      cssPrefixes = ["Webkit", "Moz", "ms"],
      emptyStyle = document.createElement("div").style;
  function vendorPropName(name) {
    if (name in emptyStyle) {
      return name;
    }
    var capName = name[0].toUpperCase() + name.slice(1),
        i = cssPrefixes.length;
    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in emptyStyle) {
        return name;
      }
    }
  }
  function setPositiveNumber(elem, value, subtract) {
    var matches = rcssNum.exec(value);
    return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
  }
  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
    var i,
        val = 0;
    if (extra === (isBorderBox ? "border" : "content")) {
      i = 4;
    } else {
      i = name === "width" ? 1 : 0;
    }
    for (; i < 4; i += 2) {
      if (extra === "margin") {
        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
      }
      if (isBorderBox) {
        if (extra === "content") {
          val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        }
        if (extra !== "margin") {
          val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      } else {
        val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        if (extra !== "padding") {
          val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      }
    }
    return val;
  }
  function getWidthOrHeight(elem, name, extra) {
    var val,
        valueIsBorderBox = true,
        styles = getStyles(elem),
        isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
    if (elem.getClientRects().length) {
      val = elem.getBoundingClientRect()[name];
    }
    if (val <= 0 || val == null) {
      val = curCSS(elem, name, styles);
      if (val < 0 || val == null) {
        val = elem.style[name];
      }
      if (rnumnonpx.test(val)) {
        return val;
      }
      valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
      val = parseFloat(val) || 0;
    }
    return (val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles)) + "px";
  }
  jQuery.extend({
    cssHooks: {opacity: {get: function(elem, computed) {
          if (computed) {
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }}},
    cssNumber: {
      "animationIterationCount": true,
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
    cssProps: {"float": "cssFloat"},
    style: function(elem, name, value, extra) {
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      }
      var ret,
          type,
          hooks,
          origName = jQuery.camelCase(name),
          style = elem.style;
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (value !== undefined) {
        type = typeof value;
        if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
          value = adjustCSS(elem, name, ret);
          type = "number";
        }
        if (value == null || value !== value) {
          return;
        }
        if (type === "number") {
          value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
        }
        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
          style[name] = "inherit";
        }
        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          style[name] = value;
        }
      } else {
        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        }
        return style[name];
      }
    },
    css: function(elem, name, extra, styles) {
      var val,
          num,
          hooks,
          origName = jQuery.camelCase(name);
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      }
      if (val === undefined) {
        val = curCSS(elem, name, styles);
      }
      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }
      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || isFinite(num) ? num || 0 : val;
      }
      return val;
    }
  });
  jQuery.each(["height", "width"], function(i, name) {
    jQuery.cssHooks[name] = {
      get: function(elem, computed, extra) {
        if (computed) {
          return rdisplayswap.test(jQuery.css(elem, "display")) && (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
            return getWidthOrHeight(elem, name, extra);
          }) : getWidthOrHeight(elem, name, extra);
        }
      },
      set: function(elem, value, extra) {
        var matches,
            styles = extra && getStyles(elem),
            subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles);
        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
          elem.style[name] = value;
          value = jQuery.css(elem, name);
        }
        return setPositiveNumber(elem, value, subtract);
      }
    };
  });
  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
    if (computed) {
      return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {marginLeft: 0}, function() {
        return elem.getBoundingClientRect().left;
      })) + "px";
    }
  });
  jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function(prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {expand: function(value) {
        var i = 0,
            expanded = {},
            parts = typeof value === "string" ? value.split(" ") : [value];
        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }
        return expanded;
      }};
    if (!rmargin.test(prefix)) {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  jQuery.fn.extend({css: function(name, value) {
      return access(this, function(elem, name, value) {
        var styles,
            len,
            map = {},
            i = 0;
        if (jQuery.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;
          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }
          return map;
        }
        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    }});
  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function(elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || jQuery.easing._default;
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function() {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function(percent) {
      var eased,
          hooks = Tween.propHooks[this.prop];
      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;
      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }
      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {_default: {
      get: function(tween) {
        var result;
        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
          return tween.elem[tween.prop];
        }
        result = jQuery.css(tween.elem, tween.prop, "");
        return !result || result === "auto" ? 0 : result;
      },
      set: function(tween) {
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }};
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {set: function(tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }};
  jQuery.easing = {
    linear: function(p) {
      return p;
    },
    swing: function(p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    },
    _default: "swing"
  };
  jQuery.fx = Tween.prototype.init;
  jQuery.fx.step = {};
  var fxNow,
      timerId,
      rfxtypes = /^(?:toggle|show|hide)$/,
      rrun = /queueHooks$/;
  function raf() {
    if (timerId) {
      window.requestAnimationFrame(raf);
      jQuery.fx.tick();
    }
  }
  function createFxNow() {
    window.setTimeout(function() {
      fxNow = undefined;
    });
    return (fxNow = jQuery.now());
  }
  function genFx(type, includeWidth) {
    var which,
        i = 0,
        attrs = {height: type};
    includeWidth = includeWidth ? 1 : 0;
    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }
    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }
    return attrs;
  }
  function createTween(value, prop, animation) {
    var tween,
        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
        index = 0,
        length = collection.length;
    for (; index < length; index++) {
      if ((tween = collection[index].call(animation, prop, value))) {
        return tween;
      }
    }
  }
  function defaultPrefilter(elem, props, opts) {
    var prop,
        value,
        toggle,
        hooks,
        oldfire,
        propTween,
        restoreDisplay,
        display,
        isBox = "width" in props || "height" in props,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType && isHiddenWithinTree(elem),
        dataShow = dataPriv.get(elem, "fxshow");
    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function() {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;
      anim.always(function() {
        anim.always(function() {
          hooks.unqueued--;
          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    }
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.test(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";
        if (value === (hidden ? "hide" : "show")) {
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true;
          } else {
            continue;
          }
        }
        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      }
    }
    propTween = !jQuery.isEmptyObject(props);
    if (!propTween && jQuery.isEmptyObject(orig)) {
      return;
    }
    if (isBox && elem.nodeType === 1) {
      opts.overflow = [style.overflow, style.overflowX, style.overflowY];
      restoreDisplay = dataShow && dataShow.display;
      if (restoreDisplay == null) {
        restoreDisplay = dataPriv.get(elem, "display");
      }
      display = jQuery.css(elem, "display");
      if (display === "none") {
        if (restoreDisplay) {
          display = restoreDisplay;
        } else {
          showHide([elem], true);
          restoreDisplay = elem.style.display || restoreDisplay;
          display = jQuery.css(elem, "display");
          showHide([elem]);
        }
      }
      if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
        if (jQuery.css(elem, "float") === "none") {
          if (!propTween) {
            anim.done(function() {
              style.display = restoreDisplay;
            });
            if (restoreDisplay == null) {
              display = style.display;
              restoreDisplay = display === "none" ? "" : display;
            }
          }
          style.display = "inline-block";
        }
      }
    }
    if (opts.overflow) {
      style.overflow = "hidden";
      anim.always(function() {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    }
    propTween = false;
    for (prop in orig) {
      if (!propTween) {
        if (dataShow) {
          if ("hidden" in dataShow) {
            hidden = dataShow.hidden;
          }
        } else {
          dataShow = dataPriv.access(elem, "fxshow", {display: restoreDisplay});
        }
        if (toggle) {
          dataShow.hidden = !hidden;
        }
        if (hidden) {
          showHide([elem], true);
        }
        anim.done(function() {
          if (!hidden) {
            showHide([elem]);
          }
          dataPriv.remove(elem, "fxshow");
          for (prop in orig) {
            jQuery.style(elem, prop, orig[prop]);
          }
        });
      }
      propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
      if (!(prop in dataShow)) {
        dataShow[prop] = propTween.start;
        if (hidden) {
          propTween.end = propTween.start;
          propTween.start = 0;
        }
      }
    }
  }
  function propFilter(props, specialEasing) {
    var index,
        name,
        easing,
        value,
        hooks;
    for (index in props) {
      name = jQuery.camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (jQuery.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }
      if (index !== name) {
        props[name] = value;
        delete props[index];
      }
      hooks = jQuery.cssHooks[name];
      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name];
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }
  function Animation(elem, properties, options) {
    var result,
        stopped,
        index = 0,
        length = Animation.prefilters.length,
        deferred = jQuery.Deferred().always(function() {
          delete tick.elem;
        }),
        tick = function() {
          if (stopped) {
            return false;
          }
          var currentTime = fxNow || createFxNow(),
              remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
              temp = remaining / animation.duration || 0,
              percent = 1 - temp,
              index = 0,
              length = animation.tweens.length;
          for (; index < length; index++) {
            animation.tweens[index].run(percent);
          }
          deferred.notifyWith(elem, [animation, percent, remaining]);
          if (percent < 1 && length) {
            return remaining;
          } else {
            deferred.resolveWith(elem, [animation]);
            return false;
          }
        },
        animation = deferred.promise({
          elem: elem,
          props: jQuery.extend({}, properties),
          opts: jQuery.extend(true, {
            specialEasing: {},
            easing: jQuery.easing._default
          }, options),
          originalProperties: properties,
          originalOptions: options,
          startTime: fxNow || createFxNow(),
          duration: options.duration,
          tweens: [],
          createTween: function(prop, end) {
            var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
            animation.tweens.push(tween);
            return tween;
          },
          stop: function(gotoEnd) {
            var index = 0,
                length = gotoEnd ? animation.tweens.length : 0;
            if (stopped) {
              return this;
            }
            stopped = true;
            for (; index < length; index++) {
              animation.tweens[index].run(1);
            }
            if (gotoEnd) {
              deferred.notifyWith(elem, [animation, 1, 0]);
              deferred.resolveWith(elem, [animation, gotoEnd]);
            } else {
              deferred.rejectWith(elem, [animation, gotoEnd]);
            }
            return this;
          }
        }),
        props = animation.props;
    propFilter(props, animation.opts.specialEasing);
    for (; index < length; index++) {
      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
      if (result) {
        if (jQuery.isFunction(result.stop)) {
          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
        }
        return result;
      }
    }
    jQuery.map(props, createTween, animation);
    if (jQuery.isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
  }
  jQuery.Animation = jQuery.extend(Animation, {
    tweeners: {"*": [function(prop, value) {
        var tween = this.createTween(prop, value);
        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
        return tween;
      }]},
    tweener: function(props, callback) {
      if (jQuery.isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.match(rnothtmlwhite);
      }
      var prop,
          index = 0,
          length = props.length;
      for (; index < length; index++) {
        prop = props[index];
        Animation.tweeners[prop] = Animation.tweeners[prop] || [];
        Animation.tweeners[prop].unshift(callback);
      }
    },
    prefilters: [defaultPrefilter],
    prefilter: function(callback, prepend) {
      if (prepend) {
        Animation.prefilters.unshift(callback);
      } else {
        Animation.prefilters.push(callback);
      }
    }
  });
  jQuery.speed = function(speed, easing, fn) {
    var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
      complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
      duration: speed,
      easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
    };
    if (jQuery.fx.off || document.hidden) {
      opt.duration = 0;
    } else {
      if (typeof opt.duration !== "number") {
        if (opt.duration in jQuery.fx.speeds) {
          opt.duration = jQuery.fx.speeds[opt.duration];
        } else {
          opt.duration = jQuery.fx.speeds._default;
        }
      }
    }
    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    }
    opt.old = opt.complete;
    opt.complete = function() {
      if (jQuery.isFunction(opt.old)) {
        opt.old.call(this);
      }
      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };
    return opt;
  };
  jQuery.fn.extend({
    fadeTo: function(speed, to, easing, callback) {
      return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({opacity: to}, speed, easing, callback);
    },
    animate: function(prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
          optall = jQuery.speed(speed, easing, callback),
          doAnimation = function() {
            var anim = Animation(this, jQuery.extend({}, prop), optall);
            if (empty || dataPriv.get(this, "finish")) {
              anim.stop(true);
            }
          };
      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function(type, clearQueue, gotoEnd) {
      var stopQueue = function(hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };
      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if (clearQueue && type !== false) {
        this.queue(type || "fx", []);
      }
      return this.each(function() {
        var dequeue = true,
            index = type != null && type + "queueHooks",
            timers = jQuery.timers,
            data = dataPriv.get(this);
        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }
        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function(type) {
      if (type !== false) {
        type = type || "fx";
      }
      return this.each(function() {
        var index,
            data = dataPriv.get(this),
            queue = data[type + "queue"],
            hooks = data[type + "queueHooks"],
            timers = jQuery.timers,
            length = queue ? queue.length : 0;
        data.finish = true;
        jQuery.queue(this, type, []);
        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        }
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }
        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        }
        delete data.finish;
      });
    }
  });
  jQuery.each(["toggle", "show", "hide"], function(i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function(speed, easing, callback) {
      return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  });
  jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: {opacity: "show"},
    fadeOut: {opacity: "hide"},
    fadeToggle: {opacity: "toggle"}
  }, function(name, props) {
    jQuery.fn[name] = function(speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.timers = [];
  jQuery.fx.tick = function() {
    var timer,
        i = 0,
        timers = jQuery.timers;
    fxNow = jQuery.now();
    for (; i < timers.length; i++) {
      timer = timers[i];
      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }
    if (!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };
  jQuery.fx.timer = function(timer) {
    jQuery.timers.push(timer);
    if (timer()) {
      jQuery.fx.start();
    } else {
      jQuery.timers.pop();
    }
  };
  jQuery.fx.interval = 13;
  jQuery.fx.start = function() {
    if (!timerId) {
      timerId = window.requestAnimationFrame ? window.requestAnimationFrame(raf) : window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
    }
  };
  jQuery.fx.stop = function() {
    if (window.cancelAnimationFrame) {
      window.cancelAnimationFrame(timerId);
    } else {
      window.clearInterval(timerId);
    }
    timerId = null;
  };
  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  };
  jQuery.fn.delay = function(time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";
    return this.queue(type, function(next, hooks) {
      var timeout = window.setTimeout(next, time);
      hooks.stop = function() {
        window.clearTimeout(timeout);
      };
    });
  };
  (function() {
    var input = document.createElement("input"),
        select = document.createElement("select"),
        opt = select.appendChild(document.createElement("option"));
    input.type = "checkbox";
    support.checkOn = input.value !== "";
    support.optSelected = opt.selected;
    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();
  var boolHook,
      attrHandle = jQuery.expr.attrHandle;
  jQuery.fn.extend({
    attr: function(name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function(name) {
      return this.each(function() {
        jQuery.removeAttr(this, name);
      });
    }
  });
  jQuery.extend({
    attr: function(elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType;
      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (typeof elem.getAttribute === "undefined") {
        return jQuery.prop(elem, name, value);
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
      }
      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
          return;
        }
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }
        elem.setAttribute(name, value + "");
        return value;
      }
      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }
      ret = jQuery.find.attr(elem, name);
      return ret == null ? undefined : ret;
    },
    attrHooks: {type: {set: function(elem, value) {
          if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
            var val = elem.value;
            elem.setAttribute("type", value);
            if (val) {
              elem.value = val;
            }
            return value;
          }
        }}},
    removeAttr: function(elem, value) {
      var name,
          i = 0,
          attrNames = value && value.match(rnothtmlwhite);
      if (attrNames && elem.nodeType === 1) {
        while ((name = attrNames[i++])) {
          elem.removeAttribute(name);
        }
      }
    }
  });
  boolHook = {set: function(elem, value, name) {
      if (value === false) {
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }
      return name;
    }};
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;
    attrHandle[name] = function(elem, name, isXML) {
      var ret,
          handle,
          lowercaseName = name.toLowerCase();
      if (!isXML) {
        handle = attrHandle[lowercaseName];
        attrHandle[lowercaseName] = ret;
        ret = getter(elem, name, isXML) != null ? lowercaseName : null;
        attrHandle[lowercaseName] = handle;
      }
      return ret;
    };
  });
  var rfocusable = /^(?:input|select|textarea|button)$/i,
      rclickable = /^(?:a|area)$/i;
  jQuery.fn.extend({
    prop: function(name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function(name) {
      return this.each(function() {
        delete this[jQuery.propFix[name] || name];
      });
    }
  });
  jQuery.extend({
    prop: function(elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType;
      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }
      if (value !== undefined) {
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }
        return (elem[name] = value);
      }
      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }
      return elem[name];
    },
    propHooks: {tabIndex: {get: function(elem) {
          var tabindex = jQuery.find.attr(elem, "tabindex");
          if (tabindex) {
            return parseInt(tabindex, 10);
          }
          if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
            return 0;
          }
          return -1;
        }}},
    propFix: {
      "for": "htmlFor",
      "class": "className"
    }
  });
  if (!support.optSelected) {
    jQuery.propHooks.selected = {
      get: function(elem) {
        var parent = elem.parentNode;
        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
        return null;
      },
      set: function(elem) {
        var parent = elem.parentNode;
        if (parent) {
          parent.selectedIndex;
          if (parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
        }
      }
    };
  }
  jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
    jQuery.propFix[this.toLowerCase()] = this;
  });
  function stripAndCollapse(value) {
    var tokens = value.match(rnothtmlwhite) || [];
    return tokens.join(" ");
  }
  function getClass(elem) {
    return elem.getAttribute && elem.getAttribute("class") || "";
  }
  jQuery.fn.extend({
    addClass: function(value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;
      if (jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).addClass(value.call(this, j, getClass(this)));
        });
      }
      if (typeof value === "string" && value) {
        classes = value.match(rnothtmlwhite) || [];
        while ((elem = this[i++])) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              if (cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            }
            finalValue = stripAndCollapse(cur);
            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }
      return this;
    },
    removeClass: function(value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;
      if (jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).removeClass(value.call(this, j, getClass(this)));
        });
      }
      if (!arguments.length) {
        return this.attr("class", "");
      }
      if (typeof value === "string" && value) {
        classes = value.match(rnothtmlwhite) || [];
        while ((elem = this[i++])) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              while (cur.indexOf(" " + clazz + " ") > -1) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            }
            finalValue = stripAndCollapse(cur);
            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }
      return this;
    },
    toggleClass: function(value, stateVal) {
      var type = typeof value;
      if (typeof stateVal === "boolean" && type === "string") {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }
      if (jQuery.isFunction(value)) {
        return this.each(function(i) {
          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
        });
      }
      return this.each(function() {
        var className,
            i,
            self,
            classNames;
        if (type === "string") {
          i = 0;
          self = jQuery(this);
          classNames = value.match(rnothtmlwhite) || [];
          while ((className = classNames[i++])) {
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }
        } else if (value === undefined || type === "boolean") {
          className = getClass(this);
          if (className) {
            dataPriv.set(this, "__className__", className);
          }
          if (this.setAttribute) {
            this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
          }
        }
      });
    },
    hasClass: function(selector) {
      var className,
          elem,
          i = 0;
      className = " " + selector + " ";
      while ((elem = this[i++])) {
        if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
          return true;
        }
      }
      return false;
    }
  });
  var rreturn = /\r/g;
  jQuery.fn.extend({val: function(value) {
      var hooks,
          ret,
          isFunction,
          elem = this[0];
      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
          if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }
          ret = elem.value;
          if (typeof ret === "string") {
            return ret.replace(rreturn, "");
          }
          return ret == null ? "" : ret;
        }
        return;
      }
      isFunction = jQuery.isFunction(value);
      return this.each(function(i) {
        var val;
        if (this.nodeType !== 1) {
          return;
        }
        if (isFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        }
        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (jQuery.isArray(val)) {
          val = jQuery.map(val, function(value) {
            return value == null ? "" : value + "";
          });
        }
        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }});
  jQuery.extend({valHooks: {
      option: {get: function(elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null ? val : stripAndCollapse(jQuery.text(elem));
        }},
      select: {
        get: function(elem) {
          var value,
              option,
              i,
              options = elem.options,
              index = elem.selectedIndex,
              one = elem.type === "select-one",
              values = one ? null : [],
              max = one ? index + 1 : options.length;
          if (index < 0) {
            i = max;
          } else {
            i = one ? index : 0;
          }
          for (; i < max; i++) {
            option = options[i];
            if ((option.selected || i === index) && !option.disabled && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
              value = jQuery(option).val();
              if (one) {
                return value;
              }
              values.push(value);
            }
          }
          return values;
        },
        set: function(elem, value) {
          var optionSet,
              option,
              options = elem.options,
              values = jQuery.makeArray(value),
              i = options.length;
          while (i--) {
            option = options[i];
            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
              optionSet = true;
            }
          }
          if (!optionSet) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    }});
  jQuery.each(["radio", "checkbox"], function() {
    jQuery.valHooks[this] = {set: function(elem, value) {
        if (jQuery.isArray(value)) {
          return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);
        }
      }};
    if (!support.checkOn) {
      jQuery.valHooks[this].get = function(elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  });
  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
  jQuery.extend(jQuery.event, {
    trigger: function(event, data, elem, onlyHandlers) {
      var i,
          cur,
          tmp,
          bubbleType,
          ontype,
          handle,
          special,
          eventPath = [elem || document],
          type = hasOwn.call(event, "type") ? event.type : event,
          namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
      cur = tmp = elem = elem || document;
      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      }
      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }
      if (type.indexOf(".") > -1) {
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(":") < 0 && "on" + type;
      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
      event.result = undefined;
      if (!event.target) {
        event.target = elem;
      }
      data = data == null ? [event] : jQuery.makeArray(data, [event]);
      special = jQuery.event.special[type] || {};
      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      }
      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
        bubbleType = special.delegateType || type;
        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }
        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }
      i = 0;
      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        event.type = i > 1 ? bubbleType : special.bindType || type;
        handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
        if (handle) {
          handle.apply(cur, data);
        }
        handle = ontype && cur[ontype];
        if (handle && handle.apply && acceptData(cur)) {
          event.result = handle.apply(cur, data);
          if (event.result === false) {
            event.preventDefault();
          }
        }
      }
      event.type = type;
      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
          if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
            tmp = elem[ontype];
            if (tmp) {
              elem[ontype] = null;
            }
            jQuery.event.triggered = type;
            elem[type]();
            jQuery.event.triggered = undefined;
            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }
      return event.result;
    },
    simulate: function(type, elem, event) {
      var e = jQuery.extend(new jQuery.Event(), event, {
        type: type,
        isSimulated: true
      });
      jQuery.event.trigger(e, null, elem);
    }
  });
  jQuery.fn.extend({
    trigger: function(type, data) {
      return this.each(function() {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function(type, data) {
      var elem = this[0];
      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  });
  jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function(i, name) {
    jQuery.fn[name] = function(data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  });
  jQuery.fn.extend({hover: function(fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    }});
  support.focusin = "onfocusin" in window;
  if (!support.focusin) {
    jQuery.each({
      focus: "focusin",
      blur: "focusout"
    }, function(orig, fix) {
      var handler = function(event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
      };
      jQuery.event.special[fix] = {
        setup: function() {
          var doc = this.ownerDocument || this,
              attaches = dataPriv.access(doc, fix);
          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }
          dataPriv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function() {
          var doc = this.ownerDocument || this,
              attaches = dataPriv.access(doc, fix) - 1;
          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            dataPriv.remove(doc, fix);
          } else {
            dataPriv.access(doc, fix, attaches);
          }
        }
      };
    });
  }
  var location = window.location;
  var nonce = jQuery.now();
  var rquery = (/\?/);
  jQuery.parseXML = function(data) {
    var xml;
    if (!data || typeof data !== "string") {
      return null;
    }
    try {
      xml = (new window.DOMParser()).parseFromString(data, "text/xml");
    } catch (e) {
      xml = undefined;
    }
    if (!xml || xml.getElementsByTagName("parsererror").length) {
      jQuery.error("Invalid XML: " + data);
    }
    return xml;
  };
  var rbracket = /\[\]$/,
      rCRLF = /\r?\n/g,
      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
      rsubmittable = /^(?:input|select|textarea|keygen)/i;
  function buildParams(prefix, obj, traditional, add) {
    var name;
    if (jQuery.isArray(obj)) {
      jQuery.each(obj, function(i, v) {
        if (traditional || rbracket.test(prefix)) {
          add(prefix, v);
        } else {
          buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
        }
      });
    } else if (!traditional && jQuery.type(obj) === "object") {
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      add(prefix, obj);
    }
  }
  jQuery.param = function(a, traditional) {
    var prefix,
        s = [],
        add = function(key, valueOrFunction) {
          var value = jQuery.isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
          s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
        };
    if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
      jQuery.each(a, function() {
        add(this.name, this.value);
      });
    } else {
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }
    return s.join("&");
  };
  jQuery.fn.extend({
    serialize: function() {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function() {
      return this.map(function() {
        var elements = jQuery.prop(this, "elements");
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function() {
        var type = this.type;
        return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
      }).map(function(i, elem) {
        var val = jQuery(this).val();
        if (val == null) {
          return null;
        }
        if (jQuery.isArray(val)) {
          return jQuery.map(val, function(val) {
            return {
              name: elem.name,
              value: val.replace(rCRLF, "\r\n")
            };
          });
        }
        return {
          name: elem.name,
          value: val.replace(rCRLF, "\r\n")
        };
      }).get();
    }
  });
  var r20 = /%20/g,
      rhash = /#.*$/,
      rantiCache = /([?&])_=[^&]*/,
      rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
      rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
      rnoContent = /^(?:GET|HEAD)$/,
      rprotocol = /^\/\//,
      prefilters = {},
      transports = {},
      allTypes = "*/".concat("*"),
      originAnchor = document.createElement("a");
  originAnchor.href = location.href;
  function addToPrefiltersOrTransports(structure) {
    return function(dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }
      var dataType,
          i = 0,
          dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
      if (jQuery.isFunction(func)) {
        while ((dataType = dataTypes[i++])) {
          if (dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func);
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }
  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {},
        seekingTransport = (structure === transports);
    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }
    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
  }
  function ajaxExtend(target, src) {
    var key,
        deep,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};
    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
      }
    }
    if (deep) {
      jQuery.extend(true, target, deep);
    }
    return target;
  }
  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct,
        type,
        finalDataType,
        firstDataType,
        contents = s.contents,
        dataTypes = s.dataTypes;
    while (dataTypes[0] === "*") {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    }
    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }
      finalDataType = finalDataType || firstDataType;
    }
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }
  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2,
        current,
        conv,
        tmp,
        prev,
        converters = {},
        dataTypes = s.dataTypes.slice();
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }
    current = dataTypes.shift();
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }
      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }
      prev = current;
      current = dataTypes.shift();
      if (current) {
        if (current === "*") {
          current = prev;
        } else if (prev !== "*" && prev !== current) {
          conv = converters[prev + " " + current] || converters["* " + current];
          if (!conv) {
            for (conv2 in converters) {
              tmp = conv2.split(" ");
              if (tmp[1] === current) {
                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                if (conv) {
                  if (conv === true) {
                    conv = converters[conv2];
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }
          if (conv !== true) {
            if (conv && s.throws) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }
    return {
      state: "success",
      data: response
    };
  }
  jQuery.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: location.href,
      type: "GET",
      isLocal: rlocalProtocol.test(location.protocol),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": true,
        "text json": JSON.parse,
        "text xml": jQuery.parseXML
      },
      flatOptions: {
        url: true,
        context: true
      }
    },
    ajaxSetup: function(target, settings) {
      return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    ajax: function(url, options) {
      if (typeof url === "object") {
        options = url;
        url = undefined;
      }
      options = options || {};
      var transport,
          cacheURL,
          responseHeadersString,
          responseHeaders,
          timeoutTimer,
          urlAnchor,
          completed,
          fireGlobals,
          i,
          uncached,
          s = jQuery.ajaxSetup({}, options),
          callbackContext = s.context || s,
          globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
          deferred = jQuery.Deferred(),
          completeDeferred = jQuery.Callbacks("once memory"),
          statusCode = s.statusCode || {},
          requestHeaders = {},
          requestHeadersNames = {},
          strAbort = "canceled",
          jqXHR = {
            readyState: 0,
            getResponseHeader: function(key) {
              var match;
              if (completed) {
                if (!responseHeaders) {
                  responseHeaders = {};
                  while ((match = rheaders.exec(responseHeadersString))) {
                    responseHeaders[match[1].toLowerCase()] = match[2];
                  }
                }
                match = responseHeaders[key.toLowerCase()];
              }
              return match == null ? null : match;
            },
            getAllResponseHeaders: function() {
              return completed ? responseHeadersString : null;
            },
            setRequestHeader: function(name, value) {
              if (completed == null) {
                name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                requestHeaders[name] = value;
              }
              return this;
            },
            overrideMimeType: function(type) {
              if (completed == null) {
                s.mimeType = type;
              }
              return this;
            },
            statusCode: function(map) {
              var code;
              if (map) {
                if (completed) {
                  jqXHR.always(map[jqXHR.status]);
                } else {
                  for (code in map) {
                    statusCode[code] = [statusCode[code], map[code]];
                  }
                }
              }
              return this;
            },
            abort: function(statusText) {
              var finalText = statusText || strAbort;
              if (transport) {
                transport.abort(finalText);
              }
              done(0, finalText);
              return this;
            }
          };
      deferred.promise(jqXHR);
      s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//");
      s.type = options.method || options.type || s.method || s.type;
      s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
      if (s.crossDomain == null) {
        urlAnchor = document.createElement("a");
        try {
          urlAnchor.href = s.url;
          urlAnchor.href = urlAnchor.href;
          s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
        } catch (e) {
          s.crossDomain = true;
        }
      }
      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      }
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
      if (completed) {
        return jqXHR;
      }
      fireGlobals = jQuery.event && s.global;
      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      }
      s.type = s.type.toUpperCase();
      s.hasContent = !rnoContent.test(s.type);
      cacheURL = s.url.replace(rhash, "");
      if (!s.hasContent) {
        uncached = s.url.slice(cacheURL.length);
        if (s.data) {
          cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
          delete s.data;
        }
        if (s.cache === false) {
          cacheURL = cacheURL.replace(rantiCache, "$1");
          uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + (nonce++) + uncached;
        }
        s.url = cacheURL + uncached;
      } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
        s.data = s.data.replace(r20, "+");
      }
      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
        }
        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      }
      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      }
      jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }
      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
        return jqXHR.abort();
      }
      strAbort = "abort";
      completeDeferred.add(s.complete);
      jqXHR.done(s.success);
      jqXHR.fail(s.error);
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1;
        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        }
        if (completed) {
          return jqXHR;
        }
        if (s.async && s.timeout > 0) {
          timeoutTimer = window.setTimeout(function() {
            jqXHR.abort("timeout");
          }, s.timeout);
        }
        try {
          completed = false;
          transport.send(requestHeaders, done);
        } catch (e) {
          if (completed) {
            throw e;
          }
          done(-1, e);
        }
      }
      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
            success,
            error,
            response,
            modified,
            statusText = nativeStatusText;
        if (completed) {
          return;
        }
        completed = true;
        if (timeoutTimer) {
          window.clearTimeout(timeoutTimer);
        }
        transport = undefined;
        responseHeadersString = headers || "";
        jqXHR.readyState = status > 0 ? 4 : 0;
        isSuccess = status >= 200 && status < 300 || status === 304;
        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }
        response = ajaxConvert(s, response, jqXHR, isSuccess);
        if (isSuccess) {
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");
            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader("etag");
            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          }
          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent";
          } else if (status === 304) {
            statusText = "notmodified";
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          error = statusText;
          if (status || !statusText) {
            statusText = "error";
            if (status < 0) {
              status = 0;
            }
          }
        }
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + "";
        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        }
        jqXHR.statusCode(statusCode);
        statusCode = undefined;
        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
        }
        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
          if (!(--jQuery.active)) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }
      return jqXHR;
    },
    getJSON: function(url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },
    getScript: function(url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    }
  });
  jQuery.each(["get", "post"], function(i, method) {
    jQuery[method] = function(url, data, callback, type) {
      if (jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }
      return jQuery.ajax(jQuery.extend({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      }, jQuery.isPlainObject(url) && url));
    };
  });
  jQuery._evalUrl = function(url) {
    return jQuery.ajax({
      url: url,
      type: "GET",
      dataType: "script",
      cache: true,
      async: false,
      global: false,
      "throws": true
    });
  };
  jQuery.fn.extend({
    wrapAll: function(html) {
      var wrap;
      if (this[0]) {
        if (jQuery.isFunction(html)) {
          html = html.call(this[0]);
        }
        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }
        wrap.map(function() {
          var elem = this;
          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }
          return elem;
        }).append(this);
      }
      return this;
    },
    wrapInner: function(html) {
      if (jQuery.isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }
      return this.each(function() {
        var self = jQuery(this),
            contents = self.contents();
        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function(html) {
      var isFunction = jQuery.isFunction(html);
      return this.each(function(i) {
        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function(selector) {
      this.parent(selector).not("body").each(function() {
        jQuery(this).replaceWith(this.childNodes);
      });
      return this;
    }
  });
  jQuery.expr.pseudos.hidden = function(elem) {
    return !jQuery.expr.pseudos.visible(elem);
  };
  jQuery.expr.pseudos.visible = function(elem) {
    return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
  };
  jQuery.ajaxSettings.xhr = function() {
    try {
      return new window.XMLHttpRequest();
    } catch (e) {}
  };
  var xhrSuccessStatus = {
    0: 200,
    1223: 204
  },
      xhrSupported = jQuery.ajaxSettings.xhr();
  support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
  support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function(options) {
    var callback,
        errorCallback;
    if (support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function(headers, complete) {
          var i,
              xhr = options.xhr();
          xhr.open(options.type, options.url, options.async, options.username, options.password);
          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          }
          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          }
          if (!options.crossDomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          }
          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          }
          callback = function(type) {
            return function() {
              if (callback) {
                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
                if (type === "abort") {
                  xhr.abort();
                } else if (type === "error") {
                  if (typeof xhr.status !== "number") {
                    complete(0, "error");
                  } else {
                    complete(xhr.status, xhr.statusText);
                  }
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {binary: xhr.response} : {text: xhr.responseText}, xhr.getAllResponseHeaders());
                }
              }
            };
          };
          xhr.onload = callback();
          errorCallback = xhr.onerror = callback("error");
          if (xhr.onabort !== undefined) {
            xhr.onabort = errorCallback;
          } else {
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                window.setTimeout(function() {
                  if (callback) {
                    errorCallback();
                  }
                });
              }
            };
          }
          callback = callback("abort");
          try {
            xhr.send(options.hasContent && options.data || null);
          } catch (e) {
            if (callback) {
              throw e;
            }
          }
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  jQuery.ajaxPrefilter(function(s) {
    if (s.crossDomain) {
      s.contents.script = false;
    }
  });
  jQuery.ajaxSetup({
    accepts: {script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"},
    contents: {script: /\b(?:java|ecma)script\b/},
    converters: {"text script": function(text) {
        jQuery.globalEval(text);
        return text;
      }}
  });
  jQuery.ajaxPrefilter("script", function(s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = "GET";
    }
  });
  jQuery.ajaxTransport("script", function(s) {
    if (s.crossDomain) {
      var script,
          callback;
      return {
        send: function(_, complete) {
          script = jQuery("<script>").prop({
            charset: s.scriptCharset,
            src: s.url
          }).on("load error", callback = function(evt) {
            script.remove();
            callback = null;
            if (evt) {
              complete(evt.type === "error" ? 404 : 200, evt.type);
            }
          });
          document.head.appendChild(script[0]);
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var oldCallbacks = [],
      rjsonp = /(=)\?(?=&|$)|\?\?/;
  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
      var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
      this[callback] = true;
      return callback;
    }
  });
  jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
    var callbackName,
        overwritten,
        responseContainer,
        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
    if (jsonProp || s.dataTypes[0] === "jsonp") {
      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      }
      s.converters["script json"] = function() {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }
        return responseContainer[0];
      };
      s.dataTypes[0] = "json";
      overwritten = window[callbackName];
      window[callbackName] = function() {
        responseContainer = arguments;
      };
      jqXHR.always(function() {
        if (overwritten === undefined) {
          jQuery(window).removeProp(callbackName);
        } else {
          window[callbackName] = overwritten;
        }
        if (s[callbackName]) {
          s.jsonpCallback = originalSettings.jsonpCallback;
          oldCallbacks.push(callbackName);
        }
        if (responseContainer && jQuery.isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }
        responseContainer = overwritten = undefined;
      });
      return "script";
    }
  });
  support.createHTMLDocument = (function() {
    var body = document.implementation.createHTMLDocument("").body;
    body.innerHTML = "<form></form><form></form>";
    return body.childNodes.length === 2;
  })();
  jQuery.parseHTML = function(data, context, keepScripts) {
    if (typeof data !== "string") {
      return [];
    }
    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }
    var base,
        parsed,
        scripts;
    if (!context) {
      if (support.createHTMLDocument) {
        context = document.implementation.createHTMLDocument("");
        base = context.createElement("base");
        base.href = document.location.href;
        context.head.appendChild(base);
      } else {
        context = document;
      }
    }
    parsed = rsingleTag.exec(data);
    scripts = !keepScripts && [];
    if (parsed) {
      return [context.createElement(parsed[1])];
    }
    parsed = buildFragment([data], context, scripts);
    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }
    return jQuery.merge([], parsed.childNodes);
  };
  jQuery.fn.load = function(url, params, callback) {
    var selector,
        type,
        response,
        self = this,
        off = url.indexOf(" ");
    if (off > -1) {
      selector = stripAndCollapse(url.slice(off));
      url = url.slice(0, off);
    }
    if (jQuery.isFunction(params)) {
      callback = params;
      params = undefined;
    } else if (params && typeof params === "object") {
      type = "POST";
    }
    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        type: type || "GET",
        dataType: "html",
        data: params
      }).done(function(responseText) {
        response = arguments;
        self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
      }).always(callback && function(jqXHR, status) {
        self.each(function() {
          callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
        });
      });
    }
    return this;
  };
  jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
    jQuery.fn[type] = function(fn) {
      return this.on(type, fn);
    };
  });
  jQuery.expr.pseudos.animated = function(elem) {
    return jQuery.grep(jQuery.timers, function(fn) {
      return elem === fn.elem;
    }).length;
  };
  function getWindow(elem) {
    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
  }
  jQuery.offset = {setOffset: function(elem, options, i) {
      var curPosition,
          curLeft,
          curCSSTop,
          curTop,
          curOffset,
          curCSSLeft,
          calculatePosition,
          position = jQuery.css(elem, "position"),
          curElem = jQuery(elem),
          props = {};
      if (position === "static") {
        elem.style.position = "relative";
      }
      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }
      if (jQuery.isFunction(options)) {
        options = options.call(elem, i, jQuery.extend({}, curOffset));
      }
      if (options.top != null) {
        props.top = (options.top - curOffset.top) + curTop;
      }
      if (options.left != null) {
        props.left = (options.left - curOffset.left) + curLeft;
      }
      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }};
  jQuery.fn.extend({
    offset: function(options) {
      if (arguments.length) {
        return options === undefined ? this : this.each(function(i) {
          jQuery.offset.setOffset(this, options, i);
        });
      }
      var docElem,
          win,
          rect,
          doc,
          elem = this[0];
      if (!elem) {
        return;
      }
      if (!elem.getClientRects().length) {
        return {
          top: 0,
          left: 0
        };
      }
      rect = elem.getBoundingClientRect();
      if (rect.width || rect.height) {
        doc = elem.ownerDocument;
        win = getWindow(doc);
        docElem = doc.documentElement;
        return {
          top: rect.top + win.pageYOffset - docElem.clientTop,
          left: rect.left + win.pageXOffset - docElem.clientLeft
        };
      }
      return rect;
    },
    position: function() {
      if (!this[0]) {
        return;
      }
      var offsetParent,
          offset,
          elem = this[0],
          parentOffset = {
            top: 0,
            left: 0
          };
      if (jQuery.css(elem, "position") === "fixed") {
        offset = elem.getBoundingClientRect();
      } else {
        offsetParent = this.offsetParent();
        offset = this.offset();
        if (!jQuery.nodeName(offsetParent[0], "html")) {
          parentOffset = offsetParent.offset();
        }
        parentOffset = {
          top: parentOffset.top + jQuery.css(offsetParent[0], "borderTopWidth", true),
          left: parentOffset.left + jQuery.css(offsetParent[0], "borderLeftWidth", true)
        };
      }
      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
      };
    },
    offsetParent: function() {
      return this.map(function() {
        var offsetParent = this.offsetParent;
        while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || documentElement;
      });
    }
  });
  jQuery.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function(method, prop) {
    var top = "pageYOffset" === prop;
    jQuery.fn[method] = function(val) {
      return access(this, function(elem, method, val) {
        var win = getWindow(elem);
        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }
        if (win) {
          win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length);
    };
  });
  jQuery.each(["top", "left"], function(i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop);
        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
      }
    });
  });
  jQuery.each({
    Height: "height",
    Width: "width"
  }, function(name, type) {
    jQuery.each({
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function(defaultExtra, funcName) {
      jQuery.fn[funcName] = function(margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
            extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return access(this, function(elem, type, value) {
          var doc;
          if (jQuery.isWindow(elem)) {
            return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
          }
          if (elem.nodeType === 9) {
            doc = elem.documentElement;
            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
          }
          return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable);
      };
    });
  });
  jQuery.fn.extend({
    bind: function(types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function(types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function(selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function(selector, types, fn) {
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    }
  });
  jQuery.parseJSON = JSON.parse;
  if (typeof define === "function" && define.amd) {
    define("npm:jquery@3.1.1/dist/jquery.js", [], function() {
      return jQuery;
    }) && define("jquery", ["npm:jquery@3.1.1/dist/jquery.js"], function(m) {
      return m;
    });
  }
  var _jQuery = window.jQuery,
      _$ = window.$;
  jQuery.noConflict = function(deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }
    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }
    return jQuery;
  };
  if (!noGlobal) {
    window.jQuery = window.$ = jQuery;
  }
  return jQuery;
});

})();
System.registerDynamic("github:jeresig/jquery.hotkeys@0.2.0.json", [], false, function() {
  return {
    "main": "jquery.hotkeys.js"
  };
});

System.registerDynamic("github:jeresig/jquery.hotkeys@0.2.0/jquery.hotkeys.js", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    /*jslint browser: true*/
    /*jslint jquery: true*/

    /*
     * jQuery Hotkeys Plugin
     * Copyright 2010, John Resig
     * Dual licensed under the MIT or GPL Version 2 licenses.
     *
     * Based upon the plugin by Tzury Bar Yochay:
     * http://github.com/tzuryby/hotkeys
     *
     * Original idea by:
     * Binny V A, http://www.openjs.com/scripts/events/keyboard_shortcuts/
     */

    /*
     * One small change is: now keys are passed by object { keys: '...' }
     * Might be useful, when you want to pass some other data to your handler
     */

    (function (jQuery) {

      jQuery.hotkeys = {
        version: "0.8",

        specialKeys: {
          8: "backspace",
          9: "tab",
          10: "return",
          13: "return",
          16: "shift",
          17: "ctrl",
          18: "alt",
          19: "pause",
          20: "capslock",
          27: "esc",
          32: "space",
          33: "pageup",
          34: "pagedown",
          35: "end",
          36: "home",
          37: "left",
          38: "up",
          39: "right",
          40: "down",
          45: "insert",
          46: "del",
          59: ";",
          61: "=",
          96: "0",
          97: "1",
          98: "2",
          99: "3",
          100: "4",
          101: "5",
          102: "6",
          103: "7",
          104: "8",
          105: "9",
          106: "*",
          107: "+",
          109: "-",
          110: ".",
          111: "/",
          112: "f1",
          113: "f2",
          114: "f3",
          115: "f4",
          116: "f5",
          117: "f6",
          118: "f7",
          119: "f8",
          120: "f9",
          121: "f10",
          122: "f11",
          123: "f12",
          144: "numlock",
          145: "scroll",
          173: "-",
          186: ";",
          187: "=",
          188: ",",
          189: "-",
          190: ".",
          191: "/",
          192: "`",
          219: "[",
          220: "\\",
          221: "]",
          222: "'"
        },

        shiftNums: {
          "`": "~",
          "1": "!",
          "2": "@",
          "3": "#",
          "4": "$",
          "5": "%",
          "6": "^",
          "7": "&",
          "8": "*",
          "9": "(",
          "0": ")",
          "-": "_",
          "=": "+",
          ";": ": ",
          "'": "\"",
          ",": "<",
          ".": ">",
          "/": "?",
          "\\": "|"
        },

        // excludes: button, checkbox, file, hidden, image, password, radio, reset, search, submit, url
        textAcceptingInputTypes: ["text", "password", "number", "email", "url", "range", "date", "month", "week", "time", "datetime", "datetime-local", "search", "color", "tel"],

        options: {
          filterTextInputs: true
        }
      };

      function keyHandler(handleObj) {
        if (typeof handleObj.data === "string") {
          handleObj.data = {
            keys: handleObj.data
          };
        }

        // Only care when a possible input has been specified
        if (!handleObj.data || !handleObj.data.keys || typeof handleObj.data.keys !== "string") {
          return;
        }

        var origHandler = handleObj.handler,
            keys = handleObj.data.keys.toLowerCase().split(" ");

        handleObj.handler = function (event) {
          //      Don't fire in text-accepting inputs that we didn't directly bind to
          if (this !== event.target && (/textarea|select/i.test(event.target.nodeName) || jQuery.hotkeys.options.filterTextInputs && jQuery.inArray(event.target.type, jQuery.hotkeys.textAcceptingInputTypes) > -1)) {
            return;
          }

          var special = event.type !== "keypress" && jQuery.hotkeys.specialKeys[event.which],
              character = String.fromCharCode(event.which).toLowerCase(),
              modif = "",
              possible = {};

          jQuery.each(["alt", "ctrl", "shift"], function (index, specialKey) {

            if (event[specialKey + 'Key'] && special !== specialKey) {
              modif += specialKey + '+';
            }
          });

          // metaKey is triggered off ctrlKey erronously
          if (event.metaKey && !event.ctrlKey && special !== "meta") {
            modif += "meta+";
          }

          if (event.metaKey && special !== "meta" && modif.indexOf("alt+ctrl+shift+") > -1) {
            modif = modif.replace("alt+ctrl+shift+", "hyper+");
          }

          if (special) {
            possible[modif + special] = true;
          } else {
            possible[modif + character] = true;
            possible[modif + jQuery.hotkeys.shiftNums[character]] = true;

            // "$" can be triggered as "Shift+4" or "Shift+$" or just "$"
            if (modif === "shift+") {
              possible[jQuery.hotkeys.shiftNums[character]] = true;
            }
          }

          for (var i = 0, l = keys.length; i < l; i++) {
            if (possible[keys[i]]) {
              return origHandler.apply(this, arguments);
            }
          }
        };
      }

      jQuery.each(["keydown", "keyup", "keypress"], function () {
        jQuery.event.special[this] = {
          add: keyHandler
        };
      });
    })(jQuery || this.jQuery || window.jQuery);
  })(this);

  return _retrieveGlobal();
});
System.registerDynamic("github:ajaxorg/ace-builds@1.2.6/theme-monokai.js", ["ace/ace"], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    ace.define("ace/theme/monokai", ["require", "exports", "module", "ace/lib/dom"], function (require, exports, module) {

      exports.isDark = true;
      exports.cssClass = "ace-monokai";
      exports.cssText = ".ace-monokai .ace_gutter {\
background: #2F3129;\
color: #8F908A\
}\
.ace-monokai .ace_print-margin {\
width: 1px;\
background: #555651\
}\
.ace-monokai {\
background-color: #272822;\
color: #F8F8F2\
}\
.ace-monokai .ace_cursor {\
color: #F8F8F0\
}\
.ace-monokai .ace_marker-layer .ace_selection {\
background: #49483E\
}\
.ace-monokai.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px #272822;\
}\
.ace-monokai .ace_marker-layer .ace_step {\
background: rgb(102, 82, 0)\
}\
.ace-monokai .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid #49483E\
}\
.ace-monokai .ace_marker-layer .ace_active-line {\
background: #202020\
}\
.ace-monokai .ace_gutter-active-line {\
background-color: #272727\
}\
.ace-monokai .ace_marker-layer .ace_selected-word {\
border: 1px solid #49483E\
}\
.ace-monokai .ace_invisible {\
color: #52524d\
}\
.ace-monokai .ace_entity.ace_name.ace_tag,\
.ace-monokai .ace_keyword,\
.ace-monokai .ace_meta.ace_tag,\
.ace-monokai .ace_storage {\
color: #F92672\
}\
.ace-monokai .ace_punctuation,\
.ace-monokai .ace_punctuation.ace_tag {\
color: #fff\
}\
.ace-monokai .ace_constant.ace_character,\
.ace-monokai .ace_constant.ace_language,\
.ace-monokai .ace_constant.ace_numeric,\
.ace-monokai .ace_constant.ace_other {\
color: #AE81FF\
}\
.ace-monokai .ace_invalid {\
color: #F8F8F0;\
background-color: #F92672\
}\
.ace-monokai .ace_invalid.ace_deprecated {\
color: #F8F8F0;\
background-color: #AE81FF\
}\
.ace-monokai .ace_support.ace_constant,\
.ace-monokai .ace_support.ace_function {\
color: #66D9EF\
}\
.ace-monokai .ace_fold {\
background-color: #A6E22E;\
border-color: #F8F8F2\
}\
.ace-monokai .ace_storage.ace_type,\
.ace-monokai .ace_support.ace_class,\
.ace-monokai .ace_support.ace_type {\
font-style: italic;\
color: #66D9EF\
}\
.ace-monokai .ace_entity.ace_name.ace_function,\
.ace-monokai .ace_entity.ace_other,\
.ace-monokai .ace_entity.ace_other.ace_attribute-name,\
.ace-monokai .ace_variable {\
color: #A6E22E\
}\
.ace-monokai .ace_variable.ace_parameter {\
font-style: italic;\
color: #FD971F\
}\
.ace-monokai .ace_string {\
color: #E6DB74\
}\
.ace-monokai .ace_comment {\
color: #75715E\
}\
.ace-monokai .ace_indent-guide {\
background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWPQ0FD0ZXBzd/wPAAjVAoxeSgNeAAAAAElFTkSuQmCC) right repeat-y\
}";

      var dom = require("../lib/dom");
      dom.importCssString(exports.cssText, exports.cssClass);
    });
  })(this);

  return _retrieveGlobal();
});
System.registerDynamic("github:ajaxorg/ace-builds@1.2.6/mode-javascript.js", ["ace/ace"], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

    (function ($__global) {
        ace.define("ace/mode/doc_comment_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

            var DocCommentHighlightRules = function () {
                this.$rules = {
                    "start": [{
                        token: "comment.doc.tag",
                        regex: "@[\\w\\d_]+" // TODO: fix email addresses
                    }, DocCommentHighlightRules.getTagRule(), {
                        defaultToken: "comment.doc",
                        caseInsensitive: true
                    }]
                };
            };

            oop.inherits(DocCommentHighlightRules, TextHighlightRules);

            DocCommentHighlightRules.getTagRule = function (start) {
                return {
                    token: "comment.doc.tag.storage.type",
                    regex: "\\b(?:TODO|FIXME|XXX|HACK)\\b"
                };
            };

            DocCommentHighlightRules.getStartRule = function (start) {
                return {
                    token: "comment.doc", // doc comment
                    regex: "\\/\\*(?=\\*)",
                    next: start
                };
            };

            DocCommentHighlightRules.getEndRule = function (start) {
                return {
                    token: "comment.doc", // closing comment
                    regex: "\\*\\/",
                    next: start
                };
            };

            exports.DocCommentHighlightRules = DocCommentHighlightRules;
        });

        ace.define("ace/mode/javascript_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/doc_comment_highlight_rules", "ace/mode/text_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var DocCommentHighlightRules = require("./doc_comment_highlight_rules").DocCommentHighlightRules;
            var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
            var identifierRe = "[a-zA-Z\\$_\u00a1-\uffff][a-zA-Z\\d\\$_\u00a1-\uffff]*";

            var JavaScriptHighlightRules = function (options) {
                var keywordMapper = this.createKeywordMapper({
                    "variable.language": "Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|" + // Constructors
                    "Namespace|QName|XML|XMLList|" + // E4X
                    "ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|" + "Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|" + "Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|" + // Errors
                    "SyntaxError|TypeError|URIError|" + "decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|" + // Non-constructor functions
                    "isNaN|parseFloat|parseInt|" + "JSON|Math|" + // Other
                    "this|arguments|prototype|window|document", // Pseudo
                    "keyword": "const|yield|import|get|set|async|await|" + "break|case|catch|continue|default|delete|do|else|finally|for|function|" + "if|in|of|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|" + "__parent__|__count__|escape|unescape|with|__proto__|" + "class|enum|extends|super|export|implements|private|public|interface|package|protected|static",
                    "storage.type": "const|let|var|function",
                    "constant.language": "null|Infinity|NaN|undefined",
                    "support.function": "alert",
                    "constant.language.boolean": "true|false"
                }, "identifier");
                var kwBeforeRe = "case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void";

                var escapedRe = "\\\\(?:x[0-9a-fA-F]{2}|" + // hex
                "u[0-9a-fA-F]{4}|" + // unicode
                "u{[0-9a-fA-F]{1,6}}|" + // es6 unicode
                "[0-2][0-7]{0,2}|" + // oct
                "3[0-7][0-7]?|" + // oct
                "[4-7][0-7]?|" + //oct
                ".)";

                this.$rules = {
                    "no_regex": [DocCommentHighlightRules.getStartRule("doc-start"), comments("no_regex"), {
                        token: "string",
                        regex: "'(?=.)",
                        next: "qstring"
                    }, {
                        token: "string",
                        regex: '"(?=.)',
                        next: "qqstring"
                    }, {
                        token: "constant.numeric", // hex
                        regex: /0(?:[xX][0-9a-fA-F]+|[bB][01]+)\b/
                    }, {
                        token: "constant.numeric", // float
                        regex: /[+-]?\d[\d_]*(?:(?:\.\d*)?(?:[eE][+-]?\d+)?)?\b/
                    }, {
                        token: ["storage.type", "punctuation.operator", "support.function", "punctuation.operator", "entity.name.function", "text", "keyword.operator"],
                        regex: "(" + identifierRe + ")(\\.)(prototype)(\\.)(" + identifierRe + ")(\\s*)(=)",
                        next: "function_arguments"
                    }, {
                        token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "entity.name.function", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s+)(\\w+)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["storage.type", "text", "entity.name.function", "text", "paren.lparen"],
                        regex: "(function)(\\s+)(" + identifierRe + ")(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["entity.name.function", "text", "punctuation.operator", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\s*)(:)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["text", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(:)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: "keyword",
                        regex: "(?:" + kwBeforeRe + ")\\b",
                        next: "start"
                    }, {
                        token: ["support.constant"],
                        regex: /that\b/
                    }, {
                        token: ["storage.type", "punctuation.operator", "support.function.firebug"],
                        regex: /(console)(\.)(warn|info|log|error|time|trace|timeEnd|assert)\b/
                    }, {
                        token: keywordMapper,
                        regex: identifierRe
                    }, {
                        token: "punctuation.operator",
                        regex: /[.](?![.])/,
                        next: "property"
                    }, {
                        token: "keyword.operator",
                        regex: /--|\+\+|\.{3}|===|==|=|!=|!==|<+=?|>+=?|!|&&|\|\||\?:|[!$%&*+\-~\/^]=?/,
                        next: "start"
                    }, {
                        token: "punctuation.operator",
                        regex: /[?:,;.]/,
                        next: "start"
                    }, {
                        token: "paren.lparen",
                        regex: /[\[({]/,
                        next: "start"
                    }, {
                        token: "paren.rparen",
                        regex: /[\])}]/
                    }, {
                        token: "comment",
                        regex: /^#!.*$/
                    }],
                    property: [{
                        token: "text",
                        regex: "\\s+"
                    }, {
                        token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "entity.name.function", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(?:(\\s+)(\\w+))?(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: "punctuation.operator",
                        regex: /[.](?![.])/
                    }, {
                        token: "support.function",
                        regex: /(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\b(?=\()/
                    }, {
                        token: "support.function.dom",
                        regex: /(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName|ClassName)|ById)|Attribute(?:Node)?)|blur)\b(?=\()/
                    }, {
                        token: "support.constant",
                        regex: /(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\b/
                    }, {
                        token: "identifier",
                        regex: identifierRe
                    }, {
                        regex: "",
                        token: "empty",
                        next: "no_regex"
                    }],
                    "start": [DocCommentHighlightRules.getStartRule("doc-start"), comments("start"), {
                        token: "string.regexp",
                        regex: "\\/",
                        next: "regex"
                    }, {
                        token: "text",
                        regex: "\\s+|^$",
                        next: "start"
                    }, {
                        token: "empty",
                        regex: "",
                        next: "no_regex"
                    }],
                    "regex": [{
                        token: "regexp.keyword.operator",
                        regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
                    }, {
                        token: "string.regexp",
                        regex: "/[sxngimy]*",
                        next: "no_regex"
                    }, {
                        token: "invalid",
                        regex: /\{\d+\b,?\d*\}[+*]|[+*$^?][+*]|[$^][?]|\?{3,}/
                    }, {
                        token: "constant.language.escape",
                        regex: /\(\?[:=!]|\)|\{\d+\b,?\d*\}|[+*]\?|[()$^+*?.]/
                    }, {
                        token: "constant.language.delimiter",
                        regex: /\|/
                    }, {
                        token: "constant.language.escape",
                        regex: /\[\^?/,
                        next: "regex_character_class"
                    }, {
                        token: "empty",
                        regex: "$",
                        next: "no_regex"
                    }, {
                        defaultToken: "string.regexp"
                    }],
                    "regex_character_class": [{
                        token: "regexp.charclass.keyword.operator",
                        regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
                    }, {
                        token: "constant.language.escape",
                        regex: "]",
                        next: "regex"
                    }, {
                        token: "constant.language.escape",
                        regex: "-"
                    }, {
                        token: "empty",
                        regex: "$",
                        next: "no_regex"
                    }, {
                        defaultToken: "string.regexp.charachterclass"
                    }],
                    "function_arguments": [{
                        token: "variable.parameter",
                        regex: identifierRe
                    }, {
                        token: "punctuation.operator",
                        regex: "[, ]+"
                    }, {
                        token: "punctuation.operator",
                        regex: "$"
                    }, {
                        token: "empty",
                        regex: "",
                        next: "no_regex"
                    }],
                    "qqstring": [{
                        token: "constant.language.escape",
                        regex: escapedRe
                    }, {
                        token: "string",
                        regex: "\\\\$",
                        next: "qqstring"
                    }, {
                        token: "string",
                        regex: '"|$',
                        next: "no_regex"
                    }, {
                        defaultToken: "string"
                    }],
                    "qstring": [{
                        token: "constant.language.escape",
                        regex: escapedRe
                    }, {
                        token: "string",
                        regex: "\\\\$",
                        next: "qstring"
                    }, {
                        token: "string",
                        regex: "'|$",
                        next: "no_regex"
                    }, {
                        defaultToken: "string"
                    }]
                };

                if (!options || !options.noES6) {
                    this.$rules.no_regex.unshift({
                        regex: "[{}]", onMatch: function (val, state, stack) {
                            this.next = val == "{" ? this.nextState : "";
                            if (val == "{" && stack.length) {
                                stack.unshift("start", state);
                            } else if (val == "}" && stack.length) {
                                stack.shift();
                                this.next = stack.shift();
                                if (this.next.indexOf("string") != -1 || this.next.indexOf("jsx") != -1) return "paren.quasi.end";
                            }
                            return val == "{" ? "paren.lparen" : "paren.rparen";
                        },
                        nextState: "start"
                    }, {
                        token: "string.quasi.start",
                        regex: /`/,
                        push: [{
                            token: "constant.language.escape",
                            regex: escapedRe
                        }, {
                            token: "paren.quasi.start",
                            regex: /\${/,
                            push: "start"
                        }, {
                            token: "string.quasi.end",
                            regex: /`/,
                            next: "pop"
                        }, {
                            defaultToken: "string.quasi"
                        }]
                    });

                    if (!options || options.jsx != false) JSX.call(this);
                }

                this.embedRules(DocCommentHighlightRules, "doc-", [DocCommentHighlightRules.getEndRule("no_regex")]);

                this.normalizeRules();
            };

            oop.inherits(JavaScriptHighlightRules, TextHighlightRules);

            function JSX() {
                var tagRegex = identifierRe.replace("\\d", "\\d\\-");
                var jsxTag = {
                    onMatch: function (val, state, stack) {
                        var offset = val.charAt(1) == "/" ? 2 : 1;
                        if (offset == 1) {
                            if (state != this.nextState) stack.unshift(this.next, this.nextState, 0);else stack.unshift(this.next);
                            stack[2]++;
                        } else if (offset == 2) {
                            if (state == this.nextState) {
                                stack[1]--;
                                if (!stack[1] || stack[1] < 0) {
                                    stack.shift();
                                    stack.shift();
                                }
                            }
                        }
                        return [{
                            type: "meta.tag.punctuation." + (offset == 1 ? "" : "end-") + "tag-open.xml",
                            value: val.slice(0, offset)
                        }, {
                            type: "meta.tag.tag-name.xml",
                            value: val.substr(offset)
                        }];
                    },
                    regex: "</?" + tagRegex + "",
                    next: "jsxAttributes",
                    nextState: "jsx"
                };
                this.$rules.start.unshift(jsxTag);
                var jsxJsRule = {
                    regex: "{",
                    token: "paren.quasi.start",
                    push: "start"
                };
                this.$rules.jsx = [jsxJsRule, jsxTag, { include: "reference" }, { defaultToken: "string" }];
                this.$rules.jsxAttributes = [{
                    token: "meta.tag.punctuation.tag-close.xml",
                    regex: "/?>",
                    onMatch: function (value, currentState, stack) {
                        if (currentState == stack[0]) stack.shift();
                        if (value.length == 2) {
                            if (stack[0] == this.nextState) stack[1]--;
                            if (!stack[1] || stack[1] < 0) {
                                stack.splice(0, 2);
                            }
                        }
                        this.next = stack[0] || "start";
                        return [{ type: this.token, value: value }];
                    },
                    nextState: "jsx"
                }, jsxJsRule, comments("jsxAttributes"), {
                    token: "entity.other.attribute-name.xml",
                    regex: tagRegex
                }, {
                    token: "keyword.operator.attribute-equals.xml",
                    regex: "="
                }, {
                    token: "text.tag-whitespace.xml",
                    regex: "\\s+"
                }, {
                    token: "string.attribute-value.xml",
                    regex: "'",
                    stateName: "jsx_attr_q",
                    push: [{ token: "string.attribute-value.xml", regex: "'", next: "pop" }, { include: "reference" }, { defaultToken: "string.attribute-value.xml" }]
                }, {
                    token: "string.attribute-value.xml",
                    regex: '"',
                    stateName: "jsx_attr_qq",
                    push: [{ token: "string.attribute-value.xml", regex: '"', next: "pop" }, { include: "reference" }, { defaultToken: "string.attribute-value.xml" }]
                }, jsxTag];
                this.$rules.reference = [{
                    token: "constant.language.escape.reference.xml",
                    regex: "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
                }];
            }

            function comments(next) {
                return [{
                    token: "comment", // multi line comment
                    regex: /\/\*/,
                    next: [DocCommentHighlightRules.getTagRule(), { token: "comment", regex: "\\*\\/", next: next || "pop" }, { defaultToken: "comment", caseInsensitive: true }]
                }, {
                    token: "comment",
                    regex: "\\/\\/",
                    next: [DocCommentHighlightRules.getTagRule(), { token: "comment", regex: "$|^", next: next || "pop" }, { defaultToken: "comment", caseInsensitive: true }]
                }];
            }
            exports.JavaScriptHighlightRules = JavaScriptHighlightRules;
        });

        ace.define("ace/mode/matching_brace_outdent", ["require", "exports", "module", "ace/range"], function (require, exports, module) {
            "use strict";

            var Range = require("../range").Range;

            var MatchingBraceOutdent = function () {};

            (function () {

                this.checkOutdent = function (line, input) {
                    if (!/^\s+$/.test(line)) return false;

                    return (/^\s*\}/.test(input)
                    );
                };

                this.autoOutdent = function (doc, row) {
                    var line = doc.getLine(row);
                    var match = line.match(/^(\s*\})/);

                    if (!match) return 0;

                    var column = match[1].length;
                    var openBracePos = doc.findMatchingBracket({ row: row, column: column });

                    if (!openBracePos || openBracePos.row == row) return 0;

                    var indent = this.$getIndent(doc.getLine(openBracePos.row));
                    doc.replace(new Range(row, 0, row, column - 1), indent);
                };

                this.$getIndent = function (line) {
                    return line.match(/^\s*/)[0];
                };
            }).call(MatchingBraceOutdent.prototype);

            exports.MatchingBraceOutdent = MatchingBraceOutdent;
        });

        ace.define("ace/mode/folding/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/range", "ace/mode/folding/fold_mode"], function (require, exports, module) {
            "use strict";

            var oop = require("../../lib/oop");
            var Range = require("../../range").Range;
            var BaseFoldMode = require("./fold_mode").FoldMode;

            var FoldMode = exports.FoldMode = function (commentRegex) {
                if (commentRegex) {
                    this.foldingStartMarker = new RegExp(this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start));
                    this.foldingStopMarker = new RegExp(this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end));
                }
            };
            oop.inherits(FoldMode, BaseFoldMode);

            (function () {

                this.foldingStartMarker = /(\{|\[)[^\}\]]*$|^\s*(\/\*)/;
                this.foldingStopMarker = /^[^\[\{]*(\}|\])|^[\s\*]*(\*\/)/;
                this.singleLineBlockCommentRe = /^\s*(\/\*).*\*\/\s*$/;
                this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
                this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
                this._getFoldWidgetBase = this.getFoldWidget;
                this.getFoldWidget = function (session, foldStyle, row) {
                    var line = session.getLine(row);

                    if (this.singleLineBlockCommentRe.test(line)) {
                        if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line)) return "";
                    }

                    var fw = this._getFoldWidgetBase(session, foldStyle, row);

                    if (!fw && this.startRegionRe.test(line)) return "start"; // lineCommentRegionStart

                    return fw;
                };

                this.getFoldWidgetRange = function (session, foldStyle, row, forceMultiline) {
                    var line = session.getLine(row);

                    if (this.startRegionRe.test(line)) return this.getCommentRegionBlock(session, line, row);

                    var match = line.match(this.foldingStartMarker);
                    if (match) {
                        var i = match.index;

                        if (match[1]) return this.openingBracketBlock(session, match[1], row, i);

                        var range = session.getCommentFoldRange(row, i + match[0].length, 1);

                        if (range && !range.isMultiLine()) {
                            if (forceMultiline) {
                                range = this.getSectionRange(session, row);
                            } else if (foldStyle != "all") range = null;
                        }

                        return range;
                    }

                    if (foldStyle === "markbegin") return;

                    var match = line.match(this.foldingStopMarker);
                    if (match) {
                        var i = match.index + match[0].length;

                        if (match[1]) return this.closingBracketBlock(session, match[1], row, i);

                        return session.getCommentFoldRange(row, i, -1);
                    }
                };

                this.getSectionRange = function (session, row) {
                    var line = session.getLine(row);
                    var startIndent = line.search(/\S/);
                    var startRow = row;
                    var startColumn = line.length;
                    row = row + 1;
                    var endRow = row;
                    var maxRow = session.getLength();
                    while (++row < maxRow) {
                        line = session.getLine(row);
                        var indent = line.search(/\S/);
                        if (indent === -1) continue;
                        if (startIndent > indent) break;
                        var subRange = this.getFoldWidgetRange(session, "all", row);

                        if (subRange) {
                            if (subRange.start.row <= startRow) {
                                break;
                            } else if (subRange.isMultiLine()) {
                                row = subRange.end.row;
                            } else if (startIndent == indent) {
                                break;
                            }
                        }
                        endRow = row;
                    }

                    return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
                };
                this.getCommentRegionBlock = function (session, line, row) {
                    var startColumn = line.search(/\s*$/);
                    var maxRow = session.getLength();
                    var startRow = row;

                    var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
                    var depth = 1;
                    while (++row < maxRow) {
                        line = session.getLine(row);
                        var m = re.exec(line);
                        if (!m) continue;
                        if (m[1]) depth--;else depth++;

                        if (!depth) break;
                    }

                    var endRow = row;
                    if (endRow > startRow) {
                        return new Range(startRow, startColumn, endRow, line.length);
                    }
                };
            }).call(FoldMode.prototype);
        });

        ace.define("ace/mode/javascript", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/javascript_highlight_rules", "ace/mode/matching_brace_outdent", "ace/worker/worker_client", "ace/mode/behaviour/cstyle", "ace/mode/folding/cstyle"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var TextMode = require("./text").Mode;
            var JavaScriptHighlightRules = require("./javascript_highlight_rules").JavaScriptHighlightRules;
            var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
            var WorkerClient = require("../worker/worker_client").WorkerClient;
            var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
            var CStyleFoldMode = require("./folding/cstyle").FoldMode;

            var Mode = function () {
                this.HighlightRules = JavaScriptHighlightRules;

                this.$outdent = new MatchingBraceOutdent();
                this.$behaviour = new CstyleBehaviour();
                this.foldingRules = new CStyleFoldMode();
            };
            oop.inherits(Mode, TextMode);

            (function () {

                this.lineCommentStart = "//";
                this.blockComment = { start: "/*", end: "*/" };

                this.getNextLineIndent = function (state, line, tab) {
                    var indent = this.$getIndent(line);

                    var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
                    var tokens = tokenizedLine.tokens;
                    var endState = tokenizedLine.state;

                    if (tokens.length && tokens[tokens.length - 1].type == "comment") {
                        return indent;
                    }

                    if (state == "start" || state == "no_regex") {
                        var match = line.match(/^.*(?:\bcase\b.*:|[\{\(\[])\s*$/);
                        if (match) {
                            indent += tab;
                        }
                    } else if (state == "doc-start") {
                        if (endState == "start" || endState == "no_regex") {
                            return "";
                        }
                        var match = line.match(/^\s*(\/?)\*/);
                        if (match) {
                            if (match[1]) {
                                indent += " ";
                            }
                            indent += "* ";
                        }
                    }

                    return indent;
                };

                this.checkOutdent = function (state, line, input) {
                    return this.$outdent.checkOutdent(line, input);
                };

                this.autoOutdent = function (state, doc, row) {
                    this.$outdent.autoOutdent(doc, row);
                };

                this.createWorker = function (session) {
                    var worker = new WorkerClient(["ace"], "ace/mode/javascript_worker", "JavaScriptWorker");
                    worker.attachToDocument(session.getDocument());

                    worker.on("annotate", function (results) {
                        session.setAnnotations(results.data);
                    });

                    worker.on("terminate", function () {
                        session.clearAnnotations();
                    });

                    return worker;
                };

                this.$id = "ace/mode/javascript";
            }).call(Mode.prototype);

            exports.Mode = Mode;
        });
    })(this);

    return _retrieveGlobal();
});
System.registerDynamic("github:ajaxorg/ace-builds@1.2.6/mode-scss.js", ["ace/ace"], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

    (function ($__global) {
        ace.define("ace/mode/scss_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/mode/text_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var lang = require("../lib/lang");
            var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

            var ScssHighlightRules = function () {

                var properties = lang.arrayToMap(function () {

                    var browserPrefix = "-webkit-|-moz-|-o-|-ms-|-svg-|-pie-|-khtml-".split("|");

                    var prefixProperties = ("appearance|background-clip|background-inline-policy|background-origin|" + "background-size|binding|border-bottom-colors|border-left-colors|" + "border-right-colors|border-top-colors|border-end|border-end-color|" + "border-end-style|border-end-width|border-image|border-start|" + "border-start-color|border-start-style|border-start-width|box-align|" + "box-direction|box-flex|box-flexgroup|box-ordinal-group|box-orient|" + "box-pack|box-sizing|column-count|column-gap|column-width|column-rule|" + "column-rule-width|column-rule-style|column-rule-color|float-edge|" + "font-feature-settings|font-language-override|force-broken-image-icon|" + "image-region|margin-end|margin-start|opacity|outline|outline-color|" + "outline-offset|outline-radius|outline-radius-bottomleft|" + "outline-radius-bottomright|outline-radius-topleft|outline-radius-topright|" + "outline-style|outline-width|padding-end|padding-start|stack-sizing|" + "tab-size|text-blink|text-decoration-color|text-decoration-line|" + "text-decoration-style|transform|transform-origin|transition|" + "transition-delay|transition-duration|transition-property|" + "transition-timing-function|user-focus|user-input|user-modify|user-select|" + "window-shadow|border-radius").split("|");

                    var properties = ("azimuth|background-attachment|background-color|background-image|" + "background-position|background-repeat|background|border-bottom-color|" + "border-bottom-style|border-bottom-width|border-bottom|border-collapse|" + "border-color|border-left-color|border-left-style|border-left-width|" + "border-left|border-right-color|border-right-style|border-right-width|" + "border-right|border-spacing|border-style|border-top-color|" + "border-top-style|border-top-width|border-top|border-width|border|bottom|" + "box-shadow|box-sizing|caption-side|clear|clip|color|content|counter-increment|" + "counter-reset|cue-after|cue-before|cue|cursor|direction|display|" + "elevation|empty-cells|float|font-family|font-size-adjust|font-size|" + "font-stretch|font-style|font-variant|font-weight|font|height|left|" + "letter-spacing|line-height|list-style-image|list-style-position|" + "list-style-type|list-style|margin-bottom|margin-left|margin-right|" + "margin-top|marker-offset|margin|marks|max-height|max-width|min-height|" + "min-width|opacity|orphans|outline-color|" + "outline-style|outline-width|outline|overflow|overflow-x|overflow-y|padding-bottom|" + "padding-left|padding-right|padding-top|padding|page-break-after|" + "page-break-before|page-break-inside|page|pause-after|pause-before|" + "pause|pitch-range|pitch|play-during|position|quotes|richness|right|" + "size|speak-header|speak-numeral|speak-punctuation|speech-rate|speak|" + "stress|table-layout|text-align|text-decoration|text-indent|" + "text-shadow|text-transform|top|unicode-bidi|vertical-align|" + "visibility|voice-family|volume|white-space|widows|width|word-spacing|" + "z-index").split("|");
                    var ret = [];
                    for (var i = 0, ln = browserPrefix.length; i < ln; i++) {
                        Array.prototype.push.apply(ret, (browserPrefix[i] + prefixProperties.join("|" + browserPrefix[i])).split("|"));
                    }
                    Array.prototype.push.apply(ret, prefixProperties);
                    Array.prototype.push.apply(ret, properties);

                    return ret;
                }());

                var functions = lang.arrayToMap(("hsl|hsla|rgb|rgba|url|attr|counter|counters|abs|adjust_color|adjust_hue|" + "alpha|join|blue|ceil|change_color|comparable|complement|darken|desaturate|" + "floor|grayscale|green|hue|if|invert|join|length|lighten|lightness|mix|" + "nth|opacify|opacity|percentage|quote|red|round|saturate|saturation|" + "scale_color|transparentize|type_of|unit|unitless|unqoute").split("|"));

                var constants = lang.arrayToMap(("absolute|all-scroll|always|armenian|auto|baseline|below|bidi-override|" + "block|bold|bolder|border-box|both|bottom|break-all|break-word|capitalize|center|" + "char|circle|cjk-ideographic|col-resize|collapse|content-box|crosshair|dashed|" + "decimal-leading-zero|decimal|default|disabled|disc|" + "distribute-all-lines|distribute-letter|distribute-space|" + "distribute|dotted|double|e-resize|ellipsis|fixed|georgian|groove|" + "hand|hebrew|help|hidden|hiragana-iroha|hiragana|horizontal|" + "ideograph-alpha|ideograph-numeric|ideograph-parenthesis|" + "ideograph-space|inactive|inherit|inline-block|inline|inset|inside|" + "inter-ideograph|inter-word|italic|justify|katakana-iroha|katakana|" + "keep-all|left|lighter|line-edge|line-through|line|list-item|loose|" + "lower-alpha|lower-greek|lower-latin|lower-roman|lowercase|lr-tb|ltr|" + "medium|middle|move|n-resize|ne-resize|newspaper|no-drop|no-repeat|" + "nw-resize|none|normal|not-allowed|nowrap|oblique|outset|outside|" + "overline|pointer|progress|relative|repeat-x|repeat-y|repeat|right|" + "ridge|row-resize|rtl|s-resize|scroll|se-resize|separate|small-caps|" + "solid|square|static|strict|super|sw-resize|table-footer-group|" + "table-header-group|tb-rl|text-bottom|text-top|text|thick|thin|top|" + "transparent|underline|upper-alpha|upper-latin|upper-roman|uppercase|" + "vertical-ideographic|vertical-text|visible|w-resize|wait|whitespace|" + "zero").split("|"));

                var colors = lang.arrayToMap(("aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|" + "purple|red|silver|teal|white|yellow").split("|"));

                var keywords = lang.arrayToMap("@mixin|@extend|@include|@import|@media|@debug|@warn|@if|@for|@each|@while|@else|@font-face|@-webkit-keyframes|if|and|!default|module|def|end|declare".split("|"));

                var tags = lang.arrayToMap(("a|abbr|acronym|address|applet|area|article|aside|audio|b|base|basefont|bdo|" + "big|blockquote|body|br|button|canvas|caption|center|cite|code|col|colgroup|" + "command|datalist|dd|del|details|dfn|dir|div|dl|dt|em|embed|fieldset|" + "figcaption|figure|font|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|" + "header|hgroup|hr|html|i|iframe|img|input|ins|keygen|kbd|label|legend|li|" + "link|map|mark|menu|meta|meter|nav|noframes|noscript|object|ol|optgroup|" + "option|output|p|param|pre|progress|q|rp|rt|ruby|s|samp|script|section|select|" + "small|source|span|strike|strong|style|sub|summary|sup|table|tbody|td|" + "textarea|tfoot|th|thead|time|title|tr|tt|u|ul|var|video|wbr|xmp").split("|"));

                var numRe = "\\-?(?:(?:[0-9]+)|(?:[0-9]*\\.[0-9]+))";

                this.$rules = {
                    "start": [{
                        token: "comment",
                        regex: "\\/\\/.*$"
                    }, {
                        token: "comment", // multi line comment
                        regex: "\\/\\*",
                        next: "comment"
                    }, {
                        token: "string", // single line
                        regex: '["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]'
                    }, {
                        token: "string", // multi line string start
                        regex: '["].*\\\\$',
                        next: "qqstring"
                    }, {
                        token: "string", // single line
                        regex: "['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"
                    }, {
                        token: "string", // multi line string start
                        regex: "['].*\\\\$",
                        next: "qstring"
                    }, {
                        token: "constant.numeric",
                        regex: numRe + "(?:em|ex|px|cm|mm|in|pt|pc|deg|rad|grad|ms|s|hz|khz|%)"
                    }, {
                        token: "constant.numeric", // hex6 color
                        regex: "#[a-f0-9]{6}"
                    }, {
                        token: "constant.numeric", // hex3 color
                        regex: "#[a-f0-9]{3}"
                    }, {
                        token: "constant.numeric",
                        regex: numRe
                    }, {
                        token: ["support.function", "string", "support.function"],
                        regex: "(url\\()(.*)(\\))"
                    }, {
                        token: function (value) {
                            if (properties.hasOwnProperty(value.toLowerCase())) return "support.type";
                            if (keywords.hasOwnProperty(value)) return "keyword";else if (constants.hasOwnProperty(value)) return "constant.language";else if (functions.hasOwnProperty(value)) return "support.function";else if (colors.hasOwnProperty(value.toLowerCase())) return "support.constant.color";else if (tags.hasOwnProperty(value.toLowerCase())) return "variable.language";else return "text";
                        },
                        regex: "\\-?[@a-z_][@a-z0-9_\\-]*"
                    }, {
                        token: "variable",
                        regex: "[a-z_\\-$][a-z0-9_\\-$]*\\b"
                    }, {
                        token: "variable.language",
                        regex: "#[a-z0-9-_]+"
                    }, {
                        token: "variable.language",
                        regex: "\\.[a-z0-9-_]+"
                    }, {
                        token: "variable.language",
                        regex: ":[a-z0-9-_]+"
                    }, {
                        token: "constant",
                        regex: "[a-z0-9-_]+"
                    }, {
                        token: "keyword.operator",
                        regex: "<|>|<=|>=|==|!=|-|%|#|\\+|\\$|\\+|\\*"
                    }, {
                        token: "paren.lparen",
                        regex: "[[({]"
                    }, {
                        token: "paren.rparen",
                        regex: "[\\])}]"
                    }, {
                        token: "text",
                        regex: "\\s+"
                    }, {
                        caseInsensitive: true
                    }],
                    "comment": [{
                        token: "comment", // closing comment
                        regex: ".*?\\*\\/",
                        next: "start"
                    }, {
                        token: "comment", // comment spanning whole line
                        regex: ".+"
                    }],
                    "qqstring": [{
                        token: "string",
                        regex: '(?:(?:\\\\.)|(?:[^"\\\\]))*?"',
                        next: "start"
                    }, {
                        token: "string",
                        regex: '.+'
                    }],
                    "qstring": [{
                        token: "string",
                        regex: "(?:(?:\\\\.)|(?:[^'\\\\]))*?'",
                        next: "start"
                    }, {
                        token: "string",
                        regex: '.+'
                    }]
                };
            };

            oop.inherits(ScssHighlightRules, TextHighlightRules);

            exports.ScssHighlightRules = ScssHighlightRules;
        });

        ace.define("ace/mode/matching_brace_outdent", ["require", "exports", "module", "ace/range"], function (require, exports, module) {
            "use strict";

            var Range = require("../range").Range;

            var MatchingBraceOutdent = function () {};

            (function () {

                this.checkOutdent = function (line, input) {
                    if (!/^\s+$/.test(line)) return false;

                    return (/^\s*\}/.test(input)
                    );
                };

                this.autoOutdent = function (doc, row) {
                    var line = doc.getLine(row);
                    var match = line.match(/^(\s*\})/);

                    if (!match) return 0;

                    var column = match[1].length;
                    var openBracePos = doc.findMatchingBracket({ row: row, column: column });

                    if (!openBracePos || openBracePos.row == row) return 0;

                    var indent = this.$getIndent(doc.getLine(openBracePos.row));
                    doc.replace(new Range(row, 0, row, column - 1), indent);
                };

                this.$getIndent = function (line) {
                    return line.match(/^\s*/)[0];
                };
            }).call(MatchingBraceOutdent.prototype);

            exports.MatchingBraceOutdent = MatchingBraceOutdent;
        });

        ace.define("ace/mode/behaviour/css", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/mode/behaviour/cstyle", "ace/token_iterator"], function (require, exports, module) {
            "use strict";

            var oop = require("../../lib/oop");
            var Behaviour = require("../behaviour").Behaviour;
            var CstyleBehaviour = require("./cstyle").CstyleBehaviour;
            var TokenIterator = require("../../token_iterator").TokenIterator;

            var CssBehaviour = function () {

                this.inherit(CstyleBehaviour);

                this.add("colon", "insertion", function (state, action, editor, session, text) {
                    if (text === ':') {
                        var cursor = editor.getCursorPosition();
                        var iterator = new TokenIterator(session, cursor.row, cursor.column);
                        var token = iterator.getCurrentToken();
                        if (token && token.value.match(/\s+/)) {
                            token = iterator.stepBackward();
                        }
                        if (token && token.type === 'support.type') {
                            var line = session.doc.getLine(cursor.row);
                            var rightChar = line.substring(cursor.column, cursor.column + 1);
                            if (rightChar === ':') {
                                return {
                                    text: '',
                                    selection: [1, 1]
                                };
                            }
                            if (!line.substring(cursor.column).match(/^\s*;/)) {
                                return {
                                    text: ':;',
                                    selection: [1, 1]
                                };
                            }
                        }
                    }
                });

                this.add("colon", "deletion", function (state, action, editor, session, range) {
                    var selected = session.doc.getTextRange(range);
                    if (!range.isMultiLine() && selected === ':') {
                        var cursor = editor.getCursorPosition();
                        var iterator = new TokenIterator(session, cursor.row, cursor.column);
                        var token = iterator.getCurrentToken();
                        if (token && token.value.match(/\s+/)) {
                            token = iterator.stepBackward();
                        }
                        if (token && token.type === 'support.type') {
                            var line = session.doc.getLine(range.start.row);
                            var rightChar = line.substring(range.end.column, range.end.column + 1);
                            if (rightChar === ';') {
                                range.end.column++;
                                return range;
                            }
                        }
                    }
                });

                this.add("semicolon", "insertion", function (state, action, editor, session, text) {
                    if (text === ';') {
                        var cursor = editor.getCursorPosition();
                        var line = session.doc.getLine(cursor.row);
                        var rightChar = line.substring(cursor.column, cursor.column + 1);
                        if (rightChar === ';') {
                            return {
                                text: '',
                                selection: [1, 1]
                            };
                        }
                    }
                });
            };
            oop.inherits(CssBehaviour, CstyleBehaviour);

            exports.CssBehaviour = CssBehaviour;
        });

        ace.define("ace/mode/folding/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/range", "ace/mode/folding/fold_mode"], function (require, exports, module) {
            "use strict";

            var oop = require("../../lib/oop");
            var Range = require("../../range").Range;
            var BaseFoldMode = require("./fold_mode").FoldMode;

            var FoldMode = exports.FoldMode = function (commentRegex) {
                if (commentRegex) {
                    this.foldingStartMarker = new RegExp(this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start));
                    this.foldingStopMarker = new RegExp(this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end));
                }
            };
            oop.inherits(FoldMode, BaseFoldMode);

            (function () {

                this.foldingStartMarker = /(\{|\[)[^\}\]]*$|^\s*(\/\*)/;
                this.foldingStopMarker = /^[^\[\{]*(\}|\])|^[\s\*]*(\*\/)/;
                this.singleLineBlockCommentRe = /^\s*(\/\*).*\*\/\s*$/;
                this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
                this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
                this._getFoldWidgetBase = this.getFoldWidget;
                this.getFoldWidget = function (session, foldStyle, row) {
                    var line = session.getLine(row);

                    if (this.singleLineBlockCommentRe.test(line)) {
                        if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line)) return "";
                    }

                    var fw = this._getFoldWidgetBase(session, foldStyle, row);

                    if (!fw && this.startRegionRe.test(line)) return "start"; // lineCommentRegionStart

                    return fw;
                };

                this.getFoldWidgetRange = function (session, foldStyle, row, forceMultiline) {
                    var line = session.getLine(row);

                    if (this.startRegionRe.test(line)) return this.getCommentRegionBlock(session, line, row);

                    var match = line.match(this.foldingStartMarker);
                    if (match) {
                        var i = match.index;

                        if (match[1]) return this.openingBracketBlock(session, match[1], row, i);

                        var range = session.getCommentFoldRange(row, i + match[0].length, 1);

                        if (range && !range.isMultiLine()) {
                            if (forceMultiline) {
                                range = this.getSectionRange(session, row);
                            } else if (foldStyle != "all") range = null;
                        }

                        return range;
                    }

                    if (foldStyle === "markbegin") return;

                    var match = line.match(this.foldingStopMarker);
                    if (match) {
                        var i = match.index + match[0].length;

                        if (match[1]) return this.closingBracketBlock(session, match[1], row, i);

                        return session.getCommentFoldRange(row, i, -1);
                    }
                };

                this.getSectionRange = function (session, row) {
                    var line = session.getLine(row);
                    var startIndent = line.search(/\S/);
                    var startRow = row;
                    var startColumn = line.length;
                    row = row + 1;
                    var endRow = row;
                    var maxRow = session.getLength();
                    while (++row < maxRow) {
                        line = session.getLine(row);
                        var indent = line.search(/\S/);
                        if (indent === -1) continue;
                        if (startIndent > indent) break;
                        var subRange = this.getFoldWidgetRange(session, "all", row);

                        if (subRange) {
                            if (subRange.start.row <= startRow) {
                                break;
                            } else if (subRange.isMultiLine()) {
                                row = subRange.end.row;
                            } else if (startIndent == indent) {
                                break;
                            }
                        }
                        endRow = row;
                    }

                    return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
                };
                this.getCommentRegionBlock = function (session, line, row) {
                    var startColumn = line.search(/\s*$/);
                    var maxRow = session.getLength();
                    var startRow = row;

                    var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
                    var depth = 1;
                    while (++row < maxRow) {
                        line = session.getLine(row);
                        var m = re.exec(line);
                        if (!m) continue;
                        if (m[1]) depth--;else depth++;

                        if (!depth) break;
                    }

                    var endRow = row;
                    if (endRow > startRow) {
                        return new Range(startRow, startColumn, endRow, line.length);
                    }
                };
            }).call(FoldMode.prototype);
        });

        ace.define("ace/mode/scss", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/scss_highlight_rules", "ace/mode/matching_brace_outdent", "ace/mode/behaviour/css", "ace/mode/folding/cstyle"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var TextMode = require("./text").Mode;
            var ScssHighlightRules = require("./scss_highlight_rules").ScssHighlightRules;
            var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
            var CssBehaviour = require("./behaviour/css").CssBehaviour;
            var CStyleFoldMode = require("./folding/cstyle").FoldMode;

            var Mode = function () {
                this.HighlightRules = ScssHighlightRules;
                this.$outdent = new MatchingBraceOutdent();
                this.$behaviour = new CssBehaviour();
                this.foldingRules = new CStyleFoldMode();
            };
            oop.inherits(Mode, TextMode);

            (function () {

                this.lineCommentStart = "//";
                this.blockComment = { start: "/*", end: "*/" };

                this.getNextLineIndent = function (state, line, tab) {
                    var indent = this.$getIndent(line);
                    var tokens = this.getTokenizer().getLineTokens(line, state).tokens;
                    if (tokens.length && tokens[tokens.length - 1].type == "comment") {
                        return indent;
                    }

                    var match = line.match(/^.*\{\s*$/);
                    if (match) {
                        indent += tab;
                    }

                    return indent;
                };

                this.checkOutdent = function (state, line, input) {
                    return this.$outdent.checkOutdent(line, input);
                };

                this.autoOutdent = function (state, doc, row) {
                    this.$outdent.autoOutdent(doc, row);
                };

                this.$id = "ace/mode/scss";
            }).call(Mode.prototype);

            exports.Mode = Mode;
        });
    })(this);

    return _retrieveGlobal();
});
System.registerDynamic('npm:jspm-nodelibs-buffer@0.2.1/global.js', ['./buffer.js'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('./buffer.js').Buffer;
  return module.exports;
});
System.registerDynamic('npm:rhythmmeister@1.0.1/functions.js', ['postcss', 'buffer', 'buffer/global'], true, function ($__require, exports, module) {
    var Buffer = $__require('buffer/global');
    var define,
        global = this || self,
        GLOBAL = global;

    $__require.resolve = function (request) {
        return System.get('@@cjs-helpers').requireResolve(request, module.id);
    };

    var postcss = $__require('postcss');
    var buffer = $__require('buffer');
    var Buffer = buffer.Buffer;

    var functions = {
        getFontPreset: function (localOptions, name) {
            return localOptions.presets && localOptions.presets[name];
        },

        roundToNumber: function (valueToRound, roundTo) {
            return Math.round(valueToRound / roundTo) * roundTo;
        },

        ceilToNumber: function (valueToCeil, ceilTo) {
            return Math.ceil(valueToCeil / ceilTo) * ceilTo;
        },

        getPixelValueFromCssProperty: function (properties) {
            var width = false;
            var propertiesSplit = properties.split(' ');

            propertiesSplit.forEach(property => {
                if (parseInt(property)) {
                    if (width) {
                        throw new Error('This function does not know how to deal with multiple pixel values in a css property value.');
                    }
                    width = parseInt(property);
                }
            });

            return width;
        },

        applyRs: function (declaration, localDocumentRowSize) {
            if (declaration.value.indexOf('rs') !== -1) {
                var regexp = new RegExp('(\\d*\\.?\\d+)rs', 'gi');

                declaration.value = declaration.value.replace(regexp, function ($1) {
                    return parseFloat($1) * localDocumentRowSize + 'px';
                });
            }
        },

        applyFontProperties: function (rule, declaration, fontPreset, localDocumentRowSize) {
            var propertiesToSkip = ['rows', 'base-line-percentage'];

            Object.keys(fontPreset).forEach(property => {
                if (propertiesToSkip.indexOf(property) === -1) {
                    rule.insertAfter(declaration, postcss.parse(property + ': ' + fontPreset[property]));
                }
            });

            rule.insertAfter(declaration, postcss.parse('line-height: ' + localDocumentRowSize * fontPreset['rows'] + 'px'));
        },

        calculateTopCorrection: function (fontPreset, localDocumentRowSize) {
            var initialFontBase = localDocumentRowSize * fontPreset['rows'] / 2 + (parseFloat(fontPreset['base-line-percentage']) - 0.5) * parseInt(fontPreset['font-size']);
            var wantedFontSize = functions.roundToNumber(initialFontBase, localDocumentRowSize);
            var topCorrection = wantedFontSize - initialFontBase;

            if (topCorrection < localDocumentRowSize) {
                topCorrection = topCorrection + localDocumentRowSize;
            }

            return topCorrection;
        },

        subtractBorder: function (rule, paddingCorrection, localDocumentRowSize, type) {
            rule.walkDecls(function (possibleBorder) {
                if (possibleBorder.prop == 'border') {
                    var allBorderWidth = functions.getPixelValueFromCssProperty(possibleBorder.value);
                    if (allBorderWidth) {
                        paddingCorrection = paddingCorrection - allBorderWidth;
                    }
                }

                if (possibleBorder.prop == 'border-' + type) {
                    var borderTopWidth = functions.getPixelValueFromCssProperty(possibleBorder.value);
                    if (borderTopWidth) {
                        paddingCorrection = paddingCorrection - borderTopWidth;
                    }
                }
            });

            if (paddingCorrection < 0) {
                paddingCorrection = paddingCorrection + localDocumentRowSize;
            }

            return paddingCorrection;
        },

        subtractBorderTop: function (rule, paddingTopCorrection, localDocumentRowSize) {
            return functions.subtractBorder(rule, paddingTopCorrection, localDocumentRowSize, 'top');
        },

        subtractBorderBottom: function (rule, paddingBottomCorrection, localDocumentRowSize) {
            return functions.subtractBorder(rule, paddingBottomCorrection, localDocumentRowSize, 'bottom');
        },

        paddingOrMarginToLongHand: function (value) {
            var valueSplit = value.split(' ');

            if (valueSplit.length == 1) {
                return {
                    top: value,
                    right: value,
                    bottom: value,
                    left: value
                };
            }

            if (valueSplit.length == 2) {
                return {
                    top: valueSplit[0],
                    right: valueSplit[1],
                    bottom: valueSplit[0],
                    left: valueSplit[1]
                };
            }

            if (valueSplit.length == 3) {
                return {
                    top: valueSplit[0],
                    right: valueSplit[1],
                    bottom: valueSplit[2],
                    left: valueSplit[1]
                };
            }

            if (valueSplit.length == 4) {
                return {
                    top: valueSplit[0],
                    right: valueSplit[1],
                    bottom: valueSplit[2],
                    left: valueSplit[3]
                };
            }
        },

        fixPadding: function (rule, declaration, paddingTopCorrection, paddingBottomCorrection) {
            var paddingLongHand = {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
            };

            rule.walkDecls(function (possiblePadding) {
                if (possiblePadding.prop == 'padding') {
                    paddingLongHand = functions.paddingOrMarginToLongHand(possiblePadding.value);
                    possiblePadding.remove();
                }

                if (possiblePadding.prop == 'padding-top') {
                    paddingLongHand.top = parseInt(possiblePadding.value);
                    possiblePadding.remove();
                }

                if (possiblePadding.prop == 'padding-bottom') {
                    paddingLongHand.bottom = parseInt(possiblePadding.value);
                    possiblePadding.remove();
                }
            });

            paddingTopCorrection = parseInt(paddingLongHand.top) + paddingTopCorrection;
            paddingBottomCorrection = parseInt(paddingLongHand.bottom) + paddingBottomCorrection;

            if (paddingTopCorrection) {
                rule.insertAfter(declaration, postcss.parse('padding-top: ' + paddingTopCorrection + 'px'));
            }

            if (paddingBottomCorrection) {
                rule.insertAfter(declaration, postcss.parse('padding-bottom: ' + paddingBottomCorrection + 'px'));
            }

            if (paddingLongHand.left) {
                rule.insertAfter(declaration, postcss.parse('padding-left: ' + paddingLongHand.left));
            }

            if (paddingLongHand.right) {
                rule.insertAfter(declaration, postcss.parse('padding-right: ' + paddingLongHand.right));
            }
        },

        applyGridHelper: function (rule, declaration, localDocumentRowSize) {
            if (declaration.prop == 'vertical-rhythm-grid') {
                var properties = declaration.value.split(' ');

                var firstRowOddColor = properties[0];
                var firstRowEvenColor = properties[1];

                var otherRowOddColor = properties[2];
                var otherRowEvenColor = properties[3];

                var horizontalWidth = properties[4];
                var alternation = properties[5];

                var oneLineWidth = parseInt(horizontalWidth);
                var svgWidth = oneLineWidth * 2;
                var svgHeight = alternation * localDocumentRowSize;

                var svgStart = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="' + svgWidth + '" height="' + svgHeight + '" viewBox="0 0 ' + svgWidth + ' ' + svgHeight + '">';

                var svgMiddle = '';

                for (i = 0; i < alternation; i++) {
                    var rowOddColor = i == 0 ? firstRowOddColor : otherRowOddColor;
                    var rowEvenColor = i == 0 ? firstRowEvenColor : otherRowEvenColor;
                    var y = i * localDocumentRowSize;

                    svgMiddle += '<rect width="' + oneLineWidth + '" height="1" x="0" y="' + y + '" fill="' + rowOddColor + '"/><rect width="' + oneLineWidth + '" height="1" x="' + oneLineWidth + '" y="' + y + '" fill="' + rowEvenColor + '"/>';
                }

                var svgEnd = '</svg>';

                var svg = svgStart + svgMiddle + svgEnd;

                var base64String = new Buffer(svg).toString('base64');
                declaration.remove();

                rule.insertAfter(declaration, postcss.parse('background-image:  url("data:image/svg+xml;base64,' + base64String + '")'));
            }
        },

        purgeCache: function (moduleName) {
            // Traverse the cache looking for the files
            // loaded by the specified module name
            functions.searchCache(moduleName, function (mod) {
                delete $__require.cache[mod.id];
            });

            // Remove cached paths to the module.
            // Thanks to @bentael for pointing this out.
            Object.keys(module.constructor._pathCache).forEach(function (cacheKey) {
                if (cacheKey.indexOf(moduleName) > 0) {
                    delete module.constructor._pathCache[cacheKey];
                }
            });
        },

        searchCache: function (moduleName, callback) {
            // Resolve the module identified by the specified name
            var mod = $__require.resolve(moduleName);

            // Check if the module has been resolved and found within
            // the cache
            if (mod && (mod = $__require.cache[mod]) !== undefined) {
                // Recursively go over the results
                (function traverse(mod) {
                    // Go over each of the module's children and
                    // traverse them
                    mod.children.forEach(function (child) {
                        traverse(child);
                    });

                    // Call the specified callback providing the
                    // found cached module
                    callback(mod);
                })(mod);
            }
        }
    };

    module.exports = functions;
    return module.exports;
});
System.registerDynamic("npm:rhythmmeister@1.0.1.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      },
      "functions.js": {
        "globals": {
          "Buffer": "buffer/global"
        }
      },
      "test/*": {
        "format": "esm"
      }
    }
  };
});

System.registerDynamic('npm:rhythmmeister@1.0.1/index.js', ['postcss', './functions.js'], true, function ($__require, exports, module) {
    var define,
        global = this || self,
        GLOBAL = global;
    var postcss = $__require('postcss');
    var functions = $__require('./functions.js');

    module.exports = {
        processor: postcss.plugin('rhythmmeister', function (options) {

            options = options || {};
            var documentRowSize = parseInt(options['document-row-size']);

            return function (css) {
                css.walkRules(function (rule) {
                    rule.walkDecls(function (declaration, i) {
                        functions.applyRs(declaration, documentRowSize);
                        functions.applyGridHelper(rule, declaration, documentRowSize);
                    });
                });

                css.walkRules(function (rule) {
                    rule.walkDecls(function (declaration, i) {
                        if (declaration.prop == 'font-preset' && functions.getFontPreset(options, declaration.value)) {
                            var fontPreset = functions.getFontPreset(options, declaration.value);
                            functions.applyFontProperties(rule, declaration, fontPreset, documentRowSize);

                            var paddingTopCorrection = functions.calculateTopCorrection(fontPreset, documentRowSize);
                            var paddingBottomCorrection = documentRowSize - paddingTopCorrection;

                            paddingTopCorrection = functions.subtractBorderTop(rule, paddingTopCorrection, documentRowSize);
                            paddingBottomCorrection = functions.subtractBorderBottom(rule, paddingBottomCorrection, documentRowSize);

                            functions.fixPadding(rule, declaration, Math.round(paddingTopCorrection), Math.round(paddingBottomCorrection));

                            declaration.remove();
                        }
                    });
                });
            };
        }),

        load: function (moduleName) {
            functions.purgeCache(moduleName);
            return $__require(moduleName);
        }
    };
    return module.exports;
});
System.registerDynamic('npm:postcss@5.2.6/lib/vendor.js', ['process'], true, function ($__require, exports, module) {
    'use strict';

    var process = $__require('process');
    var define,
        global = this || self,
        GLOBAL = global;
    exports.__esModule = true;
    /**
     * Contains helpers for working with vendor prefixes.
     *
     * @example
     * const vendor = postcss.vendor;
     *
     * @namespace vendor
     */
    var vendor = {

        /**
         * Returns the vendor prefix extracted from an input string.
         *
         * @param {string} prop - string with or without vendor prefix
         *
         * @return {string} vendor prefix or empty string
         *
         * @example
         * postcss.vendor.prefix('-moz-tab-size') //=> '-moz-'
         * postcss.vendor.prefix('tab-size')      //=> ''
         */
        prefix: function prefix(prop) {
            var match = prop.match(/^(-\w+-)/);
            if (match) {
                return match[0];
            } else {
                return '';
            }
        },

        /**
         * Returns the input string stripped of its vendor prefix.
         *
         * @param {string} prop - string with or without vendor prefix
         *
         * @return {string} string name without vendor prefixes
         *
         * @example
         * postcss.vendor.unprefixed('-moz-tab-size') //=> 'tab-size'
         */
        unprefixed: function unprefixed(prop) {
            return prop.replace(/^-\w+-/, '');
        }
    };

    exports.default = vendor;
    module.exports = exports['default'];
    return module.exports;
});
System.registerDynamic('npm:postcss@5.2.6/lib/map-generator.js', ['js-base64', 'source-map', 'path', 'process'], true, function ($__require, exports, module) {
    'use strict';

    var process = $__require('process');
    var define,
        global = this || self,
        GLOBAL = global;
    exports.__esModule = true;

    var _jsBase = $__require('js-base64');

    var _sourceMap = $__require('source-map');

    var _sourceMap2 = _interopRequireDefault(_sourceMap);

    var _path = $__require('path');

    var _path2 = _interopRequireDefault(_path);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var MapGenerator = function () {
        function MapGenerator(stringify, root, opts) {
            _classCallCheck(this, MapGenerator);

            this.stringify = stringify;
            this.mapOpts = opts.map || {};
            this.root = root;
            this.opts = opts;
        }

        MapGenerator.prototype.isMap = function isMap() {
            if (typeof this.opts.map !== 'undefined') {
                return !!this.opts.map;
            } else {
                return this.previous().length > 0;
            }
        };

        MapGenerator.prototype.previous = function previous() {
            var _this = this;

            if (!this.previousMaps) {
                this.previousMaps = [];
                this.root.walk(function (node) {
                    if (node.source && node.source.input.map) {
                        var map = node.source.input.map;
                        if (_this.previousMaps.indexOf(map) === -1) {
                            _this.previousMaps.push(map);
                        }
                    }
                });
            }

            return this.previousMaps;
        };

        MapGenerator.prototype.isInline = function isInline() {
            if (typeof this.mapOpts.inline !== 'undefined') {
                return this.mapOpts.inline;
            }

            var annotation = this.mapOpts.annotation;
            if (typeof annotation !== 'undefined' && annotation !== true) {
                return false;
            }

            if (this.previous().length) {
                return this.previous().some(function (i) {
                    return i.inline;
                });
            } else {
                return true;
            }
        };

        MapGenerator.prototype.isSourcesContent = function isSourcesContent() {
            if (typeof this.mapOpts.sourcesContent !== 'undefined') {
                return this.mapOpts.sourcesContent;
            }
            if (this.previous().length) {
                return this.previous().some(function (i) {
                    return i.withContent();
                });
            } else {
                return true;
            }
        };

        MapGenerator.prototype.clearAnnotation = function clearAnnotation() {
            if (this.mapOpts.annotation === false) return;

            var node = void 0;
            for (var i = this.root.nodes.length - 1; i >= 0; i--) {
                node = this.root.nodes[i];
                if (node.type !== 'comment') continue;
                if (node.text.indexOf('# sourceMappingURL=') === 0) {
                    this.root.removeChild(i);
                }
            }
        };

        MapGenerator.prototype.setSourcesContent = function setSourcesContent() {
            var _this2 = this;

            var already = {};
            this.root.walk(function (node) {
                if (node.source) {
                    var from = node.source.input.from;
                    if (from && !already[from]) {
                        already[from] = true;
                        var relative = _this2.relative(from);
                        _this2.map.setSourceContent(relative, node.source.input.css);
                    }
                }
            });
        };

        MapGenerator.prototype.applyPrevMaps = function applyPrevMaps() {
            for (var _iterator = this.previous(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var prev = _ref;

                var from = this.relative(prev.file);
                var root = prev.root || _path2.default.dirname(prev.file);
                var map = void 0;

                if (this.mapOpts.sourcesContent === false) {
                    map = new _sourceMap2.default.SourceMapConsumer(prev.text);
                    if (map.sourcesContent) {
                        map.sourcesContent = map.sourcesContent.map(function () {
                            return null;
                        });
                    }
                } else {
                    map = prev.consumer();
                }

                this.map.applySourceMap(map, from, this.relative(root));
            }
        };

        MapGenerator.prototype.isAnnotation = function isAnnotation() {
            if (this.isInline()) {
                return true;
            } else if (typeof this.mapOpts.annotation !== 'undefined') {
                return this.mapOpts.annotation;
            } else if (this.previous().length) {
                return this.previous().some(function (i) {
                    return i.annotation;
                });
            } else {
                return true;
            }
        };

        MapGenerator.prototype.addAnnotation = function addAnnotation() {
            var content = void 0;

            if (this.isInline()) {
                content = 'data:application/json;base64,' + _jsBase.Base64.encode(this.map.toString());
            } else if (typeof this.mapOpts.annotation === 'string') {
                content = this.mapOpts.annotation;
            } else {
                content = this.outputFile() + '.map';
            }

            var eol = '\n';
            if (this.css.indexOf('\r\n') !== -1) eol = '\r\n';

            this.css += eol + '/*# sourceMappingURL=' + content + ' */';
        };

        MapGenerator.prototype.outputFile = function outputFile() {
            if (this.opts.to) {
                return this.relative(this.opts.to);
            } else if (this.opts.from) {
                return this.relative(this.opts.from);
            } else {
                return 'to.css';
            }
        };

        MapGenerator.prototype.generateMap = function generateMap() {
            this.generateString();
            if (this.isSourcesContent()) this.setSourcesContent();
            if (this.previous().length > 0) this.applyPrevMaps();
            if (this.isAnnotation()) this.addAnnotation();

            if (this.isInline()) {
                return [this.css];
            } else {
                return [this.css, this.map];
            }
        };

        MapGenerator.prototype.relative = function relative(file) {
            if (file.indexOf('<') === 0) return file;
            if (/^\w+:\/\//.test(file)) return file;

            var from = this.opts.to ? _path2.default.dirname(this.opts.to) : '.';

            if (typeof this.mapOpts.annotation === 'string') {
                from = _path2.default.dirname(_path2.default.resolve(from, this.mapOpts.annotation));
            }

            file = _path2.default.relative(from, file);
            if (_path2.default.sep === '\\') {
                return file.replace(/\\/g, '/');
            } else {
                return file;
            }
        };

        MapGenerator.prototype.sourcePath = function sourcePath(node) {
            if (this.mapOpts.from) {
                return this.mapOpts.from;
            } else {
                return this.relative(node.source.input.from);
            }
        };

        MapGenerator.prototype.generateString = function generateString() {
            var _this3 = this;

            this.css = '';
            this.map = new _sourceMap2.default.SourceMapGenerator({ file: this.outputFile() });

            var line = 1;
            var column = 1;

            var lines = void 0,
                last = void 0;
            this.stringify(this.root, function (str, node, type) {
                _this3.css += str;

                if (node && type !== 'end') {
                    if (node.source && node.source.start) {
                        _this3.map.addMapping({
                            source: _this3.sourcePath(node),
                            generated: { line: line, column: column - 1 },
                            original: {
                                line: node.source.start.line,
                                column: node.source.start.column - 1
                            }
                        });
                    } else {
                        _this3.map.addMapping({
                            source: '<no source>',
                            original: { line: 1, column: 0 },
                            generated: { line: line, column: column - 1 }
                        });
                    }
                }

                lines = str.match(/\n/g);
                if (lines) {
                    line += lines.length;
                    last = str.lastIndexOf('\n');
                    column = str.length - last;
                } else {
                    column += str.length;
                }

                if (node && type !== 'start') {
                    if (node.source && node.source.end) {
                        _this3.map.addMapping({
                            source: _this3.sourcePath(node),
                            generated: { line: line, column: column - 1 },
                            original: {
                                line: node.source.end.line,
                                column: node.source.end.column
                            }
                        });
                    } else {
                        _this3.map.addMapping({
                            source: '<no source>',
                            original: { line: 1, column: 0 },
                            generated: { line: line, column: column - 1 }
                        });
                    }
                }
            });
        };

        MapGenerator.prototype.generate = function generate() {
            this.clearAnnotation();

            if (this.isMap()) {
                return this.generateMap();
            } else {
                var result = '';
                this.stringify(this.root, function (i) {
                    result += i;
                });
                return [result];
            }
        };

        return MapGenerator;
    }();

    exports.default = MapGenerator;
    module.exports = exports['default'];
    return module.exports;
});
System.registerDynamic('npm:postcss@5.2.6/lib/warning.js', ['process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * Represents a plugin’s warning. It can be created using {@link Node#warn}.
   *
   * @example
   * if ( decl.important ) {
   *     decl.warn(result, 'Avoid !important', { word: '!important' });
   * }
   */
  var Warning = function () {

    /**
     * @param {string} text        - warning message
     * @param {Object} [opts]      - warning options
     * @param {Node}   opts.node   - CSS node that caused the warning
     * @param {string} opts.word   - word in CSS source that caused the warning
     * @param {number} opts.index  - index in CSS node string that caused
     *                               the warning
     * @param {string} opts.plugin - name of the plugin that created
     *                               this warning. {@link Result#warn} fills
     *                               this property automatically.
     */
    function Warning(text) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Warning);

      /**
       * @member {string} - Type to filter warnings from
       *                    {@link Result#messages}. Always equal
       *                    to `"warning"`.
       *
       * @example
       * const nonWarning = result.messages.filter(i => i.type !== 'warning')
       */
      this.type = 'warning';
      /**
       * @member {string} - The warning message.
       *
       * @example
       * warning.text //=> 'Try to avoid !important'
       */
      this.text = text;

      if (opts.node && opts.node.source) {
        var pos = opts.node.positionBy(opts);
        /**
         * @member {number} - Line in the input file
         *                    with this warning’s source
         *
         * @example
         * warning.line //=> 5
         */
        this.line = pos.line;
        /**
         * @member {number} - Column in the input file
         *                    with this warning’s source.
         *
         * @example
         * warning.column //=> 6
         */
        this.column = pos.column;
      }

      for (var opt in opts) {
        this[opt] = opts[opt];
      }
    }

    /**
     * Returns a warning position and message.
     *
     * @example
     * warning.toString() //=> 'postcss-lint:a.css:10:14: Avoid !important'
     *
     * @return {string} warning position and message
     */

    Warning.prototype.toString = function toString() {
      if (this.node) {
        return this.node.error(this.text, {
          plugin: this.plugin,
          index: this.index,
          word: this.word
        }).message;
      } else if (this.plugin) {
        return this.plugin + ': ' + this.text;
      } else {
        return this.text;
      }
    };

    /**
     * @memberof Warning#
     * @member {string} plugin - The name of the plugin that created
     *                           it will fill this property automatically.
     *                           this warning. When you call {@link Node#warn}
     *
     * @example
     * warning.plugin //=> 'postcss-important'
     */

    /**
     * @memberof Warning#
     * @member {Node} node - Contains the CSS node that caused the warning.
     *
     * @example
     * warning.node.toString() //=> 'color: white !important'
     */

    return Warning;
  }();

  exports.default = Warning;
  module.exports = exports['default'];
  return module.exports;
});
System.registerDynamic('npm:postcss@5.2.6/lib/result.js', ['./warning', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _warning = $__require('./warning');

  var _warning2 = _interopRequireDefault(_warning);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * Provides the result of the PostCSS transformations.
   *
   * A Result instance is returned by {@link LazyResult#then}
   * or {@link Root#toResult} methods.
   *
   * @example
   * postcss([cssnext]).process(css).then(function (result) {
   *    console.log(result.css);
   * });
   *
   * @example
   * var result2 = postcss.parse(css).toResult();
   */
  var Result = function () {

    /**
     * @param {Processor} processor - processor used for this transformation.
     * @param {Root}      root      - Root node after all transformations.
     * @param {processOptions} opts - options from the {@link Processor#process}
     *                                or {@link Root#toResult}
     */
    function Result(processor, root, opts) {
      _classCallCheck(this, Result);

      /**
       * @member {Processor} - The Processor instance used
       *                       for this transformation.
       *
       * @example
       * for ( let plugin of result.processor.plugins) {
       *   if ( plugin.postcssPlugin === 'postcss-bad' ) {
       *     throw 'postcss-good is incompatible with postcss-bad';
       *   }
       * });
       */
      this.processor = processor;
      /**
       * @member {Message[]} - Contains messages from plugins
       *                       (e.g., warnings or custom messages).
       *                       Each message should have type
       *                       and plugin properties.
       *
       * @example
       * postcss.plugin('postcss-min-browser', () => {
       *   return (root, result) => {
       *     var browsers = detectMinBrowsersByCanIUse(root);
       *     result.messages.push({
       *       type:    'min-browser',
       *       plugin:  'postcss-min-browser',
       *       browsers: browsers
       *     });
       *   };
       * });
       */
      this.messages = [];
      /**
       * @member {Root} - Root node after all transformations.
       *
       * @example
       * root.toResult().root == root;
       */
      this.root = root;
      /**
       * @member {processOptions} - Options from the {@link Processor#process}
       *                            or {@link Root#toResult} call
       *                            that produced this Result instance.
       *
       * @example
       * root.toResult(opts).opts == opts;
       */
      this.opts = opts;
      /**
       * @member {string} - A CSS string representing of {@link Result#root}.
       *
       * @example
       * postcss.parse('a{}').toResult().css //=> "a{}"
       */
      this.css = undefined;
      /**
       * @member {SourceMapGenerator} - An instance of `SourceMapGenerator`
       *                                class from the `source-map` library,
       *                                representing changes
       *                                to the {@link Result#root} instance.
       *
       * @example
       * result.map.toJSON() //=> { version: 3, file: 'a.css', … }
       *
       * @example
       * if ( result.map ) {
       *   fs.writeFileSync(result.opts.to + '.map', result.map.toString());
       * }
       */
      this.map = undefined;
    }

    /**
     * Returns for @{link Result#css} content.
     *
     * @example
     * result + '' === result.css
     *
     * @return {string} string representing of {@link Result#root}
     */

    Result.prototype.toString = function toString() {
      return this.css;
    };

    /**
     * Creates an instance of {@link Warning} and adds it
     * to {@link Result#messages}.
     *
     * @param {string} text        - warning message
     * @param {Object} [opts]      - warning options
     * @param {Node}   opts.node   - CSS node that caused the warning
     * @param {string} opts.word   - word in CSS source that caused the warning
     * @param {number} opts.index  - index in CSS node string that caused
     *                               the warning
     * @param {string} opts.plugin - name of the plugin that created
     *                               this warning. {@link Result#warn} fills
     *                               this property automatically.
     *
     * @return {Warning} created warning
     */

    Result.prototype.warn = function warn(text) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!opts.plugin) {
        if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
          opts.plugin = this.lastPlugin.postcssPlugin;
        }
      }

      var warning = new _warning2.default(text, opts);
      this.messages.push(warning);

      return warning;
    };

    /**
     * Returns warnings from plugins. Filters {@link Warning} instances
     * from {@link Result#messages}.
     *
     * @example
     * result.warnings().forEach(warn => {
     *   console.warn(warn.toString());
     * });
     *
     * @return {Warning[]} warnings from plugins
     */

    Result.prototype.warnings = function warnings() {
      return this.messages.filter(function (i) {
        return i.type === 'warning';
      });
    };

    /**
     * An alias for the {@link Result#css} property.
     * Use it with syntaxes that generate non-CSS output.
     * @type {string}
     *
     * @example
     * result.css === result.content;
     */

    _createClass(Result, [{
      key: 'content',
      get: function get() {
        return this.css;
      }
    }]);

    return Result;
  }();

  exports.default = Result;

  /**
   * @typedef  {object} Message
   * @property {string} type   - message type
   * @property {string} plugin - source PostCSS plugin name
   */

  module.exports = exports['default'];
  return module.exports;
});
System.registerDynamic('npm:postcss@5.2.6/lib/declaration.js', ['./warn-once', './node', 'process'], true, function ($__require, exports, module) {
    'use strict';

    var process = $__require('process');
    var define,
        global = this || self,
        GLOBAL = global;
    exports.__esModule = true;

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
        }return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
    }();

    var _warnOnce = $__require('./warn-once');

    var _warnOnce2 = _interopRequireDefault(_warnOnce);

    var _node = $__require('./node');

    var _node2 = _interopRequireDefault(_node);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    /**
     * Represents a CSS declaration.
     *
     * @extends Node
     *
     * @example
     * const root = postcss.parse('a { color: black }');
     * const decl = root.first.first;
     * decl.type       //=> 'decl'
     * decl.toString() //=> ' color: black'
     */
    var Declaration = function (_Node) {
        _inherits(Declaration, _Node);

        function Declaration(defaults) {
            _classCallCheck(this, Declaration);

            var _this = _possibleConstructorReturn(this, _Node.call(this, defaults));

            _this.type = 'decl';
            return _this;
        }

        _createClass(Declaration, [{
            key: '_value',
            get: function get() {
                (0, _warnOnce2.default)('Node#_value was deprecated. Use Node#raws.value');
                return this.raws.value;
            },
            set: function set(val) {
                (0, _warnOnce2.default)('Node#_value was deprecated. Use Node#raws.value');
                this.raws.value = val;
            }
        }, {
            key: '_important',
            get: function get() {
                (0, _warnOnce2.default)('Node#_important was deprecated. Use Node#raws.important');
                return this.raws.important;
            },
            set: function set(val) {
                (0, _warnOnce2.default)('Node#_important was deprecated. Use Node#raws.important');
                this.raws.important = val;
            }

            /**
             * @memberof Declaration#
             * @member {string} prop - the declaration’s property name
             *
             * @example
             * const root = postcss.parse('a { color: black }');
             * const decl = root.first.first;
             * decl.prop //=> 'color'
             */

            /**
             * @memberof Declaration#
             * @member {string} value - the declaration’s value
             *
             * @example
             * const root = postcss.parse('a { color: black }');
             * const decl = root.first.first;
             * decl.value //=> 'black'
             */

            /**
             * @memberof Declaration#
             * @member {boolean} important - `true` if the declaration
             *                               has an !important annotation.
             *
             * @example
             * const root = postcss.parse('a { color: black !important; color: red }');
             * root.first.first.important //=> true
             * root.first.last.important  //=> undefined
             */

            /**
             * @memberof Declaration#
             * @member {object} raws - Information to generate byte-to-byte equal
             *                         node string as it was in the origin input.
             *
             * Every parser saves its own properties,
             * but the default CSS parser uses:
             *
             * * `before`: the space symbols before the node. It also stores `*`
             *   and `_` symbols before the declaration (IE hack).
             * * `between`: the symbols between the property and value
             *   for declarations, selector and `{` for rules, or last parameter
             *   and `{` for at-rules.
             * * `important`: the content of the important statement,
             *   if it is not just `!important`.
             *
             * PostCSS cleans declaration from comments and extra spaces,
             * but it stores origin content in raws properties.
             * As such, if you don’t change a declaration’s value,
             * PostCSS will use the raw value with comments.
             *
             * @example
             * const root = postcss.parse('a {\n  color:black\n}')
             * root.first.first.raws //=> { before: '\n  ', between: ':' }
             */

        }]);

        return Declaration;
    }(_node2.default);

    exports.default = Declaration;
    module.exports = exports['default'];
    return module.exports;
});
System.registerDynamic('npm:postcss@5.2.6/lib/comment.js', ['./warn-once', './node', 'process'], true, function ($__require, exports, module) {
    'use strict';

    var process = $__require('process');
    var define,
        global = this || self,
        GLOBAL = global;
    exports.__esModule = true;

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
        }return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
    }();

    var _warnOnce = $__require('./warn-once');

    var _warnOnce2 = _interopRequireDefault(_warnOnce);

    var _node = $__require('./node');

    var _node2 = _interopRequireDefault(_node);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    /**
     * Represents a comment between declarations or statements (rule and at-rules).
     *
     * Comments inside selectors, at-rule parameters, or declaration values
     * will be stored in the `raws` properties explained above.
     *
     * @extends Node
     */
    var Comment = function (_Node) {
        _inherits(Comment, _Node);

        function Comment(defaults) {
            _classCallCheck(this, Comment);

            var _this = _possibleConstructorReturn(this, _Node.call(this, defaults));

            _this.type = 'comment';
            return _this;
        }

        _createClass(Comment, [{
            key: 'left',
            get: function get() {
                (0, _warnOnce2.default)('Comment#left was deprecated. Use Comment#raws.left');
                return this.raws.left;
            },
            set: function set(val) {
                (0, _warnOnce2.default)('Comment#left was deprecated. Use Comment#raws.left');
                this.raws.left = val;
            }
        }, {
            key: 'right',
            get: function get() {
                (0, _warnOnce2.default)('Comment#right was deprecated. Use Comment#raws.right');
                return this.raws.right;
            },
            set: function set(val) {
                (0, _warnOnce2.default)('Comment#right was deprecated. Use Comment#raws.right');
                this.raws.right = val;
            }

            /**
             * @memberof Comment#
             * @member {string} text - the comment’s text
             */

            /**
             * @memberof Comment#
             * @member {object} raws - Information to generate byte-to-byte equal
             *                         node string as it was in the origin input.
             *
             * Every parser saves its own properties,
             * but the default CSS parser uses:
             *
             * * `before`: the space symbols before the node.
             * * `left`: the space symbols between `/*` and the comment’s text.
             * * `right`: the space symbols between the comment’s text.
             */

        }]);

        return Comment;
    }(_node2.default);

    exports.default = Comment;
    module.exports = exports['default'];
    return module.exports;
});
System.registerDynamic('npm:postcss@5.2.6/lib/stringifier.js', ['process'], true, function ($__require, exports, module) {
    'use strict';

    var process = $__require('process');
    var define,
        global = this || self,
        GLOBAL = global;
    exports.__esModule = true;

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var defaultRaw = {
        colon: ': ',
        indent: '    ',
        beforeDecl: '\n',
        beforeRule: '\n',
        beforeOpen: ' ',
        beforeClose: '\n',
        beforeComment: '\n',
        after: '\n',
        emptyBody: '',
        commentLeft: ' ',
        commentRight: ' '
    };

    function capitalize(str) {
        return str[0].toUpperCase() + str.slice(1);
    }

    var Stringifier = function () {
        function Stringifier(builder) {
            _classCallCheck(this, Stringifier);

            this.builder = builder;
        }

        Stringifier.prototype.stringify = function stringify(node, semicolon) {
            this[node.type](node, semicolon);
        };

        Stringifier.prototype.root = function root(node) {
            this.body(node);
            if (node.raws.after) this.builder(node.raws.after);
        };

        Stringifier.prototype.comment = function comment(node) {
            var left = this.raw(node, 'left', 'commentLeft');
            var right = this.raw(node, 'right', 'commentRight');
            this.builder('/*' + left + node.text + right + '*/', node);
        };

        Stringifier.prototype.decl = function decl(node, semicolon) {
            var between = this.raw(node, 'between', 'colon');
            var string = node.prop + between + this.rawValue(node, 'value');

            if (node.important) {
                string += node.raws.important || ' !important';
            }

            if (semicolon) string += ';';
            this.builder(string, node);
        };

        Stringifier.prototype.rule = function rule(node) {
            this.block(node, this.rawValue(node, 'selector'));
        };

        Stringifier.prototype.atrule = function atrule(node, semicolon) {
            var name = '@' + node.name;
            var params = node.params ? this.rawValue(node, 'params') : '';

            if (typeof node.raws.afterName !== 'undefined') {
                name += node.raws.afterName;
            } else if (params) {
                name += ' ';
            }

            if (node.nodes) {
                this.block(node, name + params);
            } else {
                var end = (node.raws.between || '') + (semicolon ? ';' : '');
                this.builder(name + params + end, node);
            }
        };

        Stringifier.prototype.body = function body(node) {
            var last = node.nodes.length - 1;
            while (last > 0) {
                if (node.nodes[last].type !== 'comment') break;
                last -= 1;
            }

            var semicolon = this.raw(node, 'semicolon');
            for (var i = 0; i < node.nodes.length; i++) {
                var child = node.nodes[i];
                var before = this.raw(child, 'before');
                if (before) this.builder(before);
                this.stringify(child, last !== i || semicolon);
            }
        };

        Stringifier.prototype.block = function block(node, start) {
            var between = this.raw(node, 'between', 'beforeOpen');
            this.builder(start + between + '{', node, 'start');

            var after = void 0;
            if (node.nodes && node.nodes.length) {
                this.body(node);
                after = this.raw(node, 'after');
            } else {
                after = this.raw(node, 'after', 'emptyBody');
            }

            if (after) this.builder(after);
            this.builder('}', node, 'end');
        };

        Stringifier.prototype.raw = function raw(node, own, detect) {
            var value = void 0;
            if (!detect) detect = own;

            // Already had
            if (own) {
                value = node.raws[own];
                if (typeof value !== 'undefined') return value;
            }

            var parent = node.parent;

            // Hack for first rule in CSS
            if (detect === 'before') {
                if (!parent || parent.type === 'root' && parent.first === node) {
                    return '';
                }
            }

            // Floating child without parent
            if (!parent) return defaultRaw[detect];

            // Detect style by other nodes
            var root = node.root();
            if (!root.rawCache) root.rawCache = {};
            if (typeof root.rawCache[detect] !== 'undefined') {
                return root.rawCache[detect];
            }

            if (detect === 'before' || detect === 'after') {
                return this.beforeAfter(node, detect);
            } else {
                var method = 'raw' + capitalize(detect);
                if (this[method]) {
                    value = this[method](root, node);
                } else {
                    root.walk(function (i) {
                        value = i.raws[own];
                        if (typeof value !== 'undefined') return false;
                    });
                }
            }

            if (typeof value === 'undefined') value = defaultRaw[detect];

            root.rawCache[detect] = value;
            return value;
        };

        Stringifier.prototype.rawSemicolon = function rawSemicolon(root) {
            var value = void 0;
            root.walk(function (i) {
                if (i.nodes && i.nodes.length && i.last.type === 'decl') {
                    value = i.raws.semicolon;
                    if (typeof value !== 'undefined') return false;
                }
            });
            return value;
        };

        Stringifier.prototype.rawEmptyBody = function rawEmptyBody(root) {
            var value = void 0;
            root.walk(function (i) {
                if (i.nodes && i.nodes.length === 0) {
                    value = i.raws.after;
                    if (typeof value !== 'undefined') return false;
                }
            });
            return value;
        };

        Stringifier.prototype.rawIndent = function rawIndent(root) {
            if (root.raws.indent) return root.raws.indent;
            var value = void 0;
            root.walk(function (i) {
                var p = i.parent;
                if (p && p !== root && p.parent && p.parent === root) {
                    if (typeof i.raws.before !== 'undefined') {
                        var parts = i.raws.before.split('\n');
                        value = parts[parts.length - 1];
                        value = value.replace(/[^\s]/g, '');
                        return false;
                    }
                }
            });
            return value;
        };

        Stringifier.prototype.rawBeforeComment = function rawBeforeComment(root, node) {
            var value = void 0;
            root.walkComments(function (i) {
                if (typeof i.raws.before !== 'undefined') {
                    value = i.raws.before;
                    if (value.indexOf('\n') !== -1) {
                        value = value.replace(/[^\n]+$/, '');
                    }
                    return false;
                }
            });
            if (typeof value === 'undefined') {
                value = this.raw(node, null, 'beforeDecl');
            }
            return value;
        };

        Stringifier.prototype.rawBeforeDecl = function rawBeforeDecl(root, node) {
            var value = void 0;
            root.walkDecls(function (i) {
                if (typeof i.raws.before !== 'undefined') {
                    value = i.raws.before;
                    if (value.indexOf('\n') !== -1) {
                        value = value.replace(/[^\n]+$/, '');
                    }
                    return false;
                }
            });
            if (typeof value === 'undefined') {
                value = this.raw(node, null, 'beforeRule');
            }
            return value;
        };

        Stringifier.prototype.rawBeforeRule = function rawBeforeRule(root) {
            var value = void 0;
            root.walk(function (i) {
                if (i.nodes && (i.parent !== root || root.first !== i)) {
                    if (typeof i.raws.before !== 'undefined') {
                        value = i.raws.before;
                        if (value.indexOf('\n') !== -1) {
                            value = value.replace(/[^\n]+$/, '');
                        }
                        return false;
                    }
                }
            });
            return value;
        };

        Stringifier.prototype.rawBeforeClose = function rawBeforeClose(root) {
            var value = void 0;
            root.walk(function (i) {
                if (i.nodes && i.nodes.length > 0) {
                    if (typeof i.raws.after !== 'undefined') {
                        value = i.raws.after;
                        if (value.indexOf('\n') !== -1) {
                            value = value.replace(/[^\n]+$/, '');
                        }
                        return false;
                    }
                }
            });
            return value;
        };

        Stringifier.prototype.rawBeforeOpen = function rawBeforeOpen(root) {
            var value = void 0;
            root.walk(function (i) {
                if (i.type !== 'decl') {
                    value = i.raws.between;
                    if (typeof value !== 'undefined') return false;
                }
            });
            return value;
        };

        Stringifier.prototype.rawColon = function rawColon(root) {
            var value = void 0;
            root.walkDecls(function (i) {
                if (typeof i.raws.between !== 'undefined') {
                    value = i.raws.between.replace(/[^\s:]/g, '');
                    return false;
                }
            });
            return value;
        };

        Stringifier.prototype.beforeAfter = function beforeAfter(node, detect) {
            var value = void 0;
            if (node.type === 'decl') {
                value = this.raw(node, null, 'beforeDecl');
            } else if (node.type === 'comment') {
                value = this.raw(node, null, 'beforeComment');
            } else if (detect === 'before') {
                value = this.raw(node, null, 'beforeRule');
            } else {
                value = this.raw(node, null, 'beforeClose');
            }

            var buf = node.parent;
            var depth = 0;
            while (buf && buf.type !== 'root') {
                depth += 1;
                buf = buf.parent;
            }

            if (value.indexOf('\n') !== -1) {
                var indent = this.raw(node, null, 'indent');
                if (indent.length) {
                    for (var step = 0; step < depth; step++) {
                        value += indent;
                    }
                }
            }

            return value;
        };

        Stringifier.prototype.rawValue = function rawValue(node, prop) {
            var value = node[prop];
            var raw = node.raws[prop];
            if (raw && raw.value === value) {
                return raw.raw;
            } else {
                return value;
            }
        };

        return Stringifier;
    }();

    exports.default = Stringifier;
    module.exports = exports['default'];
    return module.exports;
});
System.registerDynamic('npm:postcss@5.2.6/lib/stringify.js', ['./stringifier', 'process'], true, function ($__require, exports, module) {
    'use strict';

    var process = $__require('process');
    var define,
        global = this || self,
        GLOBAL = global;
    exports.__esModule = true;
    exports.default = stringify;

    var _stringifier = $__require('./stringifier');

    var _stringifier2 = _interopRequireDefault(_stringifier);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }

    function stringify(node, builder) {
        var str = new _stringifier2.default(builder);
        str.stringify(node);
    }
    module.exports = exports['default'];
    return module.exports;
});
System.registerDynamic("npm:postcss@5.2.6/lib/node.js", ["./css-syntax-error", "./stringifier", "./stringify", "./warn-once", "process"], true, function ($__require, exports, module) {
    'use strict';

    var process = $__require("process");
    var define,
        global = this || self,
        GLOBAL = global;
    exports.__esModule = true;

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
        }return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
    }();

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
        return typeof obj;
    } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    var _cssSyntaxError = $__require("./css-syntax-error");

    var _cssSyntaxError2 = _interopRequireDefault(_cssSyntaxError);

    var _stringifier = $__require("./stringifier");

    var _stringifier2 = _interopRequireDefault(_stringifier);

    var _stringify = $__require("./stringify");

    var _stringify2 = _interopRequireDefault(_stringify);

    var _warnOnce = $__require("./warn-once");

    var _warnOnce2 = _interopRequireDefault(_warnOnce);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var cloneNode = function cloneNode(obj, parent) {
        var cloned = new obj.constructor();

        for (var i in obj) {
            if (!obj.hasOwnProperty(i)) continue;
            var value = obj[i];
            var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);

            if (i === 'parent' && type === 'object') {
                if (parent) cloned[i] = parent;
            } else if (i === 'source') {
                cloned[i] = value;
            } else if (value instanceof Array) {
                cloned[i] = value.map(function (j) {
                    return cloneNode(j, cloned);
                });
            } else if (i !== 'before' && i !== 'after' && i !== 'between' && i !== 'semicolon') {
                if (type === 'object' && value !== null) value = cloneNode(value);
                cloned[i] = value;
            }
        }

        return cloned;
    };

    /**
     * All node classes inherit the following common methods.
     *
     * @abstract
     */

    var Node = function () {

        /**
         * @param {object} [defaults] - value for node properties
         */
        function Node() {
            var defaults = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            _classCallCheck(this, Node);

            this.raws = {};
            for (var name in defaults) {
                this[name] = defaults[name];
            }
        }

        /**
         * Returns a CssSyntaxError instance containing the original position
         * of the node in the source, showing line and column numbers and also
         * a small excerpt to facilitate debugging.
         *
         * If present, an input source map will be used to get the original position
         * of the source, even from a previous compilation step
         * (e.g., from Sass compilation).
         *
         * This method produces very useful error messages.
         *
         * @param {string} message     - error description
         * @param {object} [opts]      - options
         * @param {string} opts.plugin - plugin name that created this error.
         *                               PostCSS will set it automatically.
         * @param {string} opts.word   - a word inside a node’s string that should
         *                               be highlighted as the source of the error
         * @param {number} opts.index  - an index inside a node’s string that should
         *                               be highlighted as the source of the error
         *
         * @return {CssSyntaxError} error object to throw it
         *
         * @example
         * if ( !variables[name] ) {
         *   throw decl.error('Unknown variable ' + name, { word: name });
         *   // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black
         *   //   color: $black
         *   // a
         *   //          ^
         *   //   background: white
         * }
         */

        Node.prototype.error = function error(message) {
            var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            if (this.source) {
                var pos = this.positionBy(opts);
                return this.source.input.error(message, pos.line, pos.column, opts);
            } else {
                return new _cssSyntaxError2.default(message);
            }
        };

        /**
         * This method is provided as a convenience wrapper for {@link Result#warn}.
         *
         * @param {Result} result      - the {@link Result} instance
         *                               that will receive the warning
         * @param {string} text        - warning message
         * @param {object} [opts]      - options
         * @param {string} opts.plugin - plugin name that created this warning.
         *                               PostCSS will set it automatically.
         * @param {string} opts.word   - a word inside a node’s string that should
         *                               be highlighted as the source of the warning
         * @param {number} opts.index  - an index inside a node’s string that should
         *                               be highlighted as the source of the warning
         *
         * @return {Warning} created warning object
         *
         * @example
         * const plugin = postcss.plugin('postcss-deprecated', () => {
         *   return (root, result) => {
         *     root.walkDecls('bad', decl => {
         *       decl.warn(result, 'Deprecated property bad');
         *     });
         *   };
         * });
         */

        Node.prototype.warn = function warn(result, text, opts) {
            var data = { node: this };
            for (var i in opts) {
                data[i] = opts[i];
            }return result.warn(text, data);
        };

        /**
         * Removes the node from its parent and cleans the parent properties
         * from the node and its children.
         *
         * @example
         * if ( decl.prop.match(/^-webkit-/) ) {
         *   decl.remove();
         * }
         *
         * @return {Node} node to make calls chain
         */

        Node.prototype.remove = function remove() {
            if (this.parent) {
                this.parent.removeChild(this);
            }
            this.parent = undefined;
            return this;
        };

        /**
         * Returns a CSS string representing the node.
         *
         * @param {stringifier|syntax} [stringifier] - a syntax to use
         *                                             in string generation
         *
         * @return {string} CSS string of this node
         *
         * @example
         * postcss.rule({ selector: 'a' }).toString() //=> "a {}"
         */

        Node.prototype.toString = function toString() {
            var stringifier = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _stringify2.default;

            if (stringifier.stringify) stringifier = stringifier.stringify;
            var result = '';
            stringifier(this, function (i) {
                result += i;
            });
            return result;
        };

        /**
         * Returns a clone of the node.
         *
         * The resulting cloned node and its (cloned) children will have
         * a clean parent and code style properties.
         *
         * @param {object} [overrides] - new properties to override in the clone.
         *
         * @example
         * const cloned = decl.clone({ prop: '-moz-' + decl.prop });
         * cloned.raws.before  //=> undefined
         * cloned.parent       //=> undefined
         * cloned.toString()   //=> -moz-transform: scale(0)
         *
         * @return {Node} clone of the node
         */

        Node.prototype.clone = function clone() {
            var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var cloned = cloneNode(this);
            for (var name in overrides) {
                cloned[name] = overrides[name];
            }
            return cloned;
        };

        /**
         * Shortcut to clone the node and insert the resulting cloned node
         * before the current node.
         *
         * @param {object} [overrides] - new properties to override in the clone.
         *
         * @example
         * decl.cloneBefore({ prop: '-moz-' + decl.prop });
         *
         * @return {Node} - new node
         */

        Node.prototype.cloneBefore = function cloneBefore() {
            var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var cloned = this.clone(overrides);
            this.parent.insertBefore(this, cloned);
            return cloned;
        };

        /**
         * Shortcut to clone the node and insert the resulting cloned node
         * after the current node.
         *
         * @param {object} [overrides] - new properties to override in the clone.
         *
         * @return {Node} - new node
         */

        Node.prototype.cloneAfter = function cloneAfter() {
            var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var cloned = this.clone(overrides);
            this.parent.insertAfter(this, cloned);
            return cloned;
        };

        /**
         * Inserts node(s) before the current node and removes the current node.
         *
         * @param {...Node} nodes - node(s) to replace current one
         *
         * @example
         * if ( atrule.name == 'mixin' ) {
         *   atrule.replaceWith(mixinRules[atrule.params]);
         * }
         *
         * @return {Node} current node to methods chain
         */

        Node.prototype.replaceWith = function replaceWith() {
            if (this.parent) {
                for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {
                    nodes[_key] = arguments[_key];
                }

                for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                    var _ref;

                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        _i = _iterator.next();
                        if (_i.done) break;
                        _ref = _i.value;
                    }

                    var node = _ref;

                    this.parent.insertBefore(this, node);
                }

                this.remove();
            }

            return this;
        };

        /**
         * Removes the node from its current parent and inserts it
         * at the end of `newParent`.
         *
         * This will clean the `before` and `after` code {@link Node#raws} data
         * from the node and replace them with the indentation style of `newParent`.
         * It will also clean the `between` property
         * if `newParent` is in another {@link Root}.
         *
         * @param {Container} newParent - container node where the current node
         *                                will be moved
         *
         * @example
         * atrule.moveTo(atrule.root());
         *
         * @return {Node} current node to methods chain
         */

        Node.prototype.moveTo = function moveTo(newParent) {
            this.cleanRaws(this.root() === newParent.root());
            this.remove();
            newParent.append(this);
            return this;
        };

        /**
         * Removes the node from its current parent and inserts it into
         * a new parent before `otherNode`.
         *
         * This will also clean the node’s code style properties just as it would
         * in {@link Node#moveTo}.
         *
         * @param {Node} otherNode - node that will be before current node
         *
         * @return {Node} current node to methods chain
         */

        Node.prototype.moveBefore = function moveBefore(otherNode) {
            this.cleanRaws(this.root() === otherNode.root());
            this.remove();
            otherNode.parent.insertBefore(otherNode, this);
            return this;
        };

        /**
         * Removes the node from its current parent and inserts it into
         * a new parent after `otherNode`.
         *
         * This will also clean the node’s code style properties just as it would
         * in {@link Node#moveTo}.
         *
         * @param {Node} otherNode - node that will be after current node
         *
         * @return {Node} current node to methods chain
         */

        Node.prototype.moveAfter = function moveAfter(otherNode) {
            this.cleanRaws(this.root() === otherNode.root());
            this.remove();
            otherNode.parent.insertAfter(otherNode, this);
            return this;
        };

        /**
         * Returns the next child of the node’s parent.
         * Returns `undefined` if the current node is the last child.
         *
         * @return {Node|undefined} next node
         *
         * @example
         * if ( comment.text === 'delete next' ) {
         *   const next = comment.next();
         *   if ( next ) {
         *     next.remove();
         *   }
         * }
         */

        Node.prototype.next = function next() {
            var index = this.parent.index(this);
            return this.parent.nodes[index + 1];
        };

        /**
         * Returns the previous child of the node’s parent.
         * Returns `undefined` if the current node is the first child.
         *
         * @return {Node|undefined} previous node
         *
         * @example
         * const annotation = decl.prev();
         * if ( annotation.type == 'comment' ) {
         *  readAnnotation(annotation.text);
         * }
         */

        Node.prototype.prev = function prev() {
            var index = this.parent.index(this);
            return this.parent.nodes[index - 1];
        };

        Node.prototype.toJSON = function toJSON() {
            var fixed = {};

            for (var name in this) {
                if (!this.hasOwnProperty(name)) continue;
                if (name === 'parent') continue;
                var value = this[name];

                if (value instanceof Array) {
                    fixed[name] = value.map(function (i) {
                        if ((typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object' && i.toJSON) {
                            return i.toJSON();
                        } else {
                            return i;
                        }
                    });
                } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.toJSON) {
                    fixed[name] = value.toJSON();
                } else {
                    fixed[name] = value;
                }
            }

            return fixed;
        };

        /**
         * Returns a {@link Node#raws} value. If the node is missing
         * the code style property (because the node was manually built or cloned),
         * PostCSS will try to autodetect the code style property by looking
         * at other nodes in the tree.
         *
         * @param {string} prop          - name of code style property
         * @param {string} [defaultType] - name of default value, it can be missed
         *                                 if the value is the same as prop
         *
         * @example
         * const root = postcss.parse('a { background: white }');
         * root.nodes[0].append({ prop: 'color', value: 'black' });
         * root.nodes[0].nodes[1].raws.before   //=> undefined
         * root.nodes[0].nodes[1].raw('before') //=> ' '
         *
         * @return {string} code style value
         */

        Node.prototype.raw = function raw(prop, defaultType) {
            var str = new _stringifier2.default();
            return str.raw(this, prop, defaultType);
        };

        /**
         * Finds the Root instance of the node’s tree.
         *
         * @example
         * root.nodes[0].nodes[0].root() === root
         *
         * @return {Root} root parent
         */

        Node.prototype.root = function root() {
            var result = this;
            while (result.parent) {
                result = result.parent;
            }return result;
        };

        Node.prototype.cleanRaws = function cleanRaws(keepBetween) {
            delete this.raws.before;
            delete this.raws.after;
            if (!keepBetween) delete this.raws.between;
        };

        Node.prototype.positionInside = function positionInside(index) {
            var string = this.toString();
            var column = this.source.start.column;
            var line = this.source.start.line;

            for (var i = 0; i < index; i++) {
                if (string[i] === '\n') {
                    column = 1;
                    line += 1;
                } else {
                    column += 1;
                }
            }

            return { line: line, column: column };
        };

        Node.prototype.positionBy = function positionBy(opts) {
            var pos = this.source.start;
            if (opts.index) {
                pos = this.positionInside(opts.index);
            } else if (opts.word) {
                var index = this.toString().indexOf(opts.word);
                if (index !== -1) pos = this.positionInside(index);
            }
            return pos;
        };

        Node.prototype.removeSelf = function removeSelf() {
            (0, _warnOnce2.default)('Node#removeSelf is deprecated. Use Node#remove.');
            return this.remove();
        };

        Node.prototype.replace = function replace(nodes) {
            (0, _warnOnce2.default)('Node#replace is deprecated. Use Node#replaceWith');
            return this.replaceWith(nodes);
        };

        Node.prototype.style = function style(own, detect) {
            (0, _warnOnce2.default)('Node#style() is deprecated. Use Node#raw()');
            return this.raw(own, detect);
        };

        Node.prototype.cleanStyles = function cleanStyles(keepBetween) {
            (0, _warnOnce2.default)('Node#cleanStyles() is deprecated. Use Node#cleanRaws()');
            return this.cleanRaws(keepBetween);
        };

        _createClass(Node, [{
            key: 'before',
            get: function get() {
                (0, _warnOnce2.default)('Node#before is deprecated. Use Node#raws.before');
                return this.raws.before;
            },
            set: function set(val) {
                (0, _warnOnce2.default)('Node#before is deprecated. Use Node#raws.before');
                this.raws.before = val;
            }
        }, {
            key: 'between',
            get: function get() {
                (0, _warnOnce2.default)('Node#between is deprecated. Use Node#raws.between');
                return this.raws.between;
            },
            set: function set(val) {
                (0, _warnOnce2.default)('Node#between is deprecated. Use Node#raws.between');
                this.raws.between = val;
            }

            /**
             * @memberof Node#
             * @member {string} type - String representing the node’s type.
             *                         Possible values are `root`, `atrule`, `rule`,
             *                         `decl`, or `comment`.
             *
             * @example
             * postcss.decl({ prop: 'color', value: 'black' }).type //=> 'decl'
             */

            /**
             * @memberof Node#
             * @member {Container} parent - the node’s parent node.
             *
             * @example
             * root.nodes[0].parent == root;
             */

            /**
             * @memberof Node#
             * @member {source} source - the input source of the node
             *
             * The property is used in source map generation.
             *
             * If you create a node manually (e.g., with `postcss.decl()`),
             * that node will not have a `source` property and will be absent
             * from the source map. For this reason, the plugin developer should
             * consider cloning nodes to create new ones (in which case the new node’s
             * source will reference the original, cloned node) or setting
             * the `source` property manually.
             *
             * ```js
             * // Bad
             * const prefixed = postcss.decl({
             *   prop: '-moz-' + decl.prop,
             *   value: decl.value
             * });
             *
             * // Good
             * const prefixed = decl.clone({ prop: '-moz-' + decl.prop });
             * ```
             *
             * ```js
             * if ( atrule.name == 'add-link' ) {
             *   const rule = postcss.rule({ selector: 'a', source: atrule.source });
             *   atrule.parent.insertBefore(atrule, rule);
             * }
             * ```
             *
             * @example
             * decl.source.input.from //=> '/home/ai/a.sass'
             * decl.source.start      //=> { line: 10, column: 2 }
             * decl.source.end        //=> { line: 10, column: 12 }
             */

            /**
             * @memberof Node#
             * @member {object} raws - Information to generate byte-to-byte equal
             *                         node string as it was in the origin input.
             *
             * Every parser saves its own properties,
             * but the default CSS parser uses:
             *
             * * `before`: the space symbols before the node. It also stores `*`
             *   and `_` symbols before the declaration (IE hack).
             * * `after`: the space symbols after the last child of the node
             *   to the end of the node.
             * * `between`: the symbols between the property and value
             *   for declarations, selector and `{` for rules, or last parameter
             *   and `{` for at-rules.
             * * `semicolon`: contains true if the last child has
             *   an (optional) semicolon.
             * * `afterName`: the space between the at-rule name and its parameters.
             * * `left`: the space symbols between `/*` and the comment’s text.
             * * `right`: the space symbols between the comment’s text
             *   and <code>*&#47;</code>.
             * * `important`: the content of the important statement,
             *   if it is not just `!important`.
             *
             * PostCSS cleans selectors, declaration values and at-rule parameters
             * from comments and extra spaces, but it stores origin content in raws
             * properties. As such, if you don’t change a declaration’s value,
             * PostCSS will use the raw value with comments.
             *
             * @example
             * const root = postcss.parse('a {\n  color:black\n}')
             * root.first.first.raws //=> { before: '\n  ', between: ':' }
             */

        }]);

        return Node;
    }();

    exports.default = Node;

    /**
     * @typedef {object} position
     * @property {number} line   - source line in file
     * @property {number} column - source column in file
     */

    /**
     * @typedef {object} source
     * @property {Input} input    - {@link Input} with input file
     * @property {position} start - The starting position of the node’s source
     * @property {position} end   - The ending position of the node’s source
     */

    module.exports = exports['default'];
    return module.exports;
});
System.registerDynamic('npm:postcss@5.2.6/lib/at-rule.js', ['./container', './warn-once', 'process'], true, function ($__require, exports, module) {
    'use strict';

    var process = $__require('process');
    var define,
        global = this || self,
        GLOBAL = global;
    exports.__esModule = true;

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
        }return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
    }();

    var _container = $__require('./container');

    var _container2 = _interopRequireDefault(_container);

    var _warnOnce = $__require('./warn-once');

    var _warnOnce2 = _interopRequireDefault(_warnOnce);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    /**
     * Represents an at-rule.
     *
     * If it’s followed in the CSS by a {} block, this node will have
     * a nodes property representing its children.
     *
     * @extends Container
     *
     * @example
     * const root = postcss.parse('@charset "UTF-8"; @media print {}');
     *
     * const charset = root.first;
     * charset.type  //=> 'atrule'
     * charset.nodes //=> undefined
     *
     * const media = root.last;
     * media.nodes   //=> []
     */
    var AtRule = function (_Container) {
        _inherits(AtRule, _Container);

        function AtRule(defaults) {
            _classCallCheck(this, AtRule);

            var _this = _possibleConstructorReturn(this, _Container.call(this, defaults));

            _this.type = 'atrule';
            return _this;
        }

        AtRule.prototype.append = function append() {
            var _Container$prototype$;

            if (!this.nodes) this.nodes = [];

            for (var _len = arguments.length, children = Array(_len), _key = 0; _key < _len; _key++) {
                children[_key] = arguments[_key];
            }

            return (_Container$prototype$ = _Container.prototype.append).call.apply(_Container$prototype$, [this].concat(children));
        };

        AtRule.prototype.prepend = function prepend() {
            var _Container$prototype$2;

            if (!this.nodes) this.nodes = [];

            for (var _len2 = arguments.length, children = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                children[_key2] = arguments[_key2];
            }

            return (_Container$prototype$2 = _Container.prototype.prepend).call.apply(_Container$prototype$2, [this].concat(children));
        };

        _createClass(AtRule, [{
            key: 'afterName',
            get: function get() {
                (0, _warnOnce2.default)('AtRule#afterName was deprecated. Use AtRule#raws.afterName');
                return this.raws.afterName;
            },
            set: function set(val) {
                (0, _warnOnce2.default)('AtRule#afterName was deprecated. Use AtRule#raws.afterName');
                this.raws.afterName = val;
            }
        }, {
            key: '_params',
            get: function get() {
                (0, _warnOnce2.default)('AtRule#_params was deprecated. Use AtRule#raws.params');
                return this.raws.params;
            },
            set: function set(val) {
                (0, _warnOnce2.default)('AtRule#_params was deprecated. Use AtRule#raws.params');
                this.raws.params = val;
            }

            /**
             * @memberof AtRule#
             * @member {string} name - the at-rule’s name immediately follows the `@`
             *
             * @example
             * const root  = postcss.parse('@media print {}');
             * media.name //=> 'media'
             * const media = root.first;
             */

            /**
             * @memberof AtRule#
             * @member {string} params - the at-rule’s parameters, the values
             *                           that follow the at-rule’s name but precede
             *                           any {} block
             *
             * @example
             * const root  = postcss.parse('@media print, screen {}');
             * const media = root.first;
             * media.params //=> 'print, screen'
             */

            /**
             * @memberof AtRule#
             * @member {object} raws - Information to generate byte-to-byte equal
             *                         node string as it was in the origin input.
             *
             * Every parser saves its own properties,
             * but the default CSS parser uses:
             *
             * * `before`: the space symbols before the node. It also stores `*`
             *   and `_` symbols before the declaration (IE hack).
             * * `after`: the space symbols after the last child of the node
             *   to the end of the node.
             * * `between`: the symbols between the property and value
             *   for declarations, selector and `{` for rules, or last parameter
             *   and `{` for at-rules.
             * * `semicolon`: contains true if the last child has
             *   an (optional) semicolon.
             * * `afterName`: the space between the at-rule name and its parameters.
             *
             * PostCSS cleans at-rule parameters from comments and extra spaces,
             * but it stores origin content in raws properties.
             * As such, if you don’t change a declaration’s value,
             * PostCSS will use the raw value with comments.
             *
             * @example
             * const root = postcss.parse('  @media\nprint {\n}')
             * root.first.first.raws //=> { before: '  ',
             *                       //     between: ' ',
             *                       //     afterName: '\n',
             *                       //     after: '\n' }
             */

        }]);

        return AtRule;
    }(_container2.default);

    exports.default = AtRule;
    module.exports = exports['default'];
    return module.exports;
});
System.registerDynamic('npm:postcss@5.2.6/lib/container.js', ['./declaration', './warn-once', './comment', './node', './parse', './rule', './at-rule', './root', 'process'], true, function ($__require, exports, module) {
    'use strict';

    var process = $__require('process');
    var define,
        global = this || self,
        GLOBAL = global;
    exports.__esModule = true;

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
        }return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
    }();

    var _declaration = $__require('./declaration');

    var _declaration2 = _interopRequireDefault(_declaration);

    var _warnOnce = $__require('./warn-once');

    var _warnOnce2 = _interopRequireDefault(_warnOnce);

    var _comment = $__require('./comment');

    var _comment2 = _interopRequireDefault(_comment);

    var _node = $__require('./node');

    var _node2 = _interopRequireDefault(_node);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    function cleanSource(nodes) {
        return nodes.map(function (i) {
            if (i.nodes) i.nodes = cleanSource(i.nodes);
            delete i.source;
            return i;
        });
    }

    /**
     * The {@link Root}, {@link AtRule}, and {@link Rule} container nodes
     * inherit some common methods to help work with their children.
     *
     * Note that all containers can store any content. If you write a rule inside
     * a rule, PostCSS will parse it.
     *
     * @extends Node
     * @abstract
     */

    var Container = function (_Node) {
        _inherits(Container, _Node);

        function Container() {
            _classCallCheck(this, Container);

            return _possibleConstructorReturn(this, _Node.apply(this, arguments));
        }

        Container.prototype.push = function push(child) {
            child.parent = this;
            this.nodes.push(child);
            return this;
        };

        /**
         * Iterates through the container’s immediate children,
         * calling `callback` for each child.
         *
         * Returning `false` in the callback will break iteration.
         *
         * This method only iterates through the container’s immediate children.
         * If you need to recursively iterate through all the container’s descendant
         * nodes, use {@link Container#walk}.
         *
         * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe
         * if you are mutating the array of child nodes during iteration.
         * PostCSS will adjust the current index to match the mutations.
         *
         * @param {childIterator} callback - iterator receives each node and index
         *
         * @return {false|undefined} returns `false` if iteration was broke
         *
         * @example
         * const root = postcss.parse('a { color: black; z-index: 1 }');
         * const rule = root.first;
         *
         * for ( let decl of rule.nodes ) {
         *     decl.cloneBefore({ prop: '-webkit-' + decl.prop });
         *     // Cycle will be infinite, because cloneBefore moves the current node
         *     // to the next index
         * }
         *
         * rule.each(decl => {
         *     decl.cloneBefore({ prop: '-webkit-' + decl.prop });
         *     // Will be executed only for color and z-index
         * });
         */

        Container.prototype.each = function each(callback) {
            if (!this.lastEach) this.lastEach = 0;
            if (!this.indexes) this.indexes = {};

            this.lastEach += 1;
            var id = this.lastEach;
            this.indexes[id] = 0;

            if (!this.nodes) return undefined;

            var index = void 0,
                result = void 0;
            while (this.indexes[id] < this.nodes.length) {
                index = this.indexes[id];
                result = callback(this.nodes[index], index);
                if (result === false) break;

                this.indexes[id] += 1;
            }

            delete this.indexes[id];

            return result;
        };

        /**
         * Traverses the container’s descendant nodes, calling callback
         * for each node.
         *
         * Like container.each(), this method is safe to use
         * if you are mutating arrays during iteration.
         *
         * If you only need to iterate through the container’s immediate children,
         * use {@link Container#each}.
         *
         * @param {childIterator} callback - iterator receives each node and index
         *
         * @return {false|undefined} returns `false` if iteration was broke
         *
         * @example
         * root.walk(node => {
         *   // Traverses all descendant nodes.
         * });
         */

        Container.prototype.walk = function walk(callback) {
            return this.each(function (child, i) {
                var result = callback(child, i);
                if (result !== false && child.walk) {
                    result = child.walk(callback);
                }
                return result;
            });
        };

        /**
         * Traverses the container’s descendant nodes, calling callback
         * for each declaration node.
         *
         * If you pass a filter, iteration will only happen over declarations
         * with matching properties.
         *
         * Like {@link Container#each}, this method is safe
         * to use if you are mutating arrays during iteration.
         *
         * @param {string|RegExp} [prop]   - string or regular expression
         *                                   to filter declarations by property name
         * @param {childIterator} callback - iterator receives each node and index
         *
         * @return {false|undefined} returns `false` if iteration was broke
         *
         * @example
         * root.walkDecls(decl => {
         *   checkPropertySupport(decl.prop);
         * });
         *
         * root.walkDecls('border-radius', decl => {
         *   decl.remove();
         * });
         *
         * root.walkDecls(/^background/, decl => {
         *   decl.value = takeFirstColorFromGradient(decl.value);
         * });
         */

        Container.prototype.walkDecls = function walkDecls(prop, callback) {
            if (!callback) {
                callback = prop;
                return this.walk(function (child, i) {
                    if (child.type === 'decl') {
                        return callback(child, i);
                    }
                });
            } else if (prop instanceof RegExp) {
                return this.walk(function (child, i) {
                    if (child.type === 'decl' && prop.test(child.prop)) {
                        return callback(child, i);
                    }
                });
            } else {
                return this.walk(function (child, i) {
                    if (child.type === 'decl' && child.prop === prop) {
                        return callback(child, i);
                    }
                });
            }
        };

        /**
         * Traverses the container’s descendant nodes, calling callback
         * for each rule node.
         *
         * If you pass a filter, iteration will only happen over rules
         * with matching selectors.
         *
         * Like {@link Container#each}, this method is safe
         * to use if you are mutating arrays during iteration.
         *
         * @param {string|RegExp} [selector] - string or regular expression
         *                                     to filter rules by selector
         * @param {childIterator} callback   - iterator receives each node and index
         *
         * @return {false|undefined} returns `false` if iteration was broke
         *
         * @example
         * const selectors = [];
         * root.walkRules(rule => {
         *   selectors.push(rule.selector);
         * });
         * console.log(`Your CSS uses ${selectors.length} selectors`);
         */

        Container.prototype.walkRules = function walkRules(selector, callback) {
            if (!callback) {
                callback = selector;

                return this.walk(function (child, i) {
                    if (child.type === 'rule') {
                        return callback(child, i);
                    }
                });
            } else if (selector instanceof RegExp) {
                return this.walk(function (child, i) {
                    if (child.type === 'rule' && selector.test(child.selector)) {
                        return callback(child, i);
                    }
                });
            } else {
                return this.walk(function (child, i) {
                    if (child.type === 'rule' && child.selector === selector) {
                        return callback(child, i);
                    }
                });
            }
        };

        /**
         * Traverses the container’s descendant nodes, calling callback
         * for each at-rule node.
         *
         * If you pass a filter, iteration will only happen over at-rules
         * that have matching names.
         *
         * Like {@link Container#each}, this method is safe
         * to use if you are mutating arrays during iteration.
         *
         * @param {string|RegExp} [name]   - string or regular expression
         *                                   to filter at-rules by name
         * @param {childIterator} callback - iterator receives each node and index
         *
         * @return {false|undefined} returns `false` if iteration was broke
         *
         * @example
         * root.walkAtRules(rule => {
         *   if ( isOld(rule.name) ) rule.remove();
         * });
         *
         * let first = false;
         * root.walkAtRules('charset', rule => {
         *   if ( !first ) {
         *     first = true;
         *   } else {
         *     rule.remove();
         *   }
         * });
         */

        Container.prototype.walkAtRules = function walkAtRules(name, callback) {
            if (!callback) {
                callback = name;
                return this.walk(function (child, i) {
                    if (child.type === 'atrule') {
                        return callback(child, i);
                    }
                });
            } else if (name instanceof RegExp) {
                return this.walk(function (child, i) {
                    if (child.type === 'atrule' && name.test(child.name)) {
                        return callback(child, i);
                    }
                });
            } else {
                return this.walk(function (child, i) {
                    if (child.type === 'atrule' && child.name === name) {
                        return callback(child, i);
                    }
                });
            }
        };

        /**
         * Traverses the container’s descendant nodes, calling callback
         * for each comment node.
         *
         * Like {@link Container#each}, this method is safe
         * to use if you are mutating arrays during iteration.
         *
         * @param {childIterator} callback - iterator receives each node and index
         *
         * @return {false|undefined} returns `false` if iteration was broke
         *
         * @example
         * root.walkComments(comment => {
         *   comment.remove();
         * });
         */

        Container.prototype.walkComments = function walkComments(callback) {
            return this.walk(function (child, i) {
                if (child.type === 'comment') {
                    return callback(child, i);
                }
            });
        };

        /**
         * Inserts new nodes to the start of the container.
         *
         * @param {...(Node|object|string|Node[])} children - new nodes
         *
         * @return {Node} this node for methods chain
         *
         * @example
         * const decl1 = postcss.decl({ prop: 'color', value: 'black' });
         * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' });
         * rule.append(decl1, decl2);
         *
         * root.append({ name: 'charset', params: '"UTF-8"' });  // at-rule
         * root.append({ selector: 'a' });                       // rule
         * rule.append({ prop: 'color', value: 'black' });       // declaration
         * rule.append({ text: 'Comment' })                      // comment
         *
         * root.append('a {}');
         * root.first.append('color: black; z-index: 1');
         */

        Container.prototype.append = function append() {
            for (var _len = arguments.length, children = Array(_len), _key = 0; _key < _len; _key++) {
                children[_key] = arguments[_key];
            }

            for (var _iterator = children, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var child = _ref;

                var nodes = this.normalize(child, this.last);
                for (var _iterator2 = nodes, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
                    var _ref2;

                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        _i2 = _iterator2.next();
                        if (_i2.done) break;
                        _ref2 = _i2.value;
                    }

                    var node = _ref2;
                    this.nodes.push(node);
                }
            }
            return this;
        };

        /**
         * Inserts new nodes to the end of the container.
         *
         * @param {...(Node|object|string|Node[])} children - new nodes
         *
         * @return {Node} this node for methods chain
         *
         * @example
         * const decl1 = postcss.decl({ prop: 'color', value: 'black' });
         * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' });
         * rule.prepend(decl1, decl2);
         *
         * root.append({ name: 'charset', params: '"UTF-8"' });  // at-rule
         * root.append({ selector: 'a' });                       // rule
         * rule.append({ prop: 'color', value: 'black' });       // declaration
         * rule.append({ text: 'Comment' })                      // comment
         *
         * root.append('a {}');
         * root.first.append('color: black; z-index: 1');
         */

        Container.prototype.prepend = function prepend() {
            for (var _len2 = arguments.length, children = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                children[_key2] = arguments[_key2];
            }

            children = children.reverse();
            for (var _iterator3 = children, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
                var _ref3;

                if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    _i3 = _iterator3.next();
                    if (_i3.done) break;
                    _ref3 = _i3.value;
                }

                var child = _ref3;

                var nodes = this.normalize(child, this.first, 'prepend').reverse();
                for (var _iterator4 = nodes, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
                    var _ref4;

                    if (_isArray4) {
                        if (_i4 >= _iterator4.length) break;
                        _ref4 = _iterator4[_i4++];
                    } else {
                        _i4 = _iterator4.next();
                        if (_i4.done) break;
                        _ref4 = _i4.value;
                    }

                    var node = _ref4;
                    this.nodes.unshift(node);
                }for (var id in this.indexes) {
                    this.indexes[id] = this.indexes[id] + nodes.length;
                }
            }
            return this;
        };

        Container.prototype.cleanRaws = function cleanRaws(keepBetween) {
            _Node.prototype.cleanRaws.call(this, keepBetween);
            if (this.nodes) {
                for (var _iterator5 = this.nodes, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
                    var _ref5;

                    if (_isArray5) {
                        if (_i5 >= _iterator5.length) break;
                        _ref5 = _iterator5[_i5++];
                    } else {
                        _i5 = _iterator5.next();
                        if (_i5.done) break;
                        _ref5 = _i5.value;
                    }

                    var node = _ref5;
                    node.cleanRaws(keepBetween);
                }
            }
        };

        /**
         * Insert new node before old node within the container.
         *
         * @param {Node|number} exist             - child or child’s index.
         * @param {Node|object|string|Node[]} add - new node
         *
         * @return {Node} this node for methods chain
         *
         * @example
         * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }));
         */

        Container.prototype.insertBefore = function insertBefore(exist, add) {
            exist = this.index(exist);

            var type = exist === 0 ? 'prepend' : false;
            var nodes = this.normalize(add, this.nodes[exist], type).reverse();
            for (var _iterator6 = nodes, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
                var _ref6;

                if (_isArray6) {
                    if (_i6 >= _iterator6.length) break;
                    _ref6 = _iterator6[_i6++];
                } else {
                    _i6 = _iterator6.next();
                    if (_i6.done) break;
                    _ref6 = _i6.value;
                }

                var node = _ref6;
                this.nodes.splice(exist, 0, node);
            }var index = void 0;
            for (var id in this.indexes) {
                index = this.indexes[id];
                if (exist <= index) {
                    this.indexes[id] = index + nodes.length;
                }
            }

            return this;
        };

        /**
         * Insert new node after old node within the container.
         *
         * @param {Node|number} exist             - child or child’s index
         * @param {Node|object|string|Node[]} add - new node
         *
         * @return {Node} this node for methods chain
         */

        Container.prototype.insertAfter = function insertAfter(exist, add) {
            exist = this.index(exist);

            var nodes = this.normalize(add, this.nodes[exist]).reverse();
            for (var _iterator7 = nodes, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {
                var _ref7;

                if (_isArray7) {
                    if (_i7 >= _iterator7.length) break;
                    _ref7 = _iterator7[_i7++];
                } else {
                    _i7 = _iterator7.next();
                    if (_i7.done) break;
                    _ref7 = _i7.value;
                }

                var node = _ref7;
                this.nodes.splice(exist + 1, 0, node);
            }var index = void 0;
            for (var id in this.indexes) {
                index = this.indexes[id];
                if (exist < index) {
                    this.indexes[id] = index + nodes.length;
                }
            }

            return this;
        };

        Container.prototype.remove = function remove(child) {
            if (typeof child !== 'undefined') {
                (0, _warnOnce2.default)('Container#remove is deprecated. ' + 'Use Container#removeChild');
                this.removeChild(child);
            } else {
                _Node.prototype.remove.call(this);
            }
            return this;
        };

        /**
         * Removes node from the container and cleans the parent properties
         * from the node and its children.
         *
         * @param {Node|number} child - child or child’s index
         *
         * @return {Node} this node for methods chain
         *
         * @example
         * rule.nodes.length  //=> 5
         * rule.removeChild(decl);
         * rule.nodes.length  //=> 4
         * decl.parent        //=> undefined
         */

        Container.prototype.removeChild = function removeChild(child) {
            child = this.index(child);
            this.nodes[child].parent = undefined;
            this.nodes.splice(child, 1);

            var index = void 0;
            for (var id in this.indexes) {
                index = this.indexes[id];
                if (index >= child) {
                    this.indexes[id] = index - 1;
                }
            }

            return this;
        };

        /**
         * Removes all children from the container
         * and cleans their parent properties.
         *
         * @return {Node} this node for methods chain
         *
         * @example
         * rule.removeAll();
         * rule.nodes.length //=> 0
         */

        Container.prototype.removeAll = function removeAll() {
            for (var _iterator8 = this.nodes, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {
                var _ref8;

                if (_isArray8) {
                    if (_i8 >= _iterator8.length) break;
                    _ref8 = _iterator8[_i8++];
                } else {
                    _i8 = _iterator8.next();
                    if (_i8.done) break;
                    _ref8 = _i8.value;
                }

                var node = _ref8;
                node.parent = undefined;
            }this.nodes = [];
            return this;
        };

        /**
         * Passes all declaration values within the container that match pattern
         * through callback, replacing those values with the returned result
         * of callback.
         *
         * This method is useful if you are using a custom unit or function
         * and need to iterate through all values.
         *
         * @param {string|RegExp} pattern      - replace pattern
         * @param {object} opts                - options to speed up the search
         * @param {string|string[]} opts.props - an array of property names
         * @param {string} opts.fast           - string that’s used
         *                                       to narrow down values and speed up
                                                 the regexp search
         * @param {function|string} callback   - string to replace pattern
         *                                       or callback that returns a new
         *                                       value.
         *                                       The callback will receive
         *                                       the same arguments as those
         *                                       passed to a function parameter
         *                                       of `String#replace`.
         *
         * @return {Node} this node for methods chain
         *
         * @example
         * root.replaceValues(/\d+rem/, { fast: 'rem' }, string => {
         *   return 15 * parseInt(string) + 'px';
         * });
         */

        Container.prototype.replaceValues = function replaceValues(pattern, opts, callback) {
            if (!callback) {
                callback = opts;
                opts = {};
            }

            this.walkDecls(function (decl) {
                if (opts.props && opts.props.indexOf(decl.prop) === -1) return;
                if (opts.fast && decl.value.indexOf(opts.fast) === -1) return;

                decl.value = decl.value.replace(pattern, callback);
            });

            return this;
        };

        /**
         * Returns `true` if callback returns `true`
         * for all of the container’s children.
         *
         * @param {childCondition} condition - iterator returns true or false.
         *
         * @return {boolean} is every child pass condition
         *
         * @example
         * const noPrefixes = rule.every(i => i.prop[0] !== '-');
         */

        Container.prototype.every = function every(condition) {
            return this.nodes.every(condition);
        };

        /**
         * Returns `true` if callback returns `true` for (at least) one
         * of the container’s children.
         *
         * @param {childCondition} condition - iterator returns true or false.
         *
         * @return {boolean} is some child pass condition
         *
         * @example
         * const hasPrefix = rule.some(i => i.prop[0] === '-');
         */

        Container.prototype.some = function some(condition) {
            return this.nodes.some(condition);
        };

        /**
         * Returns a `child`’s index within the {@link Container#nodes} array.
         *
         * @param {Node} child - child of the current container.
         *
         * @return {number} child index
         *
         * @example
         * rule.index( rule.nodes[2] ) //=> 2
         */

        Container.prototype.index = function index(child) {
            if (typeof child === 'number') {
                return child;
            } else {
                return this.nodes.indexOf(child);
            }
        };

        /**
         * The container’s first child.
         *
         * @type {Node}
         *
         * @example
         * rule.first == rules.nodes[0];
         */

        Container.prototype.normalize = function normalize(nodes, sample) {
            var _this2 = this;

            if (typeof nodes === 'string') {
                var parse = $__require('./parse');
                nodes = cleanSource(parse(nodes).nodes);
            } else if (!Array.isArray(nodes)) {
                if (nodes.type === 'root') {
                    nodes = nodes.nodes;
                } else if (nodes.type) {
                    nodes = [nodes];
                } else if (nodes.prop) {
                    if (typeof nodes.value === 'undefined') {
                        throw new Error('Value field is missed in node creation');
                    } else if (typeof nodes.value !== 'string') {
                        nodes.value = String(nodes.value);
                    }
                    nodes = [new _declaration2.default(nodes)];
                } else if (nodes.selector) {
                    var Rule = $__require('./rule');
                    nodes = [new Rule(nodes)];
                } else if (nodes.name) {
                    var AtRule = $__require('./at-rule');
                    nodes = [new AtRule(nodes)];
                } else if (nodes.text) {
                    nodes = [new _comment2.default(nodes)];
                } else {
                    throw new Error('Unknown node type in node creation');
                }
            }

            var processed = nodes.map(function (i) {
                if (typeof i.raws === 'undefined') i = _this2.rebuild(i);

                if (i.parent) i = i.clone();
                if (typeof i.raws.before === 'undefined') {
                    if (sample && typeof sample.raws.before !== 'undefined') {
                        i.raws.before = sample.raws.before.replace(/[^\s]/g, '');
                    }
                }
                i.parent = _this2;
                return i;
            });

            return processed;
        };

        Container.prototype.rebuild = function rebuild(node, parent) {
            var _this3 = this;

            var fix = void 0;
            if (node.type === 'root') {
                var Root = $__require('./root');
                fix = new Root();
            } else if (node.type === 'atrule') {
                var AtRule = $__require('./at-rule');
                fix = new AtRule();
            } else if (node.type === 'rule') {
                var Rule = $__require('./rule');
                fix = new Rule();
            } else if (node.type === 'decl') {
                fix = new _declaration2.default();
            } else if (node.type === 'comment') {
                fix = new _comment2.default();
            }

            for (var i in node) {
                if (i === 'nodes') {
                    fix.nodes = node.nodes.map(function (j) {
                        return _this3.rebuild(j, fix);
                    });
                } else if (i === 'parent' && parent) {
                    fix.parent = parent;
                } else if (node.hasOwnProperty(i)) {
                    fix[i] = node[i];
                }
            }

            return fix;
        };

        Container.prototype.eachInside = function eachInside(callback) {
            (0, _warnOnce2.default)('Container#eachInside is deprecated. ' + 'Use Container#walk instead.');
            return this.walk(callback);
        };

        Container.prototype.eachDecl = function eachDecl(prop, callback) {
            (0, _warnOnce2.default)('Container#eachDecl is deprecated. ' + 'Use Container#walkDecls instead.');
            return this.walkDecls(prop, callback);
        };

        Container.prototype.eachRule = function eachRule(selector, callback) {
            (0, _warnOnce2.default)('Container#eachRule is deprecated. ' + 'Use Container#walkRules instead.');
            return this.walkRules(selector, callback);
        };

        Container.prototype.eachAtRule = function eachAtRule(name, callback) {
            (0, _warnOnce2.default)('Container#eachAtRule is deprecated. ' + 'Use Container#walkAtRules instead.');
            return this.walkAtRules(name, callback);
        };

        Container.prototype.eachComment = function eachComment(callback) {
            (0, _warnOnce2.default)('Container#eachComment is deprecated. ' + 'Use Container#walkComments instead.');
            return this.walkComments(callback);
        };

        _createClass(Container, [{
            key: 'first',
            get: function get() {
                if (!this.nodes) return undefined;
                return this.nodes[0];
            }

            /**
             * The container’s last child.
             *
             * @type {Node}
             *
             * @example
             * rule.last == rule.nodes[rule.nodes.length - 1];
             */

        }, {
            key: 'last',
            get: function get() {
                if (!this.nodes) return undefined;
                return this.nodes[this.nodes.length - 1];
            }
        }, {
            key: 'semicolon',
            get: function get() {
                (0, _warnOnce2.default)('Node#semicolon is deprecated. Use Node#raws.semicolon');
                return this.raws.semicolon;
            },
            set: function set(val) {
                (0, _warnOnce2.default)('Node#semicolon is deprecated. Use Node#raws.semicolon');
                this.raws.semicolon = val;
            }
        }, {
            key: 'after',
            get: function get() {
                (0, _warnOnce2.default)('Node#after is deprecated. Use Node#raws.after');
                return this.raws.after;
            },
            set: function set(val) {
                (0, _warnOnce2.default)('Node#after is deprecated. Use Node#raws.after');
                this.raws.after = val;
            }

            /**
             * @memberof Container#
             * @member {Node[]} nodes - an array containing the container’s children
             *
             * @example
             * const root = postcss.parse('a { color: black }');
             * root.nodes.length           //=> 1
             * root.nodes[0].selector      //=> 'a'
             * root.nodes[0].nodes[0].prop //=> 'color'
             */

        }]);

        return Container;
    }(_node2.default);

    exports.default = Container;

    /**
     * @callback childCondition
     * @param {Node} node    - container child
     * @param {number} index - child index
     * @param {Node[]} nodes - all container children
     * @return {boolean}
     */

    /**
     * @callback childIterator
     * @param {Node} node    - container child
     * @param {number} index - child index
     * @return {false|undefined} returning `false` will break iteration
     */

    module.exports = exports['default'];
    return module.exports;
});
System.registerDynamic('npm:postcss@5.2.6/lib/list.js', ['process'], true, function ($__require, exports, module) {
    'use strict';

    var process = $__require('process');
    var define,
        global = this || self,
        GLOBAL = global;
    exports.__esModule = true;
    /**
     * Contains helpers for safely splitting lists of CSS values,
     * preserving parentheses and quotes.
     *
     * @example
     * const list = postcss.list;
     *
     * @namespace list
     */
    var list = {
        split: function split(string, separators, last) {
            var array = [];
            var current = '';
            var split = false;

            var func = 0;
            var quote = false;
            var escape = false;

            for (var i = 0; i < string.length; i++) {
                var letter = string[i];

                if (quote) {
                    if (escape) {
                        escape = false;
                    } else if (letter === '\\') {
                        escape = true;
                    } else if (letter === quote) {
                        quote = false;
                    }
                } else if (letter === '"' || letter === '\'') {
                    quote = letter;
                } else if (letter === '(') {
                    func += 1;
                } else if (letter === ')') {
                    if (func > 0) func -= 1;
                } else if (func === 0) {
                    if (separators.indexOf(letter) !== -1) split = true;
                }

                if (split) {
                    if (current !== '') array.push(current.trim());
                    current = '';
                    split = false;
                } else {
                    current += letter;
                }
            }

            if (last || current !== '') array.push(current.trim());
            return array;
        },

        /**
         * Safely splits space-separated values (such as those for `background`,
         * `border-radius`, and other shorthand properties).
         *
         * @param {string} string - space-separated values
         *
         * @return {string[]} split values
         *
         * @example
         * postcss.list.space('1px calc(10% + 1px)') //=> ['1px', 'calc(10% + 1px)']
         */
        space: function space(string) {
            var spaces = [' ', '\n', '\t'];
            return list.split(string, spaces);
        },

        /**
         * Safely splits comma-separated values (such as those for `transition-*`
         * and `background` properties).
         *
         * @param {string} string - comma-separated values
         *
         * @return {string[]} split values
         *
         * @example
         * postcss.list.comma('black, linear-gradient(white, black)')
         * //=> ['black', 'linear-gradient(white, black)']
         */
        comma: function comma(string) {
            var comma = ',';
            return list.split(string, [comma], true);
        }
    };

    exports.default = list;
    module.exports = exports['default'];
    return module.exports;
});
System.registerDynamic('npm:postcss@5.2.6/lib/rule.js', ['./container', './warn-once', './list', 'process'], true, function ($__require, exports, module) {
    'use strict';

    var process = $__require('process');
    var define,
        global = this || self,
        GLOBAL = global;
    exports.__esModule = true;

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
        }return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
    }();

    var _container = $__require('./container');

    var _container2 = _interopRequireDefault(_container);

    var _warnOnce = $__require('./warn-once');

    var _warnOnce2 = _interopRequireDefault(_warnOnce);

    var _list = $__require('./list');

    var _list2 = _interopRequireDefault(_list);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    /**
     * Represents a CSS rule: a selector followed by a declaration block.
     *
     * @extends Container
     *
     * @example
     * const root = postcss.parse('a{}');
     * const rule = root.first;
     * rule.type       //=> 'rule'
     * rule.toString() //=> 'a{}'
     */
    var Rule = function (_Container) {
        _inherits(Rule, _Container);

        function Rule(defaults) {
            _classCallCheck(this, Rule);

            var _this = _possibleConstructorReturn(this, _Container.call(this, defaults));

            _this.type = 'rule';
            if (!_this.nodes) _this.nodes = [];
            return _this;
        }

        /**
         * An array containing the rule’s individual selectors.
         * Groups of selectors are split at commas.
         *
         * @type {string[]}
         *
         * @example
         * const root = postcss.parse('a, b { }');
         * const rule = root.first;
         *
         * rule.selector  //=> 'a, b'
         * rule.selectors //=> ['a', 'b']
         *
         * rule.selectors = ['a', 'strong'];
         * rule.selector //=> 'a, strong'
         */

        _createClass(Rule, [{
            key: 'selectors',
            get: function get() {
                return _list2.default.comma(this.selector);
            },
            set: function set(values) {
                var match = this.selector ? this.selector.match(/,\s*/) : null;
                var sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen');
                this.selector = values.join(sep);
            }
        }, {
            key: '_selector',
            get: function get() {
                (0, _warnOnce2.default)('Rule#_selector is deprecated. Use Rule#raws.selector');
                return this.raws.selector;
            },
            set: function set(val) {
                (0, _warnOnce2.default)('Rule#_selector is deprecated. Use Rule#raws.selector');
                this.raws.selector = val;
            }

            /**
             * @memberof Rule#
             * @member {string} selector - the rule’s full selector represented
             *                             as a string
             *
             * @example
             * const root = postcss.parse('a, b { }');
             * const rule = root.first;
             * rule.selector //=> 'a, b'
             */

            /**
             * @memberof Rule#
             * @member {object} raws - Information to generate byte-to-byte equal
             *                         node string as it was in the origin input.
             *
             * Every parser saves its own properties,
             * but the default CSS parser uses:
             *
             * * `before`: the space symbols before the node. It also stores `*`
             *   and `_` symbols before the declaration (IE hack).
             * * `after`: the space symbols after the last child of the node
             *   to the end of the node.
             * * `between`: the symbols between the property and value
             *   for declarations, selector and `{` for rules, or last parameter
             *   and `{` for at-rules.
             * * `semicolon`: contains true if the last child has
             *   an (optional) semicolon.
             *
             * PostCSS cleans selectors from comments and extra spaces,
             * but it stores origin content in raws properties.
             * As such, if you don’t change a declaration’s value,
             * PostCSS will use the raw value with comments.
             *
             * @example
             * const root = postcss.parse('a {\n  color:black\n}')
             * root.first.first.raws //=> { before: '', between: ' ', after: '\n' }
             */

        }]);

        return Rule;
    }(_container2.default);

    exports.default = Rule;
    module.exports = exports['default'];
    return module.exports;
});
System.registerDynamic('npm:postcss@5.2.6/lib/parser.js', ['./declaration', './tokenize', './comment', './at-rule', './root', './rule', 'process'], true, function ($__require, exports, module) {
    'use strict';

    var process = $__require('process');
    var define,
        global = this || self,
        GLOBAL = global;
    exports.__esModule = true;

    var _declaration = $__require('./declaration');

    var _declaration2 = _interopRequireDefault(_declaration);

    var _tokenize = $__require('./tokenize');

    var _tokenize2 = _interopRequireDefault(_tokenize);

    var _comment = $__require('./comment');

    var _comment2 = _interopRequireDefault(_comment);

    var _atRule = $__require('./at-rule');

    var _atRule2 = _interopRequireDefault(_atRule);

    var _root = $__require('./root');

    var _root2 = _interopRequireDefault(_root);

    var _rule = $__require('./rule');

    var _rule2 = _interopRequireDefault(_rule);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var Parser = function () {
        function Parser(input) {
            _classCallCheck(this, Parser);

            this.input = input;

            this.pos = 0;
            this.root = new _root2.default();
            this.current = this.root;
            this.spaces = '';
            this.semicolon = false;

            this.root.source = { input: input, start: { line: 1, column: 1 } };
        }

        Parser.prototype.tokenize = function tokenize() {
            this.tokens = (0, _tokenize2.default)(this.input);
        };

        Parser.prototype.loop = function loop() {
            var token = void 0;
            while (this.pos < this.tokens.length) {
                token = this.tokens[this.pos];

                switch (token[0]) {

                    case 'space':
                    case ';':
                        this.spaces += token[1];
                        break;

                    case '}':
                        this.end(token);
                        break;

                    case 'comment':
                        this.comment(token);
                        break;

                    case 'at-word':
                        this.atrule(token);
                        break;

                    case '{':
                        this.emptyRule(token);
                        break;

                    default:
                        this.other();
                        break;
                }

                this.pos += 1;
            }
            this.endFile();
        };

        Parser.prototype.comment = function comment(token) {
            var node = new _comment2.default();
            this.init(node, token[2], token[3]);
            node.source.end = { line: token[4], column: token[5] };

            var text = token[1].slice(2, -2);
            if (/^\s*$/.test(text)) {
                node.text = '';
                node.raws.left = text;
                node.raws.right = '';
            } else {
                var match = text.match(/^(\s*)([^]*[^\s])(\s*)$/);
                node.text = match[2];
                node.raws.left = match[1];
                node.raws.right = match[3];
            }
        };

        Parser.prototype.emptyRule = function emptyRule(token) {
            var node = new _rule2.default();
            this.init(node, token[2], token[3]);
            node.selector = '';
            node.raws.between = '';
            this.current = node;
        };

        Parser.prototype.other = function other() {
            var token = void 0;
            var end = false;
            var type = null;
            var colon = false;
            var bracket = null;
            var brackets = [];

            var start = this.pos;
            while (this.pos < this.tokens.length) {
                token = this.tokens[this.pos];
                type = token[0];

                if (type === '(' || type === '[') {
                    if (!bracket) bracket = token;
                    brackets.push(type === '(' ? ')' : ']');
                } else if (brackets.length === 0) {
                    if (type === ';') {
                        if (colon) {
                            this.decl(this.tokens.slice(start, this.pos + 1));
                            return;
                        } else {
                            break;
                        }
                    } else if (type === '{') {
                        this.rule(this.tokens.slice(start, this.pos + 1));
                        return;
                    } else if (type === '}') {
                        this.pos -= 1;
                        end = true;
                        break;
                    } else if (type === ':') {
                        colon = true;
                    }
                } else if (type === brackets[brackets.length - 1]) {
                    brackets.pop();
                    if (brackets.length === 0) bracket = null;
                }

                this.pos += 1;
            }
            if (this.pos === this.tokens.length) {
                this.pos -= 1;
                end = true;
            }

            if (brackets.length > 0) this.unclosedBracket(bracket);

            if (end && colon) {
                while (this.pos > start) {
                    token = this.tokens[this.pos][0];
                    if (token !== 'space' && token !== 'comment') break;
                    this.pos -= 1;
                }
                this.decl(this.tokens.slice(start, this.pos + 1));
                return;
            }

            this.unknownWord(start);
        };

        Parser.prototype.rule = function rule(tokens) {
            tokens.pop();

            var node = new _rule2.default();
            this.init(node, tokens[0][2], tokens[0][3]);

            node.raws.between = this.spacesFromEnd(tokens);
            this.raw(node, 'selector', tokens);
            this.current = node;
        };

        Parser.prototype.decl = function decl(tokens) {
            var node = new _declaration2.default();
            this.init(node);

            var last = tokens[tokens.length - 1];
            if (last[0] === ';') {
                this.semicolon = true;
                tokens.pop();
            }
            if (last[4]) {
                node.source.end = { line: last[4], column: last[5] };
            } else {
                node.source.end = { line: last[2], column: last[3] };
            }

            while (tokens[0][0] !== 'word') {
                node.raws.before += tokens.shift()[1];
            }
            node.source.start = { line: tokens[0][2], column: tokens[0][3] };

            node.prop = '';
            while (tokens.length) {
                var type = tokens[0][0];
                if (type === ':' || type === 'space' || type === 'comment') {
                    break;
                }
                node.prop += tokens.shift()[1];
            }

            node.raws.between = '';

            var token = void 0;
            while (tokens.length) {
                token = tokens.shift();

                if (token[0] === ':') {
                    node.raws.between += token[1];
                    break;
                } else {
                    node.raws.between += token[1];
                }
            }

            if (node.prop[0] === '_' || node.prop[0] === '*') {
                node.raws.before += node.prop[0];
                node.prop = node.prop.slice(1);
            }
            node.raws.between += this.spacesFromStart(tokens);
            this.precheckMissedSemicolon(tokens);

            for (var i = tokens.length - 1; i > 0; i--) {
                token = tokens[i];
                if (token[1] === '!important') {
                    node.important = true;
                    var string = this.stringFrom(tokens, i);
                    string = this.spacesFromEnd(tokens) + string;
                    if (string !== ' !important') node.raws.important = string;
                    break;
                } else if (token[1] === 'important') {
                    var cache = tokens.slice(0);
                    var str = '';
                    for (var j = i; j > 0; j--) {
                        var _type = cache[j][0];
                        if (str.trim().indexOf('!') === 0 && _type !== 'space') {
                            break;
                        }
                        str = cache.pop()[1] + str;
                    }
                    if (str.trim().indexOf('!') === 0) {
                        node.important = true;
                        node.raws.important = str;
                        tokens = cache;
                    }
                }

                if (token[0] !== 'space' && token[0] !== 'comment') {
                    break;
                }
            }

            this.raw(node, 'value', tokens);

            if (node.value.indexOf(':') !== -1) this.checkMissedSemicolon(tokens);
        };

        Parser.prototype.atrule = function atrule(token) {
            var node = new _atRule2.default();
            node.name = token[1].slice(1);
            if (node.name === '') {
                this.unnamedAtrule(node, token);
            }
            this.init(node, token[2], token[3]);

            var last = false;
            var open = false;
            var params = [];

            this.pos += 1;
            while (this.pos < this.tokens.length) {
                token = this.tokens[this.pos];

                if (token[0] === ';') {
                    node.source.end = { line: token[2], column: token[3] };
                    this.semicolon = true;
                    break;
                } else if (token[0] === '{') {
                    open = true;
                    break;
                } else if (token[0] === '}') {
                    this.end(token);
                    break;
                } else {
                    params.push(token);
                }

                this.pos += 1;
            }
            if (this.pos === this.tokens.length) {
                last = true;
            }

            node.raws.between = this.spacesFromEnd(params);
            if (params.length) {
                node.raws.afterName = this.spacesFromStart(params);
                this.raw(node, 'params', params);
                if (last) {
                    token = params[params.length - 1];
                    node.source.end = { line: token[4], column: token[5] };
                    this.spaces = node.raws.between;
                    node.raws.between = '';
                }
            } else {
                node.raws.afterName = '';
                node.params = '';
            }

            if (open) {
                node.nodes = [];
                this.current = node;
            }
        };

        Parser.prototype.end = function end(token) {
            if (this.current.nodes && this.current.nodes.length) {
                this.current.raws.semicolon = this.semicolon;
            }
            this.semicolon = false;

            this.current.raws.after = (this.current.raws.after || '') + this.spaces;
            this.spaces = '';

            if (this.current.parent) {
                this.current.source.end = { line: token[2], column: token[3] };
                this.current = this.current.parent;
            } else {
                this.unexpectedClose(token);
            }
        };

        Parser.prototype.endFile = function endFile() {
            if (this.current.parent) this.unclosedBlock();
            if (this.current.nodes && this.current.nodes.length) {
                this.current.raws.semicolon = this.semicolon;
            }
            this.current.raws.after = (this.current.raws.after || '') + this.spaces;
        };

        // Helpers

        Parser.prototype.init = function init(node, line, column) {
            this.current.push(node);

            node.source = { start: { line: line, column: column }, input: this.input };
            node.raws.before = this.spaces;
            this.spaces = '';
            if (node.type !== 'comment') this.semicolon = false;
        };

        Parser.prototype.raw = function raw(node, prop, tokens) {
            var token = void 0,
                type = void 0;
            var length = tokens.length;
            var value = '';
            var clean = true;
            for (var i = 0; i < length; i += 1) {
                token = tokens[i];
                type = token[0];
                if (type === 'comment' || type === 'space' && i === length - 1) {
                    clean = false;
                } else {
                    value += token[1];
                }
            }
            if (!clean) {
                var raw = tokens.reduce(function (all, i) {
                    return all + i[1];
                }, '');
                node.raws[prop] = { value: value, raw: raw };
            }
            node[prop] = value;
        };

        Parser.prototype.spacesFromEnd = function spacesFromEnd(tokens) {
            var lastTokenType = void 0;
            var spaces = '';
            while (tokens.length) {
                lastTokenType = tokens[tokens.length - 1][0];
                if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;
                spaces = tokens.pop()[1] + spaces;
            }
            return spaces;
        };

        Parser.prototype.spacesFromStart = function spacesFromStart(tokens) {
            var next = void 0;
            var spaces = '';
            while (tokens.length) {
                next = tokens[0][0];
                if (next !== 'space' && next !== 'comment') break;
                spaces += tokens.shift()[1];
            }
            return spaces;
        };

        Parser.prototype.stringFrom = function stringFrom(tokens, from) {
            var result = '';
            for (var i = from; i < tokens.length; i++) {
                result += tokens[i][1];
            }
            tokens.splice(from, tokens.length - from);
            return result;
        };

        Parser.prototype.colon = function colon(tokens) {
            var brackets = 0;
            var token = void 0,
                type = void 0,
                prev = void 0;
            for (var i = 0; i < tokens.length; i++) {
                token = tokens[i];
                type = token[0];

                if (type === '(') {
                    brackets += 1;
                } else if (type === ')') {
                    brackets -= 1;
                } else if (brackets === 0 && type === ':') {
                    if (!prev) {
                        this.doubleColon(token);
                    } else if (prev[0] === 'word' && prev[1] === 'progid') {
                        continue;
                    } else {
                        return i;
                    }
                }

                prev = token;
            }
            return false;
        };

        // Errors

        Parser.prototype.unclosedBracket = function unclosedBracket(bracket) {
            throw this.input.error('Unclosed bracket', bracket[2], bracket[3]);
        };

        Parser.prototype.unknownWord = function unknownWord(start) {
            var token = this.tokens[start];
            throw this.input.error('Unknown word', token[2], token[3]);
        };

        Parser.prototype.unexpectedClose = function unexpectedClose(token) {
            throw this.input.error('Unexpected }', token[2], token[3]);
        };

        Parser.prototype.unclosedBlock = function unclosedBlock() {
            var pos = this.current.source.start;
            throw this.input.error('Unclosed block', pos.line, pos.column);
        };

        Parser.prototype.doubleColon = function doubleColon(token) {
            throw this.input.error('Double colon', token[2], token[3]);
        };

        Parser.prototype.unnamedAtrule = function unnamedAtrule(node, token) {
            throw this.input.error('At-rule without name', token[2], token[3]);
        };

        Parser.prototype.precheckMissedSemicolon = function precheckMissedSemicolon(tokens) {
            // Hook for Safe Parser
            tokens;
        };

        Parser.prototype.checkMissedSemicolon = function checkMissedSemicolon(tokens) {
            var colon = this.colon(tokens);
            if (colon === false) return;

            var founded = 0;
            var token = void 0;
            for (var j = colon - 1; j >= 0; j--) {
                token = tokens[j];
                if (token[0] !== 'space') {
                    founded += 1;
                    if (founded === 2) break;
                }
            }
            throw this.input.error('Missed semicolon', token[2], token[3]);
        };

        return Parser;
    }();

    exports.default = Parser;
    module.exports = exports['default'];
    return module.exports;
});
System.registerDynamic("npm:supports-color@3.1.2.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*": {
        "globals": {
          "process": "process"
        }
      },
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "./index.js": {
        "browser": "./browser.js"
      }
    }
  };
});

System.registerDynamic('npm:supports-color@3.1.2/browser.js', ['process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = false;
  return module.exports;
});
System.registerDynamic("npm:escape-string-regexp@1.0.5.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic('npm:escape-string-regexp@1.0.5/index.js', [], true, function ($__require, exports, module) {
	'use strict';

	var define,
	    global = this || self,
	    GLOBAL = global;
	var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

	module.exports = function (str) {
		if (typeof str !== 'string') {
			throw new TypeError('Expected a string');
		}

		return str.replace(matchOperatorsRe, '\\$&');
	};
	return module.exports;
});
System.registerDynamic("npm:ansi-styles@2.2.1.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic('npm:ansi-styles@2.2.1/index.js', [], true, function ($__require, exports, module) {
	'use strict';

	var define,
	    global = this || self,
	    GLOBAL = global;
	function assembleStyles() {
		var styles = {
			modifiers: {
				reset: [0, 0],
				bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
				dim: [2, 22],
				italic: [3, 23],
				underline: [4, 24],
				inverse: [7, 27],
				hidden: [8, 28],
				strikethrough: [9, 29]
			},
			colors: {
				black: [30, 39],
				red: [31, 39],
				green: [32, 39],
				yellow: [33, 39],
				blue: [34, 39],
				magenta: [35, 39],
				cyan: [36, 39],
				white: [37, 39],
				gray: [90, 39]
			},
			bgColors: {
				bgBlack: [40, 49],
				bgRed: [41, 49],
				bgGreen: [42, 49],
				bgYellow: [43, 49],
				bgBlue: [44, 49],
				bgMagenta: [45, 49],
				bgCyan: [46, 49],
				bgWhite: [47, 49]
			}
		};

		// fix humans
		styles.colors.grey = styles.colors.gray;

		Object.keys(styles).forEach(function (groupName) {
			var group = styles[groupName];

			Object.keys(group).forEach(function (styleName) {
				var style = group[styleName];

				styles[styleName] = group[styleName] = {
					open: '\u001b[' + style[0] + 'm',
					close: '\u001b[' + style[1] + 'm'
				};
			});

			Object.defineProperty(styles, groupName, {
				value: group,
				enumerable: false
			});
		});

		return styles;
	}

	Object.defineProperty(module, 'exports', {
		enumerable: true,
		get: assembleStyles
	});
	return module.exports;
});
System.registerDynamic("npm:strip-ansi@3.0.1.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic('npm:strip-ansi@3.0.1/index.js', ['ansi-regex'], true, function ($__require, exports, module) {
	'use strict';

	var define,
	    global = this || self,
	    GLOBAL = global;
	var ansiRegex = $__require('ansi-regex')();

	module.exports = function (str) {
		return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
	};
	return module.exports;
});
System.registerDynamic("npm:ansi-regex@2.0.0.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic('npm:ansi-regex@2.0.0/index.js', [], true, function ($__require, exports, module) {
	'use strict';

	var define,
	    global = this || self,
	    GLOBAL = global;
	module.exports = function () {
		return (/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g
		);
	};
	return module.exports;
});
System.registerDynamic("npm:has-ansi@2.0.0.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic('npm:has-ansi@2.0.0/index.js', ['ansi-regex'], true, function ($__require, exports, module) {
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var ansiRegex = $__require('ansi-regex');
  var re = new RegExp(ansiRegex().source); // remove the `g` flag
  module.exports = re.test.bind(re);
  return module.exports;
});
System.registerDynamic("npm:supports-color@2.0.0.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*": {
        "globals": {
          "process": "process"
        }
      },
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic('npm:supports-color@2.0.0/index.js', ['process'], true, function ($__require, exports, module) {
	'use strict';

	var process = $__require('process');
	var define,
	    global = this || self,
	    GLOBAL = global;
	var argv = process.argv;

	var terminator = argv.indexOf('--');
	var hasFlag = function (flag) {
		flag = '--' + flag;
		var pos = argv.indexOf(flag);
		return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
	};

	module.exports = function () {
		if ('FORCE_COLOR' in process.env) {
			return true;
		}

		if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {
			return false;
		}

		if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
			return true;
		}

		if (process.stdout && !process.stdout.isTTY) {
			return false;
		}

		if (process.platform === 'win32') {
			return true;
		}

		if ('COLORTERM' in process.env) {
			return true;
		}

		if (process.env.TERM === 'dumb') {
			return false;
		}

		if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
			return true;
		}

		return false;
	}();
	return module.exports;
});
System.registerDynamic("npm:chalk@1.1.3.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*": {
        "globals": {
          "process": "process"
        }
      },
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic('npm:chalk@1.1.3/index.js', ['escape-string-regexp', 'ansi-styles', 'strip-ansi', 'has-ansi', 'supports-color', 'process'], true, function ($__require, exports, module) {
	'use strict';

	var process = $__require('process');
	var define,
	    global = this || self,
	    GLOBAL = global;
	var escapeStringRegexp = $__require('escape-string-regexp');
	var ansiStyles = $__require('ansi-styles');
	var stripAnsi = $__require('strip-ansi');
	var hasAnsi = $__require('has-ansi');
	var supportsColor = $__require('supports-color');
	var defineProps = Object.defineProperties;
	var isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);

	function Chalk(options) {
		// detect mode if not set manually
		this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;
	}

	// use bright blue on Windows as the normal blue color is illegible
	if (isSimpleWindowsTerm) {
		ansiStyles.blue.open = '\u001b[94m';
	}

	var styles = function () {
		var ret = {};

		Object.keys(ansiStyles).forEach(function (key) {
			ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

			ret[key] = {
				get: function () {
					return build.call(this, this._styles.concat(key));
				}
			};
		});

		return ret;
	}();

	var proto = defineProps(function chalk() {}, styles);

	function build(_styles) {
		var builder = function () {
			return applyStyle.apply(builder, arguments);
		};

		builder._styles = _styles;
		builder.enabled = this.enabled;
		// __proto__ is used because we must return a function, but there is
		// no way to create a function with a different prototype.
		/* eslint-disable no-proto */
		builder.__proto__ = proto;

		return builder;
	}

	function applyStyle() {
		// support varags, but simply cast to string in case there's only one arg
		var args = arguments;
		var argsLen = args.length;
		var str = argsLen !== 0 && String(arguments[0]);

		if (argsLen > 1) {
			// don't slice `arguments`, it prevents v8 optimizations
			for (var a = 1; a < argsLen; a++) {
				str += ' ' + args[a];
			}
		}

		if (!this.enabled || !str) {
			return str;
		}

		var nestedStyles = this._styles;
		var i = nestedStyles.length;

		// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
		// see https://github.com/chalk/chalk/issues/58
		// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
		var originalDim = ansiStyles.dim.open;
		if (isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {
			ansiStyles.dim.open = '';
		}

		while (i--) {
			var code = ansiStyles[nestedStyles[i]];

			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			str = code.open + str.replace(code.closeRe, code.open) + code.close;
		}

		// Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.
		ansiStyles.dim.open = originalDim;

		return str;
	}

	function init() {
		var ret = {};

		Object.keys(styles).forEach(function (name) {
			ret[name] = {
				get: function () {
					return build.call(this, [name]);
				}
			};
		});

		return ret;
	}

	defineProps(Chalk.prototype, init());

	module.exports = new Chalk();
	module.exports.styles = ansiStyles;
	module.exports.hasColor = hasAnsi;
	module.exports.stripColor = stripAnsi;
	module.exports.supportsColor = supportsColor;
	return module.exports;
});
System.registerDynamic('npm:postcss@5.2.6/lib/tokenize.js', ['process'], true, function ($__require, exports, module) {
    'use strict';

    var process = $__require('process');
    var define,
        global = this || self,
        GLOBAL = global;
    exports.__esModule = true;
    exports.default = tokenize;
    var SINGLE_QUOTE = 39;
    var DOUBLE_QUOTE = 34;
    var BACKSLASH = 92;
    var SLASH = 47;
    var NEWLINE = 10;
    var SPACE = 32;
    var FEED = 12;
    var TAB = 9;
    var CR = 13;
    var OPEN_SQUARE = 91;
    var CLOSE_SQUARE = 93;
    var OPEN_PARENTHESES = 40;
    var CLOSE_PARENTHESES = 41;
    var OPEN_CURLY = 123;
    var CLOSE_CURLY = 125;
    var SEMICOLON = 59;
    var ASTERISK = 42;
    var COLON = 58;
    var AT = 64;

    var RE_AT_END = /[ \n\t\r\f\{\(\)'"\\;/\[\]#]/g;
    var RE_WORD_END = /[ \n\t\r\f\(\)\{\}:;@!'"\\\]\[#]|\/(?=\*)/g;
    var RE_BAD_BRACKET = /.[\\\/\("'\n]/;

    function tokenize(input) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var tokens = [];
        var css = input.css.valueOf();

        var ignore = options.ignoreErrors;

        var code = void 0,
            next = void 0,
            quote = void 0,
            lines = void 0,
            last = void 0,
            content = void 0,
            escape = void 0,
            nextLine = void 0,
            nextOffset = void 0,
            escaped = void 0,
            escapePos = void 0,
            prev = void 0,
            n = void 0;

        var length = css.length;
        var offset = -1;
        var line = 1;
        var pos = 0;

        function unclosed(what) {
            throw input.error('Unclosed ' + what, line, pos - offset);
        }

        while (pos < length) {
            code = css.charCodeAt(pos);

            if (code === NEWLINE || code === FEED || code === CR && css.charCodeAt(pos + 1) !== NEWLINE) {
                offset = pos;
                line += 1;
            }

            switch (code) {
                case NEWLINE:
                case SPACE:
                case TAB:
                case CR:
                case FEED:
                    next = pos;
                    do {
                        next += 1;
                        code = css.charCodeAt(next);
                        if (code === NEWLINE) {
                            offset = next;
                            line += 1;
                        }
                    } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);

                    tokens.push(['space', css.slice(pos, next)]);
                    pos = next - 1;
                    break;

                case OPEN_SQUARE:
                    tokens.push(['[', '[', line, pos - offset]);
                    break;

                case CLOSE_SQUARE:
                    tokens.push([']', ']', line, pos - offset]);
                    break;

                case OPEN_CURLY:
                    tokens.push(['{', '{', line, pos - offset]);
                    break;

                case CLOSE_CURLY:
                    tokens.push(['}', '}', line, pos - offset]);
                    break;

                case COLON:
                    tokens.push([':', ':', line, pos - offset]);
                    break;

                case SEMICOLON:
                    tokens.push([';', ';', line, pos - offset]);
                    break;

                case OPEN_PARENTHESES:
                    prev = tokens.length ? tokens[tokens.length - 1][1] : '';
                    n = css.charCodeAt(pos + 1);
                    if (prev === 'url' && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {
                        next = pos;
                        do {
                            escaped = false;
                            next = css.indexOf(')', next + 1);
                            if (next === -1) {
                                if (ignore) {
                                    next = pos;
                                    break;
                                } else {
                                    unclosed('bracket');
                                }
                            }
                            escapePos = next;
                            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                                escapePos -= 1;
                                escaped = !escaped;
                            }
                        } while (escaped);

                        tokens.push(['brackets', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);
                        pos = next;
                    } else {
                        next = css.indexOf(')', pos + 1);
                        content = css.slice(pos, next + 1);

                        if (next === -1 || RE_BAD_BRACKET.test(content)) {
                            tokens.push(['(', '(', line, pos - offset]);
                        } else {
                            tokens.push(['brackets', content, line, pos - offset, line, next - offset]);
                            pos = next;
                        }
                    }

                    break;

                case CLOSE_PARENTHESES:
                    tokens.push([')', ')', line, pos - offset]);
                    break;

                case SINGLE_QUOTE:
                case DOUBLE_QUOTE:
                    quote = code === SINGLE_QUOTE ? '\'' : '"';
                    next = pos;
                    do {
                        escaped = false;
                        next = css.indexOf(quote, next + 1);
                        if (next === -1) {
                            if (ignore) {
                                next = pos + 1;
                                break;
                            } else {
                                unclosed('string');
                            }
                        }
                        escapePos = next;
                        while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                            escapePos -= 1;
                            escaped = !escaped;
                        }
                    } while (escaped);

                    content = css.slice(pos, next + 1);
                    lines = content.split('\n');
                    last = lines.length - 1;

                    if (last > 0) {
                        nextLine = line + last;
                        nextOffset = next - lines[last].length;
                    } else {
                        nextLine = line;
                        nextOffset = offset;
                    }

                    tokens.push(['string', css.slice(pos, next + 1), line, pos - offset, nextLine, next - nextOffset]);

                    offset = nextOffset;
                    line = nextLine;
                    pos = next;
                    break;

                case AT:
                    RE_AT_END.lastIndex = pos + 1;
                    RE_AT_END.test(css);
                    if (RE_AT_END.lastIndex === 0) {
                        next = css.length - 1;
                    } else {
                        next = RE_AT_END.lastIndex - 2;
                    }
                    tokens.push(['at-word', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);
                    pos = next;
                    break;

                case BACKSLASH:
                    next = pos;
                    escape = true;
                    while (css.charCodeAt(next + 1) === BACKSLASH) {
                        next += 1;
                        escape = !escape;
                    }
                    code = css.charCodeAt(next + 1);
                    if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
                        next += 1;
                    }
                    tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);
                    pos = next;
                    break;

                default:
                    if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
                        next = css.indexOf('*/', pos + 2) + 1;
                        if (next === 0) {
                            if (ignore) {
                                next = css.length;
                            } else {
                                unclosed('comment');
                            }
                        }

                        content = css.slice(pos, next + 1);
                        lines = content.split('\n');
                        last = lines.length - 1;

                        if (last > 0) {
                            nextLine = line + last;
                            nextOffset = next - lines[last].length;
                        } else {
                            nextLine = line;
                            nextOffset = offset;
                        }

                        tokens.push(['comment', content, line, pos - offset, nextLine, next - nextOffset]);

                        offset = nextOffset;
                        line = nextLine;
                        pos = next;
                    } else {
                        RE_WORD_END.lastIndex = pos + 1;
                        RE_WORD_END.test(css);
                        if (RE_WORD_END.lastIndex === 0) {
                            next = css.length - 1;
                        } else {
                            next = RE_WORD_END.lastIndex - 2;
                        }

                        tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);
                        pos = next;
                    }

                    break;
            }

            pos++;
        }

        return tokens;
    }
    module.exports = exports['default'];
    return module.exports;
});
System.registerDynamic('npm:postcss@5.2.6/lib/terminal-highlight.js', ['chalk', './tokenize', './input', 'process'], true, function ($__require, exports, module) {
    'use strict';

    var process = $__require('process');
    var define,
        global = this || self,
        GLOBAL = global;
    exports.__esModule = true;

    var _chalk = $__require('chalk');

    var _chalk2 = _interopRequireDefault(_chalk);

    var _tokenize = $__require('./tokenize');

    var _tokenize2 = _interopRequireDefault(_tokenize);

    var _input = $__require('./input');

    var _input2 = _interopRequireDefault(_input);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }

    var colors = new _chalk2.default.constructor({ enabled: true });

    var HIGHLIGHT_THEME = {
        'brackets': colors.cyan,
        'at-word': colors.cyan,
        'call': colors.cyan,
        'comment': colors.gray,
        'string': colors.green,
        'class': colors.yellow,
        'hash': colors.magenta,
        '(': colors.cyan,
        ')': colors.cyan,
        '{': colors.yellow,
        '}': colors.yellow,
        '[': colors.yellow,
        ']': colors.yellow,
        ':': colors.yellow,
        ';': colors.yellow
    };

    function getTokenType(_ref, index, tokens) {
        var type = _ref[0],
            value = _ref[1];

        if (type === 'word') {
            if (value[0] === '.') {
                return 'class';
            }
            if (value[0] === '#') {
                return 'hash';
            }
        }

        var nextToken = tokens[index + 1];
        if (nextToken && (nextToken[0] === 'brackets' || nextToken[0] === '(')) {
            return 'call';
        }

        return type;
    }

    function terminalHighlight(css) {
        var tokens = (0, _tokenize2.default)(new _input2.default(css), { ignoreErrors: true });
        return tokens.map(function (token, index) {
            var color = HIGHLIGHT_THEME[getTokenType(token, index, tokens)];
            if (color) {
                return token[1].split(/\r?\n/).map(function (i) {
                    return color(i);
                }).join('\n');
            } else {
                return token[1];
            }
        }).join('');
    }

    exports.default = terminalHighlight;
    module.exports = exports['default'];
    return module.exports;
});
System.registerDynamic('npm:postcss@5.2.6/lib/warn-once.js', ['process'], true, function ($__require, exports, module) {
    'use strict';

    var process = $__require('process');
    var define,
        global = this || self,
        GLOBAL = global;
    exports.__esModule = true;
    exports.default = warnOnce;
    var printed = {};

    function warnOnce(message) {
        if (printed[message]) return;
        printed[message] = true;

        if (typeof console !== 'undefined' && console.warn) console.warn(message);
    }
    module.exports = exports['default'];
    return module.exports;
});
System.registerDynamic('npm:postcss@5.2.6/lib/css-syntax-error.js', ['supports-color', 'chalk', './terminal-highlight', './warn-once', 'process'], true, function ($__require, exports, module) {
    'use strict';

    var process = $__require('process');
    var define,
        global = this || self,
        GLOBAL = global;
    exports.__esModule = true;

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
        }return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
    }();

    var _supportsColor = $__require('supports-color');

    var _supportsColor2 = _interopRequireDefault(_supportsColor);

    var _chalk = $__require('chalk');

    var _chalk2 = _interopRequireDefault(_chalk);

    var _terminalHighlight = $__require('./terminal-highlight');

    var _terminalHighlight2 = _interopRequireDefault(_terminalHighlight);

    var _warnOnce = $__require('./warn-once');

    var _warnOnce2 = _interopRequireDefault(_warnOnce);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    /**
     * The CSS parser throws this error for broken CSS.
     *
     * Custom parsers can throw this error for broken custom syntax using
     * the {@link Node#error} method.
     *
     * PostCSS will use the input source map to detect the original error location.
     * If you wrote a Sass file, compiled it to CSS and then parsed it with PostCSS,
     * PostCSS will show the original position in the Sass file.
     *
     * If you need the position in the PostCSS input
     * (e.g., to debug the previous compiler), use `error.input.file`.
     *
     * @example
     * // Catching and checking syntax error
     * try {
     *   postcss.parse('a{')
     * } catch (error) {
     *   if ( error.name === 'CssSyntaxError' ) {
     *     error //=> CssSyntaxError
     *   }
     * }
     *
     * @example
     * // Raising error from plugin
     * throw node.error('Unknown variable', { plugin: 'postcss-vars' });
     */
    var CssSyntaxError = function () {

        /**
         * @param {string} message  - error message
         * @param {number} [line]   - source line of the error
         * @param {number} [column] - source column of the error
         * @param {string} [source] - source code of the broken file
         * @param {string} [file]   - absolute path to the broken file
         * @param {string} [plugin] - PostCSS plugin name, if error came from plugin
         */
        function CssSyntaxError(message, line, column, source, file, plugin) {
            _classCallCheck(this, CssSyntaxError);

            /**
             * @member {string} - Always equal to `'CssSyntaxError'`. You should
             *                    always check error type
             *                    by `error.name === 'CssSyntaxError'` instead of
             *                    `error instanceof CssSyntaxError`, because
             *                    npm could have several PostCSS versions.
             *
             * @example
             * if ( error.name === 'CssSyntaxError' ) {
             *   error //=> CssSyntaxError
             * }
             */
            this.name = 'CssSyntaxError';
            /**
             * @member {string} - Error message.
             *
             * @example
             * error.message //=> 'Unclosed block'
             */
            this.reason = message;

            if (file) {
                /**
                 * @member {string} - Absolute path to the broken file.
                 *
                 * @example
                 * error.file       //=> 'a.sass'
                 * error.input.file //=> 'a.css'
                 */
                this.file = file;
            }
            if (source) {
                /**
                 * @member {string} - Source code of the broken file.
                 *
                 * @example
                 * error.source       //=> 'a { b {} }'
                 * error.input.column //=> 'a b { }'
                 */
                this.source = source;
            }
            if (plugin) {
                /**
                 * @member {string} - Plugin name, if error came from plugin.
                 *
                 * @example
                 * error.plugin //=> 'postcss-vars'
                 */
                this.plugin = plugin;
            }
            if (typeof line !== 'undefined' && typeof column !== 'undefined') {
                /**
                 * @member {number} - Source line of the error.
                 *
                 * @example
                 * error.line       //=> 2
                 * error.input.line //=> 4
                 */
                this.line = line;
                /**
                 * @member {number} - Source column of the error.
                 *
                 * @example
                 * error.column       //=> 1
                 * error.input.column //=> 4
                 */
                this.column = column;
            }

            this.setMessage();

            if (Error.captureStackTrace) {
                Error.captureStackTrace(this, CssSyntaxError);
            }
        }

        CssSyntaxError.prototype.setMessage = function setMessage() {
            /**
             * @member {string} - Full error text in the GNU error format
             *                    with plugin, file, line and column.
             *
             * @example
             * error.message //=> 'a.css:1:1: Unclosed block'
             */
            this.message = this.plugin ? this.plugin + ': ' : '';
            this.message += this.file ? this.file : '<css input>';
            if (typeof this.line !== 'undefined') {
                this.message += ':' + this.line + ':' + this.column;
            }
            this.message += ': ' + this.reason;
        };

        /**
         * Returns a few lines of CSS source that caused the error.
         *
         * If the CSS has an input source map without `sourceContent`,
         * this method will return an empty string.
         *
         * @param {boolean} [color] whether arrow will be colored red by terminal
         *                          color codes. By default, PostCSS will detect
         *                          color support by `process.stdout.isTTY`
         *                          and `process.env.NODE_DISABLE_COLORS`.
         *
         * @example
         * error.showSourceCode() //=> "  4 | }
         *                        //      5 | a {
         *                        //    > 6 |   bad
         *                        //        |   ^
         *                        //      7 | }
         *                        //      8 | b {"
         *
         * @return {string} few lines of CSS source that caused the error
         */

        CssSyntaxError.prototype.showSourceCode = function showSourceCode(color) {
            var _this = this;

            if (!this.source) return '';

            var css = this.source;
            if (typeof color === 'undefined') color = _supportsColor2.default;
            if (color) css = (0, _terminalHighlight2.default)(css);

            var lines = css.split(/\r?\n/);
            var start = Math.max(this.line - 3, 0);
            var end = Math.min(this.line + 2, lines.length);

            var maxWidth = String(end).length;
            var colors = new _chalk2.default.constructor({ enabled: true });

            function mark(text) {
                if (color) {
                    return colors.red.bold(text);
                } else {
                    return text;
                }
            }
            function aside(text) {
                if (color) {
                    return colors.gray(text);
                } else {
                    return text;
                }
            }

            return lines.slice(start, end).map(function (line, index) {
                var number = start + 1 + index;
                var gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | ';
                if (number === _this.line) {
                    var spacing = aside(gutter.replace(/\d/g, ' ')) + line.slice(0, _this.column - 1).replace(/[^\t]/g, ' ');
                    return mark('>') + aside(gutter) + line + '\n ' + spacing + mark('^');
                } else {
                    return ' ' + aside(gutter) + line;
                }
            }).join('\n');
        };

        /**
         * Returns error position, message and source code of the broken part.
         *
         * @example
         * error.toString() //=> "CssSyntaxError: app.css:1:1: Unclosed block
         *                  //    > 1 | a {
         *                  //        | ^"
         *
         * @return {string} error position, message and source code
         */

        CssSyntaxError.prototype.toString = function toString() {
            var code = this.showSourceCode();
            if (code) {
                code = '\n\n' + code + '\n';
            }
            return this.name + ': ' + this.message + code;
        };

        _createClass(CssSyntaxError, [{
            key: 'generated',
            get: function get() {
                (0, _warnOnce2.default)('CssSyntaxError#generated is depreacted. Use input instead.');
                return this.input;
            }

            /**
             * @memberof CssSyntaxError#
             * @member {Input} input - Input object with PostCSS internal information
             *                         about input file. If input has source map
             *                         from previous tool, PostCSS will use origin
             *                         (for example, Sass) source. You can use this
             *                         object to get PostCSS input source.
             *
             * @example
             * error.input.file //=> 'a.css'
             * error.file       //=> 'a.sass'
             */

        }]);

        return CssSyntaxError;
    }();

    exports.default = CssSyntaxError;
    module.exports = exports['default'];
    return module.exports;
});
System.registerDynamic("npm:jspm-nodelibs-buffer@0.2.1.json", [], false, function() {
  return {
    "main": "buffer.js",
    "map": {
      "./buffer.js": {
        "browser": "buffer"
      }
    }
  };
});

System.registerDynamic("npm:base64-js@1.2.0.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic('npm:base64-js@1.2.0/index.js', [], true, function ($__require, exports, module) {
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  exports.byteLength = byteLength;
  exports.toByteArray = toByteArray;
  exports.fromByteArray = fromByteArray;

  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;

  function placeHoldersCount(b64) {
    var len = b64.length;
    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4');
    }

    // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice
    return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
  }

  function byteLength(b64) {
    // base64 is 4/3 + up to two characters of the original data
    return b64.length * 3 / 4 - placeHoldersCount(b64);
  }

  function toByteArray(b64) {
    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;
    placeHolders = placeHoldersCount(b64);

    arr = new Arr(len * 3 / 4 - placeHolders);

    // if there are placeholders, only get up to the last complete 4 chars
    l = placeHolders > 0 ? len - 4 : len;

    var L = 0;

    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[L++] = tmp >> 16 & 0xFF;
      arr[L++] = tmp >> 8 & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    if (placeHolders === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[L++] = tmp & 0xFF;
    } else if (placeHolders === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[L++] = tmp >> 8 & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    return arr;
  }

  function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
  }

  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
      output.push(tripletToBase64(tmp));
    }
    return output.join('');
  }

  function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
    var output = '';
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[tmp << 4 & 0x3F];
      output += '==';
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      output += lookup[tmp >> 10];
      output += lookup[tmp >> 4 & 0x3F];
      output += lookup[tmp << 2 & 0x3F];
      output += '=';
    }

    parts.push(output);

    return parts.join('');
  }
  return module.exports;
});
System.registerDynamic("npm:ieee754@1.1.8.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      },
      "test/*": {
        "globals": {
          "Buffer": "buffer/global"
        }
      }
    }
  };
});

System.registerDynamic("npm:ieee754@1.1.8/index.js", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  exports.read = function (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];

    i += d;

    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };

  exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  };
  return module.exports;
});
System.registerDynamic("npm:isarray@1.0.0.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic('npm:isarray@1.0.0/index.js', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  var toString = {}.toString;

  module.exports = Array.isArray || function (arr) {
    return toString.call(arr) == '[object Array]';
  };
  return module.exports;
});
System.registerDynamic("npm:buffer@4.9.1.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*": {
        "globals": {
          "process": "process"
        }
      },
      "*.json": {
        "format": "json"
      },
      "test/constructor.js": {
        "globals": {
          "Buffer": "buffer/global"
        }
      },
      "test/node/*": {
        "globals": {
          "Buffer": "buffer/global"
        }
      }
    }
  };
});

System.registerDynamic('npm:buffer@4.9.1/index.js', ['base64-js', 'ieee754', 'isarray', 'process'], true, function ($__require, exports, module) {
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  /* eslint-disable no-proto */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var base64 = $__require('base64-js');
  var ieee754 = $__require('ieee754');
  var isArray = $__require('isarray');

  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.
  
   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */
  Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

  /*
   * Export kMaxLength after typed array support is determined.
   */
  exports.kMaxLength = kMaxLength();

  function typedArraySupport() {
    try {
      var arr = new Uint8Array(1);
      arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () {
          return 42;
        } };
      return arr.foo() === 42 && // typed array instances can be augmented
      typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
      arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
    } catch (e) {
      return false;
    }
  }

  function kMaxLength() {
    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
  }

  function createBuffer(that, length) {
    if (kMaxLength() < length) {
      throw new RangeError('Invalid typed array length');
    }
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = new Uint8Array(length);
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      if (that === null) {
        that = new Buffer(length);
      }
      that.length = length;
    }

    return that;
  }

  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */

  function Buffer(arg, encodingOrOffset, length) {
    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
      return new Buffer(arg, encodingOrOffset, length);
    }

    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new Error('If encoding is specified then the first argument must be a string');
      }
      return allocUnsafe(this, arg);
    }
    return from(this, arg, encodingOrOffset, length);
  }

  Buffer.poolSize = 8192; // not used by this implementation

  // TODO: Legacy, not needed anymore. Remove in next major version.
  Buffer._augment = function (arr) {
    arr.__proto__ = Buffer.prototype;
    return arr;
  };

  function from(that, value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('"value" argument must not be a number');
    }

    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length);
    }

    if (typeof value === 'string') {
      return fromString(that, value, encodingOrOffset);
    }

    return fromObject(that, value);
  }

  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  Buffer.from = function (value, encodingOrOffset, length) {
    return from(null, value, encodingOrOffset, length);
  };

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
    if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
      // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
      Object.defineProperty(Buffer, Symbol.species, {
        value: null,
        configurable: true
      });
    }
  }

  function assertSize(size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be a number');
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
  }

  function alloc(that, size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size);
    }
    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
    }
    return createBuffer(that, size);
  }

  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  Buffer.alloc = function (size, fill, encoding) {
    return alloc(null, size, fill, encoding);
  };

  function allocUnsafe(that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }
    return that;
  }

  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(null, size);
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(null, size);
  };

  function fromString(that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding');
    }

    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);

    var actual = that.write(string, encoding);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      that = that.slice(0, actual);
    }

    return that;
  }

  function fromArrayLike(that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }

  function fromArrayBuffer(that, array, byteOffset, length) {
    array.byteLength; // this throws if `array` is not a valid ArrayBuffer

    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('\'offset\' is out of bounds');
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('\'length\' is out of bounds');
    }

    if (byteOffset === undefined && length === undefined) {
      array = new Uint8Array(array);
    } else if (length === undefined) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = array;
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      that = fromArrayLike(that, array);
    }
    return that;
  }

  function fromObject(that, obj) {
    if (Buffer.isBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);

      if (that.length === 0) {
        return that;
      }

      obj.copy(that, 0, 0, len);
      return that;
    }

    if (obj) {
      if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
        if (typeof obj.length !== 'number' || isnan(obj.length)) {
          return createBuffer(that, 0);
        }
        return fromArrayLike(that, obj);
      }

      if (obj.type === 'Buffer' && isArray(obj.data)) {
        return fromArrayLike(that, obj.data);
      }
    }

    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
  }

  function checked(length) {
    // Note: cannot use `length < kMaxLength()` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
    }
    return length | 0;
  }

  function SlowBuffer(length) {
    if (+length != length) {
      // eslint-disable-line eqeqeq
      length = 0;
    }
    return Buffer.alloc(+length);
  }

  Buffer.isBuffer = function isBuffer(b) {
    return !!(b != null && b._isBuffer);
  };

  Buffer.compare = function compare(a, b) {
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError('Arguments must be Buffers');
    }

    if (a === b) return 0;

    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };

  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;
      default:
        return false;
    }
  };

  Buffer.concat = function concat(list, length) {
    if (!isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    if (list.length === 0) {
      return Buffer.alloc(0);
    }

    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (!Buffer.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer;
  };

  function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) {
      return string.length;
    }
    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== 'string') {
      string = '' + string;
    }

    var len = string.length;
    if (len === 0) return 0;

    // Use a for loop to avoid recursion
    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len;
        case 'utf8':
        case 'utf-8':
        case undefined:
          return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2;
        case 'hex':
          return len >>> 1;
        case 'base64':
          return base64ToBytes(string).length;
        default:
          if (loweredCase) return utf8ToBytes(string).length; // assume utf8
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;

  function slowToString(encoding, start, end) {
    var loweredCase = false;

    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.

    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
      start = 0;
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
      return '';
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return '';
    }

    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return '';
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);

        case 'ascii':
          return asciiSlice(this, start, end);

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end);

        case 'base64':
          return base64Slice(this, start, end);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }

  // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
  // Buffer instances.
  Buffer.prototype._isBuffer = true;

  function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits');
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };

  Buffer.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits');
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };

  Buffer.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits');
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };

  Buffer.prototype.toString = function toString() {
    var length = this.length | 0;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };

  Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
  };

  Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max) str += ' ... ';
    }
    return '<Buffer ' + str + '>';
  };

  Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (!Buffer.isBuffer(target)) {
      throw new TypeError('Argument must be a Buffer');
    }

    if (start === undefined) {
      start = 0;
    }
    if (end === undefined) {
      end = target ? target.length : 0;
    }
    if (thisStart === undefined) {
      thisStart = 0;
    }
    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index');
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;

    if (this === target) return 0;

    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);

    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };

  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf
  function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;

    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset; // Coerce to Number.
    if (isNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : buffer.length - 1;
    }

    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir) return -1;else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;else return -1;
    }

    // Normalize val
    if (typeof val === 'string') {
      val = Buffer.from(val, encoding);
    }

    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]
      if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
    }

    throw new TypeError('val must be string, number or Buffer');
  }

  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();
      if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read(buf, i) {
      if (indexSize === 1) {
        return buf[i];
      } else {
        return buf.readUInt16BE(i * indexSize);
      }
    }

    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break;
          }
        }
        if (found) return i;
      }
    }

    return -1;
  }

  Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };

  Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };

  Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };

  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }

    // must be an even number of digits
    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) return i;
      buf[offset + i] = parsed;
    }
    return i;
  }

  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }

  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }

  function latin1Write(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }

  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }

  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }

  Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
      // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
      // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
      // legacy write(string, encoding, offset, length) - remove in v0.13
    } else {
      throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds');
    }

    if (!encoding) encoding = 'utf8';

    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length);

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length);

        case 'ascii':
          return asciiWrite(this, string, offset, length);

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length);

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };

  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }

  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];

    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res);
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }

  function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret;
  }

  function latin1Slice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }

  function hexSlice(buf, start, end) {
    var len = buf.length;

    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;

    var out = '';
    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }
    return out;
  }

  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }

  Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;

    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);
      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start];
      }
    }

    return newBuf;
  };

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
  }

  Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val;
  };

  Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val;
  };

  Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };

  Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };

  Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };

  Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
  };

  Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };

  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val;
  };

  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val;
  };

  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
  };

  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };

  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };

  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };

  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };

  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };

  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };

  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
  }

  Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = value & 0xff;
    return offset + 1;
  };

  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }

  Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };

  Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };

  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
    }
  }

  Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };

  Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };

  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
  };

  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };

  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };

  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };

  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };

  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
  }

  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };

  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };

  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };

  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;

    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }
    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');

    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
    }

    return len;
  };

  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (code < 256) {
          val = code;
        }
      }
      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string');
      }
      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding);
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    }

    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index');
    }

    if (end <= start) {
      return this;
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;

    if (!val) val = 0;

    var i;
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
      var len = bytes.length;
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this;
  };

  // HELPER FUNCTIONS
  // ================

  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

  function base64clean(str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str;
  }

  function stringtrim(str) {
    if (str.trim) return str.trim();
    return str.replace(/^\s+|\s+$/g, '');
  }

  function toHex(n) {
    if (n < 16) return '0' + n.toString(16);
    return n.toString(16);
  }

  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          }

          // valid lead
          leadSurrogate = codePoint;

          continue;
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue;
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null;

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }

    return bytes;
  }

  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray;
  }

  function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;

      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray;
  }

  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }

  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }
    return i;
  }

  function isnan(val) {
    return val !== val; // eslint-disable-line no-self-compare
  }
  return module.exports;
});
System.registerDynamic("npm:js-base64@2.1.9.json", [], false, function() {
  return {
    "main": "base64.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic('npm:js-base64@2.1.9/base64.js', ['buffer'], true, function ($__require, exports, module) {
    var define,
        global = this || self,
        GLOBAL = global;
    /*
     * $Id: base64.js,v 2.15 2014/04/05 12:58:57 dankogai Exp dankogai $
     *
     *  Licensed under the MIT license.
     *    http://opensource.org/licenses/mit-license
     *
     *  References:
     *    http://en.wikipedia.org/wiki/Base64
     */

    (function (global) {
        'use strict';
        // existing version for noConflict()

        var _Base64 = global.Base64;
        var version = "2.1.9";
        // if node.js, we use Buffer
        var buffer;
        if (typeof module !== 'undefined' && module.exports) {
            try {
                buffer = $__require('buffer').Buffer;
            } catch (err) {}
        }
        // constants
        var b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        var b64tab = function (bin) {
            var t = {};
            for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
            return t;
        }(b64chars);
        var fromCharCode = String.fromCharCode;
        // encoder stuff
        var cb_utob = function (c) {
            if (c.length < 2) {
                var cc = c.charCodeAt(0);
                return cc < 0x80 ? c : cc < 0x800 ? fromCharCode(0xc0 | cc >>> 6) + fromCharCode(0x80 | cc & 0x3f) : fromCharCode(0xe0 | cc >>> 12 & 0x0f) + fromCharCode(0x80 | cc >>> 6 & 0x3f) + fromCharCode(0x80 | cc & 0x3f);
            } else {
                var cc = 0x10000 + (c.charCodeAt(0) - 0xD800) * 0x400 + (c.charCodeAt(1) - 0xDC00);
                return fromCharCode(0xf0 | cc >>> 18 & 0x07) + fromCharCode(0x80 | cc >>> 12 & 0x3f) + fromCharCode(0x80 | cc >>> 6 & 0x3f) + fromCharCode(0x80 | cc & 0x3f);
            }
        };
        var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
        var utob = function (u) {
            return u.replace(re_utob, cb_utob);
        };
        var cb_encode = function (ccc) {
            var padlen = [0, 2, 1][ccc.length % 3],
                ord = ccc.charCodeAt(0) << 16 | (ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8 | (ccc.length > 2 ? ccc.charCodeAt(2) : 0),
                chars = [b64chars.charAt(ord >>> 18), b64chars.charAt(ord >>> 12 & 63), padlen >= 2 ? '=' : b64chars.charAt(ord >>> 6 & 63), padlen >= 1 ? '=' : b64chars.charAt(ord & 63)];
            return chars.join('');
        };
        var btoa = global.btoa ? function (b) {
            return global.btoa(b);
        } : function (b) {
            return b.replace(/[\s\S]{1,3}/g, cb_encode);
        };
        var _encode = buffer ? function (u) {
            return (u.constructor === buffer.constructor ? u : new buffer(u)).toString('base64');
        } : function (u) {
            return btoa(utob(u));
        };
        var encode = function (u, urisafe) {
            return !urisafe ? _encode(String(u)) : _encode(String(u)).replace(/[+\/]/g, function (m0) {
                return m0 == '+' ? '-' : '_';
            }).replace(/=/g, '');
        };
        var encodeURI = function (u) {
            return encode(u, true);
        };
        // decoder stuff
        var re_btou = new RegExp(['[\xC0-\xDF][\x80-\xBF]', '[\xE0-\xEF][\x80-\xBF]{2}', '[\xF0-\xF7][\x80-\xBF]{3}'].join('|'), 'g');
        var cb_btou = function (cccc) {
            switch (cccc.length) {
                case 4:
                    var cp = (0x07 & cccc.charCodeAt(0)) << 18 | (0x3f & cccc.charCodeAt(1)) << 12 | (0x3f & cccc.charCodeAt(2)) << 6 | 0x3f & cccc.charCodeAt(3),
                        offset = cp - 0x10000;
                    return fromCharCode((offset >>> 10) + 0xD800) + fromCharCode((offset & 0x3FF) + 0xDC00);
                case 3:
                    return fromCharCode((0x0f & cccc.charCodeAt(0)) << 12 | (0x3f & cccc.charCodeAt(1)) << 6 | 0x3f & cccc.charCodeAt(2));
                default:
                    return fromCharCode((0x1f & cccc.charCodeAt(0)) << 6 | 0x3f & cccc.charCodeAt(1));
            }
        };
        var btou = function (b) {
            return b.replace(re_btou, cb_btou);
        };
        var cb_decode = function (cccc) {
            var len = cccc.length,
                padlen = len % 4,
                n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0) | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0) | (len > 2 ? b64tab[cccc.charAt(2)] << 6 : 0) | (len > 3 ? b64tab[cccc.charAt(3)] : 0),
                chars = [fromCharCode(n >>> 16), fromCharCode(n >>> 8 & 0xff), fromCharCode(n & 0xff)];
            chars.length -= [0, 0, 2, 1][padlen];
            return chars.join('');
        };
        var atob = global.atob ? function (a) {
            return global.atob(a);
        } : function (a) {
            return a.replace(/[\s\S]{1,4}/g, cb_decode);
        };
        var _decode = buffer ? function (a) {
            return (a.constructor === buffer.constructor ? a : new buffer(a, 'base64')).toString();
        } : function (a) {
            return btou(atob(a));
        };
        var decode = function (a) {
            return _decode(String(a).replace(/[-_]/g, function (m0) {
                return m0 == '-' ? '+' : '/';
            }).replace(/[^A-Za-z0-9\+\/]/g, ''));
        };
        var noConflict = function () {
            var Base64 = global.Base64;
            global.Base64 = _Base64;
            return Base64;
        };
        // export Base64
        global.Base64 = {
            VERSION: version,
            atob: atob,
            btoa: btoa,
            fromBase64: decode,
            toBase64: encode,
            utob: utob,
            encode: encode,
            encodeURI: encodeURI,
            btou: btou,
            decode: decode,
            noConflict: noConflict
        };
        // if ES5 is available, make Base64.extendString() available
        if (typeof Object.defineProperty === 'function') {
            var noEnum = function (v) {
                return { value: v, enumerable: false, writable: true, configurable: true };
            };
            global.Base64.extendString = function () {
                Object.defineProperty(String.prototype, 'fromBase64', noEnum(function () {
                    return decode(this);
                }));
                Object.defineProperty(String.prototype, 'toBase64', noEnum(function (urisafe) {
                    return encode(this, urisafe);
                }));
                Object.defineProperty(String.prototype, 'toBase64URI', noEnum(function () {
                    return encode(this, true);
                }));
            };
        }
        // that's it!
        if (global['Meteor']) {
            Base64 = global.Base64; // for normal export in Meteor.js
        }
    })(this);
    return module.exports;
});
System.registerDynamic("npm:source-map@0.5.6/lib/binary-search.js", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  exports.GREATEST_LOWER_BOUND = 1;
  exports.LEAST_UPPER_BOUND = 2;

  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   */
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the index of
    //      the next-closest element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element than the one we are searching for, so we return -1.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      // Found the element we are looking for.
      return mid;
    } else if (cmp > 0) {
      // Our needle is greater than aHaystack[mid].
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      }

      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (3) or (2) and return the appropriate thing.
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    } else {
      // Our needle is less than aHaystack[mid].
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }

      // we are in termination case (3) or (2) and return the appropriate thing.
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  }

  /**
   * This is an implementation of binary search which will always try and return
   * the index of the closest element if there is no exact hit. This is because
   * mappings between original and generated line/col pairs are single points,
   * and there is an implicit region between each of them, so a miss just means
   * that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
   */
  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }

    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
    if (index < 0) {
      return -1;
    }

    // We have found either the exact element, or the next-closest element than
    // the one we are searching for. However, there may be more than one such
    // element. Make sure we always return the smallest of these.
    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }
      --index;
    }

    return index;
  };
  return module.exports;
});
System.registerDynamic("npm:source-map@0.5.6/lib/quick-sort.js", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  // It turns out that some (most?) JavaScript engines don't self-host
  // `Array.prototype.sort`. This makes sense because C++ will likely remain
  // faster than JS when doing raw CPU-intensive sorting. However, when using a
  // custom comparator function, calling back and forth between the VM's C++ and
  // JIT'd JS is rather slow *and* loses JIT type information, resulting in
  // worse generated code for the comparator function than would be optimal. In
  // fact, when sorting with a comparator, these costs outweigh the benefits of
  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
  // a ~3500ms mean speed-up in `bench/bench.html`.

  /**
   * Swap the elements indexed by `x` and `y` in the array `ary`.
   *
   * @param {Array} ary
   *        The array.
   * @param {Number} x
   *        The index of the first item.
   * @param {Number} y
   *        The index of the second item.
   */
  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  }

  /**
   * Returns a random integer within the range `low .. high` inclusive.
   *
   * @param {Number} low
   *        The lower bound on the range.
   * @param {Number} high
   *        The upper bound on the range.
   */
  function randomIntInRange(low, high) {
    return Math.round(low + Math.random() * (high - low));
  }

  /**
   * The Quick Sort algorithm.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   * @param {Number} p
   *        Start index of the array
   * @param {Number} r
   *        End index of the array
   */
  function doQuickSort(ary, comparator, p, r) {
    // If our lower bound is less than our upper bound, we (1) partition the
    // array into two pieces and (2) recurse on each half. If it is not, this is
    // the empty array and our base case.

    if (p < r) {
      // (1) Partitioning.
      //
      // The partitioning chooses a pivot between `p` and `r` and moves all
      // elements that are less than or equal to the pivot to the before it, and
      // all the elements that are greater than it after it. The effect is that
      // once partition is done, the pivot is in the exact place it will be when
      // the array is put in sorted order, and it will not need to be moved
      // again. This runs in O(n) time.

      // Always choose a random pivot so that an input array which is reverse
      // sorted does not cause O(n^2) running time.
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;

      swap(ary, pivotIndex, r);
      var pivot = ary[r];

      // Immediately after `j` is incremented in this loop, the following hold
      // true:
      //
      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
      //
      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
      for (var j = p; j < r; j++) {
        if (comparator(ary[j], pivot) <= 0) {
          i += 1;
          swap(ary, i, j);
        }
      }

      swap(ary, i + 1, j);
      var q = i + 1;

      // (2) Recurse on each half.

      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  }

  /**
   * Sort the given array in-place with the given comparator function.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   */
  exports.quickSort = function (ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };
  return module.exports;
});
System.registerDynamic('npm:source-map@0.5.6/lib/source-map-consumer.js', ['./util', './binary-search', './array-set', './base64-vlq', './quick-sort'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var util = $__require('./util');
  var binarySearch = $__require('./binary-search');
  var ArraySet = $__require('./array-set').ArraySet;
  var base64VLQ = $__require('./base64-vlq');
  var quickSort = $__require('./quick-sort').quickSort;

  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap) : new BasicSourceMapConsumer(sourceMap);
  }

  SourceMapConsumer.fromSourceMap = function (aSourceMap) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
  };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer.prototype._version = 3;

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    get: function () {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });

  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    get: function () {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;

  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      if (source != null && sourceRoot != null) {
        source = util.join(sourceRoot, source);
      }
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

  /**
   * Returns all generated line and column information for the original source,
   * line, and column provided. If no column is provided, returns all mappings
   * corresponding to a either the line we are searching for or the next
   * closest line that has any mappings. Otherwise, returns all mappings
   * corresponding to the given line and either the column we are searching for
   * or the next closest column that has any offsets.
   *
   * The only argument is an object with the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: Optional. the column number in the original source.
   *
   * and an array of objects is returned, each with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    if (this.sourceRoot != null) {
      needle.source = util.relative(this.sourceRoot, needle.source);
    }
    if (!this._sources.has(needle.source)) {
      return [];
    }
    needle.source = this._sources.indexOf(needle.source);

    var mappings = [];

    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

  exports.SourceMapConsumer = SourceMapConsumer;

  /**
   * A BasicSourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The only parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: Optional. The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function BasicSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    sources = sources.map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
    });

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);

    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

  /**
   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @returns BasicSourceMapConsumer
   */
  BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
    smc.file = aSourceMap._file;

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping();
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  BasicSourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
      }, this);
    }
  });

  /**
   * Provide the JIT with a nice shape / hidden class.
   */
  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      } else if (aStr.charAt(index) === ',') {
        index++;
      } else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

  /**
   * Compute the last column for each generated mapping. The last column is
   * inclusive.
   */
  BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          if (this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
      return sc == null;
    });
  };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    if (this.sourceRoot != null) {
      aSource = util.relative(this.sourceRoot, aSource);
    }

    if (this._sources.has(aSource)) {
      return this.sourcesContent[this._sources.indexOf(aSource)];
    }

    var url;
    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
      if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }

      if ((!url.path || url.path == "/") && this._sources.has("/" + aSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    if (this.sourceRoot != null) {
      source = util.relative(this.sourceRoot, source);
    }
    if (!this._sources.has(source)) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    source = this._sources.indexOf(source);

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

  /**
   * An IndexedSourceMapConsumer instance represents a parsed source map which
   * we can query for information. It differs from BasicSourceMapConsumer in
   * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
   * input.
   *
   * The only parameter is a raw source map (either as a JSON string, or already
   * parsed to an object). According to the spec for indexed source maps, they
   * have the following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - file: Optional. The generated file this source map is associated with.
   *   - sections: A list of section definitions.
   *
   * Each value under the "sections" field has two fields:
   *   - offset: The offset into the original specified at which this section
   *       begins to apply, defined as an object with a "line" and "column"
   *       field.
   *   - map: A source map definition. This source map could also be indexed,
   *       but doesn't have to be.
   *
   * Instead of the "map" field, it's also possible to have a "url" field
   * specifying a URL to retrieve a source map from, but that's currently
   * unsupported.
   *
   * Here's an example source map, taken from the source map spec[0], but
   * modified to omit a section which uses the "url" field.
   *
   *  {
   *    version : 3,
   *    file: "app.js",
   *    sections: [{
   *      offset: {line:100, column:10},
   *      map: {
   *        version : 3,
   *        file: "section.js",
   *        sources: ["foo.js", "bar.js"],
   *        names: ["src", "maps", "are", "fun"],
   *        mappings: "AAAA,E;;ABCDE;"
   *      }
   *    }],
   *  }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
   */
  function IndexedSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sections = util.getArg(sourceMap, 'sections');

    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    this._sources = new ArraySet();
    this._names = new ArraySet();

    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function (s) {
      if (s.url) {
        // The url field will require support for asynchronicity.
        // See https://github.com/mozilla/source-map/issues/16
        throw new Error('Support for url field in sections not implemented.');
      }
      var offset = util.getArg(s, 'offset');
      var offsetLine = util.getArg(offset, 'line');
      var offsetColumn = util.getArg(offset, 'column');

      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
        throw new Error('Section offsets must be ordered and non-overlapping.');
      }
      lastOffset = offset;

      return {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util.getArg(s, 'map'))
      };
    });
  }

  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

  /**
   * The version of the source mapping spec that we are consuming.
   */
  IndexedSourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
    get: function () {
      var sources = [];
      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }
      return sources;
    }
  });

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
      var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
      if (cmp) {
        return cmp;
      }

      return needle.generatedColumn - section.generatedOffset.generatedColumn;
    });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    });
  };

  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        if (section.consumer.sourceRoot !== null) {
          source = util.join(section.consumer.sourceRoot, source);
        }
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = section.consumer._names.at(mapping.name);
        this._names.add(name);
        name = this._names.indexOf(name);

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  return module.exports;
});
System.registerDynamic('npm:source-map@0.5.6/lib/base64.js', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  exports.encode = function (number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
  };

  /**
   * Decode a single base 64 character code digit to an integer. Returns -1 on
   * failure.
   */
  exports.decode = function (charCode) {
    var bigA = 65; // 'A'
    var bigZ = 90; // 'Z'

    var littleA = 97; // 'a'
    var littleZ = 122; // 'z'

    var zero = 48; // '0'
    var nine = 57; // '9'

    var plus = 43; // '+'
    var slash = 47; // '/'

    var littleOffset = 26;
    var numberOffset = 52;

    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }

    // 26 - 51: abcdefghijklmnopqrstuvwxyz
    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }

    // 52 - 61: 0123456789
    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }

    // 62: +
    if (charCode == plus) {
      return 62;
    }

    // 63: /
    if (charCode == slash) {
      return 63;
    }

    // Invalid base64 digit.
    return -1;
  };
  return module.exports;
});
System.registerDynamic("npm:source-map@0.5.6/lib/base64-vlq.js", ["./base64"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   *
   * Based on the Base 64 VLQ implementation in Closure Compiler:
   * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
   *
   * Copyright 2011 The Closure Compiler Authors. All rights reserved.
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   *  * Redistributions of source code must retain the above copyright
   *    notice, this list of conditions and the following disclaimer.
   *  * Redistributions in binary form must reproduce the above
   *    copyright notice, this list of conditions and the following
   *    disclaimer in the documentation and/or other materials provided
   *    with the distribution.
   *  * Neither the name of Google Inc. nor the names of its
   *    contributors may be used to endorse or promote products derived
   *    from this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */

  var base64 = $__require("./base64");

  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5;

  // binary: 100000
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  // binary: 011111
  var VLQ_BASE_MASK = VLQ_BASE - 1;

  // binary: 100000
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  /**
   * Converts from a two-complement value to a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }

  /**
   * Converts to a two-complement value from a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }

  /**
   * Returns the base 64 VLQ encoded value.
   */
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;

    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string via the out parameter.
   */
  exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }

      digit = base64.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }

      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };
  return module.exports;
});
System.registerDynamic('npm:source-map@0.5.6/lib/array-set.js', ['./util'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var util = $__require('./util');
  var has = Object.prototype.hasOwnProperty;

  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */
  function ArraySet() {
    this._array = [];
    this._set = Object.create(null);
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };

  /**
   * Return how many unique items are in this ArraySet. If duplicates have been
   * added, than those do not count towards the size.
   *
   * @returns Number
   */
  ArraySet.prototype.size = function ArraySet_size() {
    return Object.getOwnPropertyNames(this._set).length;
  };

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = util.toSetString(aStr);
    var isDuplicate = has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      this._set[sStr] = idx;
    }
  };

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  };

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
  };

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  exports.ArraySet = ArraySet;
  return module.exports;
});
System.registerDynamic('npm:source-map@0.5.6/lib/mapping-list.js', ['./util'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2014 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var util = $__require('./util');

  /**
   * Determine whether mappingB is after mappingA with respect to generated
   * position.
   */
  function generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }

  /**
   * A data structure to provide a sorted view of accumulated mappings in a
   * performance conscious manner. It trades a neglibable overhead in general
   * case for a large speedup in case of mappings being added in order.
   */
  function MappingList() {
    this._array = [];
    this._sorted = true;
    // Serves as infimum
    this._last = { generatedLine: -1, generatedColumn: 0 };
  }

  /**
   * Iterate through internal items. This method takes the same arguments that
   * `Array.prototype.forEach` takes.
   *
   * NOTE: The order of the mappings is NOT guaranteed.
   */
  MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

  /**
   * Add the given source mapping.
   *
   * @param Object aMapping
   */
  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };

  /**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };

  exports.MappingList = MappingList;
  return module.exports;
});
System.registerDynamic('npm:source-map@0.5.6/lib/source-map-generator.js', ['./base64-vlq', './util', './array-set', './mapping-list'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var base64VLQ = $__require('./base64-vlq');
  var util = $__require('./util');
  var ArraySet = $__require('./array-set').ArraySet;
  var MappingList = $__require('./mapping-list').MappingList;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. You may pass an object with the following
   * properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: A root for all relative URLs in this source map.
   */
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }

  SourceMapGenerator.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */
  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }
    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      // Cases 2 and 3.
      return;
    } else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = '';

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      } else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

  exports.SourceMapGenerator = SourceMapGenerator;
  return module.exports;
});
System.registerDynamic('npm:source-map@0.5.6/lib/util.js', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;

  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = '';
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ':';
    }
    url += '//';
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + '@';
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;

  /**
   * Normalizes a path, or the path portion of a URL:
   *
   * - Replaces consecutive slashes with one slash.
   * - Removes unnecessary '.' parts.
   * - Removes unnecessary '<dir>/..' parts.
   *
   * Based on code in the Node.js 'path' core module.
   *
   * @param aPath The path or url to normalize.
   */
  function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = exports.isAbsolute(path);

    var parts = path.split(/\/+/);
    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];
      if (part === '.') {
        parts.splice(i, 1);
      } else if (part === '..') {
        up++;
      } else if (up > 0) {
        if (part === '') {
          // The first part is blank if the path is absolute. Trying to go
          // above the root is a no-op. Therefore we can remove all '..' parts
          // directly after the root.
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join('/');

    if (path === '') {
      path = isAbsolute ? '/' : '.';
    }

    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  }
  exports.normalize = normalize;

  /**
   * Joins two paths/URLs.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be joined with the root.
   *
   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
   *   first.
   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
   *   is updated with the result and aRoot is returned. Otherwise the result
   *   is returned.
   *   - If aPath is absolute, the result is aPath.
   *   - Otherwise the two paths are joined with a slash.
   * - Joining for example 'http://' and 'www.example.com' is also supported.
   */
  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || '/';
    }

    // `join(foo, '//www.example.org')`
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }

    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    // `join('http://', 'www.example.com')`
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }

    var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports.join = join;

  exports.isAbsolute = function (aPath) {
    return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
  };

  /**
   * Make a path relative to a URL or another path.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be made relative to aRoot.
   */
  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    aRoot = aRoot.replace(/\/$/, '');

    // It is possible for the path to be above the root. In this case, simply
    // checking whether the root is a prefix of the path won't work. Instead, we
    // need to remove components from the root one by one, until either we find
    // a prefix that fits, or we run out of components to remove.
    var level = 0;
    while (aPath.indexOf(aRoot + '/') !== 0) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0) {
        return aPath;
      }

      // If the only part of the root that is left is the scheme (i.e. http://,
      // file:///, etc.), one or more slashes (/), or simply nothing at all, we
      // have exhausted all components, so the path is not relative to the root.
      aRoot = aRoot.slice(0, index);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }

      ++level;
    }

    // Make sure we add a "../" for each component we removed from the root.
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  }
  exports.relative = relative;

  var supportsNullProto = function () {
    var obj = Object.create(null);
    return !('__proto__' in obj);
  }();

  function identity(s) {
    return s;
  }

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr) {
    if (isProtoString(aStr)) {
      return '$' + aStr;
    }

    return aStr;
  }
  exports.toSetString = supportsNullProto ? identity : toSetString;

  function fromSetString(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }

    return aStr;
  }
  exports.fromSetString = supportsNullProto ? identity : fromSetString;

  function isProtoString(s) {
    if (!s) {
      return false;
    }

    var length = s.length;

    if (length < 9 /* "__proto__".length */) {
        return false;
      }

    if (s.charCodeAt(length - 1) !== 95 /* '_' */ || s.charCodeAt(length - 2) !== 95 /* '_' */ || s.charCodeAt(length - 3) !== 111 /* 'o' */ || s.charCodeAt(length - 4) !== 116 /* 't' */ || s.charCodeAt(length - 5) !== 111 /* 'o' */ || s.charCodeAt(length - 6) !== 114 /* 'r' */ || s.charCodeAt(length - 7) !== 112 /* 'p' */ || s.charCodeAt(length - 8) !== 95 /* '_' */ || s.charCodeAt(length - 9) !== 95 /* '_' */) {
        return false;
      }

    for (var i = length - 10; i >= 0; i--) {
      if (s.charCodeAt(i) !== 36 /* '$' */) {
          return false;
        }
    }

    return true;
  }

  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = mappingA.source - mappingB.source;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    return mappingA.name - mappingB.name;
  }
  exports.compareByOriginalPositions = compareByOriginalPositions;

  /**
   * Comparator between two mappings with deflated source and name indices where
   * the generated positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }

    cmp = mappingA.source - mappingB.source;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }

    return mappingA.name - mappingB.name;
  }
  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

  function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }

    if (aStr1 > aStr2) {
      return 1;
    }

    return -1;
  }

  /**
   * Comparator between two mappings with inflated source and name strings where
   * the generated positions are compared.
   */
  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  return module.exports;
});
System.registerDynamic('npm:source-map@0.5.6/lib/source-node.js', ['./source-map-generator', './util'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var SourceMapGenerator = $__require('./source-map-generator').SourceMapGenerator;
  var util = $__require('./util');

  // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
  // operating systems these days (capturing the result).
  var REGEX_NEWLINE = /(\r?\n)/;

  // Newline character code for charCodeAt() comparisons
  var NEWLINE_CODE = 10;

  // Private symbol for identifying `SourceNode`s when multiple versions of
  // the source-map library are loaded. This MUST NOT CHANGE across
  // versions!
  var isSourceNode = "$$$isSourceNode$$$";

  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   * @param aRelativePath Optional. The path that relative sources in the
   *        SourceMapConsumer should be relative to.
   */
  SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are removed from this array, by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var shiftNextLine = function () {
      var lineContents = remainingLines.shift();
      // The last line of a file might not have a newline.
      var newLine = remainingLines.shift() || "";
      return lineContents + newLine;
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1,
        lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[0];
          var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
          remainingLines[0] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[0];
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[0] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLines.length > 0) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
        node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
      }
    }
  };

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length - 1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else {
        if (chunk !== '') {
          aFn(chunk, { source: this.source,
            line: this.line,
            column: this.column,
            name: this.name });
        }
      }
    }
  };

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
      this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
  };

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null && original.line !== null && original.column !== null) {
        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          // Mappings end at eol
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });

    return { code: generated.code, map: map };
  };

  exports.SourceNode = SourceNode;
  return module.exports;
});
System.registerDynamic("npm:source-map@0.5.6.json", [], false, function() {
  return {
    "main": "source-map.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic('npm:source-map@0.5.6/source-map.js', ['./lib/source-map-generator', './lib/source-map-consumer', './lib/source-node'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /*
   * Copyright 2009-2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE.txt or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  exports.SourceMapGenerator = $__require('./lib/source-map-generator').SourceMapGenerator;
  exports.SourceMapConsumer = $__require('./lib/source-map-consumer').SourceMapConsumer;
  exports.SourceNode = $__require('./lib/source-node').SourceNode;
  return module.exports;
});
System.registerDynamic("npm:jspm-nodelibs-fs@0.2.0.json", [], false, function() {
  return {
    "main": "./fs.js"
  };
});

System.registerDynamic('npm:jspm-nodelibs-fs@0.2.0/fs.js', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  exports.readFileSync = function (address) {
    var output;
    var xhr = new XMLHttpRequest();
    xhr.open('GET', address, false);
    xhr.onreadystatechange = function (e) {
      if (xhr.readyState == 4) {
        var status = xhr.status;
        if (status > 399 && status < 600 || status == 400) {
          throw 'File read error on ' + xhr.responseURL;
        } else output = xhr.responseText;
      }
    };
    xhr.send(null);
    return output;
  };
  return module.exports;
});
System.registerDynamic("npm:postcss@5.2.6/lib/previous-map.js", ["js-base64", "source-map", "path", "fs", "process"], true, function ($__require, exports, module) {
    'use strict';

    var process = $__require("process");
    var define,
        global = this || self,
        GLOBAL = global;
    exports.__esModule = true;

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
        return typeof obj;
    } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    var _jsBase = $__require("js-base64");

    var _sourceMap = $__require("source-map");

    var _sourceMap2 = _interopRequireDefault(_sourceMap);

    var _path = $__require("path");

    var _path2 = _interopRequireDefault(_path);

    var _fs = $__require("fs");

    var _fs2 = _interopRequireDefault(_fs);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    /**
     * Source map information from input CSS.
     * For example, source map after Sass compiler.
     *
     * This class will automatically find source map in input CSS or in file system
     * near input file (according `from` option).
     *
     * @example
     * const root = postcss.parse(css, { from: 'a.sass.css' });
     * root.input.map //=> PreviousMap
     */
    var PreviousMap = function () {

        /**
         * @param {string}         css    - input CSS source
         * @param {processOptions} [opts] - {@link Processor#process} options
         */
        function PreviousMap(css, opts) {
            _classCallCheck(this, PreviousMap);

            this.loadAnnotation(css);
            /**
             * @member {boolean} - Was source map inlined by data-uri to input CSS.
             */
            this.inline = this.startWith(this.annotation, 'data:');

            var prev = opts.map ? opts.map.prev : undefined;
            var text = this.loadMap(opts.from, prev);
            if (text) this.text = text;
        }

        /**
         * Create a instance of `SourceMapGenerator` class
         * from the `source-map` library to work with source map information.
         *
         * It is lazy method, so it will create object only on first call
         * and then it will use cache.
         *
         * @return {SourceMapGenerator} object with source map information
         */

        PreviousMap.prototype.consumer = function consumer() {
            if (!this.consumerCache) {
                this.consumerCache = new _sourceMap2.default.SourceMapConsumer(this.text);
            }
            return this.consumerCache;
        };

        /**
         * Does source map contains `sourcesContent` with input source text.
         *
         * @return {boolean} Is `sourcesContent` present
         */

        PreviousMap.prototype.withContent = function withContent() {
            return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
        };

        PreviousMap.prototype.startWith = function startWith(string, start) {
            if (!string) return false;
            return string.substr(0, start.length) === start;
        };

        PreviousMap.prototype.loadAnnotation = function loadAnnotation(css) {
            var match = css.match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//);
            if (match) this.annotation = match[1].trim();
        };

        PreviousMap.prototype.decodeInline = function decodeInline(text) {
            var utfd64 = 'data:application/json;charset=utf-8;base64,';
            var utf64 = 'data:application/json;charset=utf8;base64,';
            var b64 = 'data:application/json;base64,';
            var uri = 'data:application/json,';

            if (this.startWith(text, uri)) {
                return decodeURIComponent(text.substr(uri.length));
            } else if (this.startWith(text, b64)) {
                return _jsBase.Base64.decode(text.substr(b64.length));
            } else if (this.startWith(text, utf64)) {
                return _jsBase.Base64.decode(text.substr(utf64.length));
            } else if (this.startWith(text, utfd64)) {
                return _jsBase.Base64.decode(text.substr(utfd64.length));
            } else {
                var encoding = text.match(/data:application\/json;([^,]+),/)[1];
                throw new Error('Unsupported source map encoding ' + encoding);
            }
        };

        PreviousMap.prototype.loadMap = function loadMap(file, prev) {
            if (prev === false) return false;

            if (prev) {
                if (typeof prev === 'string') {
                    return prev;
                } else if (typeof prev === 'function') {
                    var prevPath = prev(file);
                    if (prevPath && _fs2.default.existsSync && _fs2.default.existsSync(prevPath)) {
                        return _fs2.default.readFileSync(prevPath, 'utf-8').toString().trim();
                    } else {
                        throw new Error('Unable to load previous source map: ' + prevPath.toString());
                    }
                } else if (prev instanceof _sourceMap2.default.SourceMapConsumer) {
                    return _sourceMap2.default.SourceMapGenerator.fromSourceMap(prev).toString();
                } else if (prev instanceof _sourceMap2.default.SourceMapGenerator) {
                    return prev.toString();
                } else if (this.isMap(prev)) {
                    return JSON.stringify(prev);
                } else {
                    throw new Error('Unsupported previous source map format: ' + prev.toString());
                }
            } else if (this.inline) {
                return this.decodeInline(this.annotation);
            } else if (this.annotation) {
                var map = this.annotation;
                if (file) map = _path2.default.join(_path2.default.dirname(file), map);

                this.root = _path2.default.dirname(map);
                if (_fs2.default.existsSync && _fs2.default.existsSync(map)) {
                    return _fs2.default.readFileSync(map, 'utf-8').toString().trim();
                } else {
                    return false;
                }
            }
        };

        PreviousMap.prototype.isMap = function isMap(map) {
            if ((typeof map === 'undefined' ? 'undefined' : _typeof(map)) !== 'object') return false;
            return typeof map.mappings === 'string' || typeof map._mappings === 'string';
        };

        return PreviousMap;
    }();

    exports.default = PreviousMap;
    module.exports = exports['default'];
    return module.exports;
});
System.registerDynamic("npm:jspm-nodelibs-path@0.2.1.json", [], false, function() {
  return {
    "main": "./path.js"
  };
});

System.registerDynamic('npm:jspm-nodelibs-path@0.2.1/path.js', ['process'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.

  // resolves . and .. elements in a path array with directory names there
  // must be no slashes, empty elements, or device names (c:\) in the array
  // (so also no leading and trailing slashes - it does not distinguish
  // relative and absolute paths)
  var process = $__require('process');

  function normalizeArray(parts, allowAboveRoot) {
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for (var i = parts.length - 1; i >= 0; i--) {
      var last = parts[i];
      if (last === '.') {
        parts.splice(i, 1);
      } else if (last === '..') {
        parts.splice(i, 1);
        up++;
      } else if (up) {
        parts.splice(i, 1);
        up--;
      }
    }

    // if the path is allowed to go above the root, restore leading ..s
    if (allowAboveRoot) {
      for (; up--; up) {
        parts.unshift('..');
      }
    }

    return parts;
  }

  // Split a filename into [root, dir, basename, ext], unix version
  // 'root' is just a slash, or nothing.
  var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
  var splitPath = function (filename) {
    return splitPathRe.exec(filename).slice(1);
  };

  // path.resolve([from ...], to)
  // posix version
  exports.resolve = function () {
    var resolvedPath = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path = i >= 0 ? arguments[i] : process.cwd();

      // Skip empty and invalid entries
      if (typeof path !== 'string') {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charAt(0) === '/';
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
      return !!p;
    }), !resolvedAbsolute).join('/');

    return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
  };

  // path.normalize(path)
  // posix version
  exports.normalize = function (path) {
    var isAbsolute = exports.isAbsolute(path),
        trailingSlash = substr(path, -1) === '/';

    // Normalize the path
    path = normalizeArray(filter(path.split('/'), function (p) {
      return !!p;
    }), !isAbsolute).join('/');

    if (!path && !isAbsolute) {
      path = '.';
    }
    if (path && trailingSlash) {
      path += '/';
    }

    return (isAbsolute ? '/' : '') + path;
  };

  // posix version
  exports.isAbsolute = function (path) {
    return path.charAt(0) === '/';
  };

  // posix version
  exports.join = function () {
    var paths = Array.prototype.slice.call(arguments, 0);
    return exports.normalize(filter(paths, function (p, index) {
      if (typeof p !== 'string') {
        throw new TypeError('Arguments to path.join must be strings');
      }
      return p;
    }).join('/'));
  };

  // path.relative(from, to)
  // posix version
  exports.relative = function (from, to) {
    from = exports.resolve(from).substr(1);
    to = exports.resolve(to).substr(1);

    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }

      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }

      if (start > end) return [];
      return arr.slice(start, end - start + 1);
    }

    var fromParts = trim(from.split('/'));
    var toParts = trim(to.split('/'));

    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (fromParts[i] !== toParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    var outputParts = [];
    for (var i = samePartsLength; i < fromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));

    return outputParts.join('/');
  };

  exports.sep = '/';
  exports.delimiter = ':';

  exports.dirname = function (path) {
    var result = splitPath(path),
        root = result[0],
        dir = result[1];

    if (!root && !dir) {
      // No dirname whatsoever
      return '.';
    }

    if (dir) {
      // It has a dirname, strip trailing slash
      dir = dir.substr(0, dir.length - 1);
    }

    return root + dir;
  };

  exports.basename = function (path, ext) {
    var f = splitPath(path)[2];
    // TODO: make this comparison case-insensitive on windows?
    if (ext && f.substr(-1 * ext.length) === ext) {
      f = f.substr(0, f.length - ext.length);
    }
    return f;
  };

  exports.extname = function (path) {
    return splitPath(path)[3];
  };

  function filter(xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
      if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
  }

  // String.prototype.substr - negative index don't work in IE8
  var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
    return str.substr(start, len);
  } : function (str, start, len) {
    if (start < 0) start = str.length + start;
    return str.substr(start, len);
  };
  return module.exports;
});
System.registerDynamic('npm:postcss@5.2.6/lib/input.js', ['./css-syntax-error', './previous-map', 'path', 'process'], true, function ($__require, exports, module) {
    'use strict';

    var process = $__require('process');
    var define,
        global = this || self,
        GLOBAL = global;
    exports.__esModule = true;

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
        }return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
    }();

    var _cssSyntaxError = $__require('./css-syntax-error');

    var _cssSyntaxError2 = _interopRequireDefault(_cssSyntaxError);

    var _previousMap = $__require('./previous-map');

    var _previousMap2 = _interopRequireDefault(_previousMap);

    var _path = $__require('path');

    var _path2 = _interopRequireDefault(_path);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var sequence = 0;

    /**
     * Represents the source CSS.
     *
     * @example
     * const root  = postcss.parse(css, { from: file });
     * const input = root.source.input;
     */

    var Input = function () {

        /**
         * @param {string} css    - input CSS source
         * @param {object} [opts] - {@link Processor#process} options
         */
        function Input(css) {
            var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            _classCallCheck(this, Input);

            /**
             * @member {string} - input CSS source
             *
             * @example
             * const input = postcss.parse('a{}', { from: file }).input;
             * input.css //=> "a{}";
             */
            this.css = css.toString();

            if (this.css[0] === '\uFEFF' || this.css[0] === '\uFFFE') {
                this.css = this.css.slice(1);
            }

            if (opts.from) {
                if (/^\w+:\/\//.test(opts.from)) {
                    /**
                     * @member {string} - The absolute path to the CSS source file
                     *                    defined with the `from` option.
                     *
                     * @example
                     * const root = postcss.parse(css, { from: 'a.css' });
                     * root.source.input.file //=> '/home/ai/a.css'
                     */
                    this.file = opts.from;
                } else {
                    this.file = _path2.default.resolve(opts.from);
                }
            }

            var map = new _previousMap2.default(this.css, opts);
            if (map.text) {
                /**
                 * @member {PreviousMap} - The input source map passed from
                 *                         a compilation step before PostCSS
                 *                         (for example, from Sass compiler).
                 *
                 * @example
                 * root.source.input.map.consumer().sources //=> ['a.sass']
                 */
                this.map = map;
                var file = map.consumer().file;
                if (!this.file && file) this.file = this.mapResolve(file);
            }

            if (!this.file) {
                sequence += 1;
                /**
                 * @member {string} - The unique ID of the CSS source. It will be
                 *                    created if `from` option is not provided
                 *                    (because PostCSS does not know the file path).
                 *
                 * @example
                 * const root = postcss.parse(css);
                 * root.source.input.file //=> undefined
                 * root.source.input.id   //=> "<input css 1>"
                 */
                this.id = '<input css ' + sequence + '>';
            }
            if (this.map) this.map.file = this.from;
        }

        Input.prototype.error = function error(message, line, column) {
            var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

            var result = void 0;
            var origin = this.origin(line, column);
            if (origin) {
                result = new _cssSyntaxError2.default(message, origin.line, origin.column, origin.source, origin.file, opts.plugin);
            } else {
                result = new _cssSyntaxError2.default(message, line, column, this.css, this.file, opts.plugin);
            }

            result.input = { line: line, column: column, source: this.css };
            if (this.file) result.input.file = this.file;

            return result;
        };

        /**
         * Reads the input source map and returns a symbol position
         * in the input source (e.g., in a Sass file that was compiled
         * to CSS before being passed to PostCSS).
         *
         * @param {number} line   - line in input CSS
         * @param {number} column - column in input CSS
         *
         * @return {filePosition} position in input source
         *
         * @example
         * root.source.input.origin(1, 1) //=> { file: 'a.css', line: 3, column: 1 }
         */

        Input.prototype.origin = function origin(line, column) {
            if (!this.map) return false;
            var consumer = this.map.consumer();

            var from = consumer.originalPositionFor({ line: line, column: column });
            if (!from.source) return false;

            var result = {
                file: this.mapResolve(from.source),
                line: from.line,
                column: from.column
            };

            var source = consumer.sourceContentFor(from.source);
            if (source) result.source = source;

            return result;
        };

        Input.prototype.mapResolve = function mapResolve(file) {
            if (/^\w+:\/\//.test(file)) {
                return file;
            } else {
                return _path2.default.resolve(this.map.consumer().sourceRoot || '.', file);
            }
        };

        /**
         * The CSS source identifier. Contains {@link Input#file} if the user
         * set the `from` option, or {@link Input#id} if they did not.
         * @type {string}
         *
         * @example
         * const root = postcss.parse(css, { from: 'a.css' });
         * root.source.input.from //=> "/home/ai/a.css"
         *
         * const root = postcss.parse(css);
         * root.source.input.from //=> "<input css 1>"
         */

        _createClass(Input, [{
            key: 'from',
            get: function get() {
                return this.file || this.id;
            }
        }]);

        return Input;
    }();

    exports.default = Input;

    /**
     * @typedef  {object} filePosition
     * @property {string} file   - path to file
     * @property {number} line   - source line in file
     * @property {number} column - source column in file
     */

    module.exports = exports['default'];
    return module.exports;
});
System.registerDynamic('npm:postcss@5.2.6/lib/parse.js', ['./parser', './input', 'process'], true, function ($__require, exports, module) {
    'use strict';

    var process = $__require('process');
    var define,
        global = this || self,
        GLOBAL = global;
    exports.__esModule = true;
    exports.default = parse;

    var _parser = $__require('./parser');

    var _parser2 = _interopRequireDefault(_parser);

    var _input = $__require('./input');

    var _input2 = _interopRequireDefault(_input);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }

    function parse(css, opts) {
        if (opts && opts.safe) {
            throw new Error('Option safe was removed. ' + 'Use parser: require("postcss-safe-parser")');
        }

        var input = new _input2.default(css, opts);

        var parser = new _parser2.default(input);
        try {
            parser.tokenize();
            parser.loop();
        } catch (e) {
            if (e.name === 'CssSyntaxError' && opts && opts.from) {
                if (/\.scss$/i.test(opts.from)) {
                    e.message += '\nYou tried to parse SCSS with ' + 'the standard CSS parser; ' + 'try again with the postcss-scss parser';
                } else if (/\.less$/i.test(opts.from)) {
                    e.message += '\nYou tried to parse Less with ' + 'the standard CSS parser; ' + 'try again with the postcss-less parser';
                }
            }
            throw e;
        }

        return parser.root;
    }
    module.exports = exports['default'];
    return module.exports;
});
System.registerDynamic("npm:postcss@5.2.6/lib/lazy-result.js", ["./map-generator", "./stringify", "./warn-once", "./result", "./parse", "process"], true, function ($__require, exports, module) {
    'use strict';

    var process = $__require("process");
    var define,
        global = this || self,
        GLOBAL = global;
    exports.__esModule = true;

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
        }return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
    }();

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
        return typeof obj;
    } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    var _mapGenerator = $__require("./map-generator");

    var _mapGenerator2 = _interopRequireDefault(_mapGenerator);

    var _stringify2 = $__require("./stringify");

    var _stringify3 = _interopRequireDefault(_stringify2);

    var _warnOnce = $__require("./warn-once");

    var _warnOnce2 = _interopRequireDefault(_warnOnce);

    var _result = $__require("./result");

    var _result2 = _interopRequireDefault(_result);

    var _parse = $__require("./parse");

    var _parse2 = _interopRequireDefault(_parse);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    function isPromise(obj) {
        return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && typeof obj.then === 'function';
    }

    /**
     * A Promise proxy for the result of PostCSS transformations.
     *
     * A `LazyResult` instance is returned by {@link Processor#process}.
     *
     * @example
     * const lazy = postcss([cssnext]).process(css);
     */

    var LazyResult = function () {
        function LazyResult(processor, css, opts) {
            _classCallCheck(this, LazyResult);

            this.stringified = false;
            this.processed = false;

            var root = void 0;
            if ((typeof css === 'undefined' ? 'undefined' : _typeof(css)) === 'object' && css.type === 'root') {
                root = css;
            } else if (css instanceof LazyResult || css instanceof _result2.default) {
                root = css.root;
                if (css.map) {
                    if (typeof opts.map === 'undefined') opts.map = {};
                    if (!opts.map.inline) opts.map.inline = false;
                    opts.map.prev = css.map;
                }
            } else {
                var parser = _parse2.default;
                if (opts.syntax) parser = opts.syntax.parse;
                if (opts.parser) parser = opts.parser;
                if (parser.parse) parser = parser.parse;

                try {
                    root = parser(css, opts);
                } catch (error) {
                    this.error = error;
                }
            }

            this.result = new _result2.default(processor, root, opts);
        }

        /**
         * Returns a {@link Processor} instance, which will be used
         * for CSS transformations.
         * @type {Processor}
         */

        /**
         * Processes input CSS through synchronous plugins
         * and calls {@link Result#warnings()}.
         *
         * @return {Warning[]} warnings from plugins
         */
        LazyResult.prototype.warnings = function warnings() {
            return this.sync().warnings();
        };

        /**
         * Alias for the {@link LazyResult#css} property.
         *
         * @example
         * lazy + '' === lazy.css;
         *
         * @return {string} output CSS
         */

        LazyResult.prototype.toString = function toString() {
            return this.css;
        };

        /**
         * Processes input CSS through synchronous and asynchronous plugins
         * and calls `onFulfilled` with a Result instance. If a plugin throws
         * an error, the `onRejected` callback will be executed.
         *
         * It implements standard Promise API.
         *
         * @param {onFulfilled} onFulfilled - callback will be executed
         *                                    when all plugins will finish work
         * @param {onRejected}  onRejected  - callback will be executed on any error
         *
         * @return {Promise} Promise API to make queue
         *
         * @example
         * postcss([cssnext]).process(css).then(result => {
         *   console.log(result.css);
         * });
         */

        LazyResult.prototype.then = function then(onFulfilled, onRejected) {
            return this.async().then(onFulfilled, onRejected);
        };

        /**
         * Processes input CSS through synchronous and asynchronous plugins
         * and calls onRejected for each error thrown in any plugin.
         *
         * It implements standard Promise API.
         *
         * @param {onRejected} onRejected - callback will be executed on any error
         *
         * @return {Promise} Promise API to make queue
         *
         * @example
         * postcss([cssnext]).process(css).then(result => {
         *   console.log(result.css);
         * }).catch(error => {
         *   console.error(error);
         * });
         */

        LazyResult.prototype.catch = function _catch(onRejected) {
            return this.async().catch(onRejected);
        };

        LazyResult.prototype.handleError = function handleError(error, plugin) {
            try {
                this.error = error;
                if (error.name === 'CssSyntaxError' && !error.plugin) {
                    error.plugin = plugin.postcssPlugin;
                    error.setMessage();
                } else if (plugin.postcssVersion) {
                    var pluginName = plugin.postcssPlugin;
                    var pluginVer = plugin.postcssVersion;
                    var runtimeVer = this.result.processor.version;
                    var a = pluginVer.split('.');
                    var b = runtimeVer.split('.');

                    if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
                        (0, _warnOnce2.default)('Your current PostCSS version ' + 'is ' + runtimeVer + ', but ' + pluginName + ' ' + 'uses ' + pluginVer + '. Perhaps this is ' + 'the source of the error below.');
                    }
                }
            } catch (err) {
                if (console && console.error) console.error(err);
            }
        };

        LazyResult.prototype.asyncTick = function asyncTick(resolve, reject) {
            var _this = this;

            if (this.plugin >= this.processor.plugins.length) {
                this.processed = true;
                return resolve();
            }

            try {
                (function () {
                    var plugin = _this.processor.plugins[_this.plugin];
                    var promise = _this.run(plugin);
                    _this.plugin += 1;

                    if (isPromise(promise)) {
                        promise.then(function () {
                            _this.asyncTick(resolve, reject);
                        }).catch(function (error) {
                            _this.handleError(error, plugin);
                            _this.processed = true;
                            reject(error);
                        });
                    } else {
                        _this.asyncTick(resolve, reject);
                    }
                })();
            } catch (error) {
                this.processed = true;
                reject(error);
            }
        };

        LazyResult.prototype.async = function async() {
            var _this2 = this;

            if (this.processed) {
                return new Promise(function (resolve, reject) {
                    if (_this2.error) {
                        reject(_this2.error);
                    } else {
                        resolve(_this2.stringify());
                    }
                });
            }
            if (this.processing) {
                return this.processing;
            }

            this.processing = new Promise(function (resolve, reject) {
                if (_this2.error) return reject(_this2.error);
                _this2.plugin = 0;
                _this2.asyncTick(resolve, reject);
            }).then(function () {
                _this2.processed = true;
                return _this2.stringify();
            });

            return this.processing;
        };

        LazyResult.prototype.sync = function sync() {
            if (this.processed) return this.result;
            this.processed = true;

            if (this.processing) {
                throw new Error('Use process(css).then(cb) to work with async plugins');
            }

            if (this.error) throw this.error;

            for (var _iterator = this.result.processor.plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var plugin = _ref;

                var promise = this.run(plugin);
                if (isPromise(promise)) {
                    throw new Error('Use process(css).then(cb) to work with async plugins');
                }
            }

            return this.result;
        };

        LazyResult.prototype.run = function run(plugin) {
            this.result.lastPlugin = plugin;

            try {
                return plugin(this.result.root, this.result);
            } catch (error) {
                this.handleError(error, plugin);
                throw error;
            }
        };

        LazyResult.prototype.stringify = function stringify() {
            if (this.stringified) return this.result;
            this.stringified = true;

            this.sync();

            var opts = this.result.opts;
            var str = _stringify3.default;
            if (opts.syntax) str = opts.syntax.stringify;
            if (opts.stringifier) str = opts.stringifier;
            if (str.stringify) str = str.stringify;

            var map = new _mapGenerator2.default(str, this.result.root, this.result.opts);
            var data = map.generate();
            this.result.css = data[0];
            this.result.map = data[1];

            return this.result;
        };

        _createClass(LazyResult, [{
            key: 'processor',
            get: function get() {
                return this.result.processor;
            }

            /**
             * Options from the {@link Processor#process} call.
             * @type {processOptions}
             */

        }, {
            key: 'opts',
            get: function get() {
                return this.result.opts;
            }

            /**
             * Processes input CSS through synchronous plugins, converts `Root`
             * to a CSS string and returns {@link Result#css}.
             *
             * This property will only work with synchronous plugins.
             * If the processor contains any asynchronous plugins
             * it will throw an error. This is why this method is only
             * for debug purpose, you should always use {@link LazyResult#then}.
             *
             * @type {string}
             * @see Result#css
             */

        }, {
            key: 'css',
            get: function get() {
                return this.stringify().css;
            }

            /**
             * An alias for the `css` property. Use it with syntaxes
             * that generate non-CSS output.
             *
             * This property will only work with synchronous plugins.
             * If the processor contains any asynchronous plugins
             * it will throw an error. This is why this method is only
             * for debug purpose, you should always use {@link LazyResult#then}.
             *
             * @type {string}
             * @see Result#content
             */

        }, {
            key: 'content',
            get: function get() {
                return this.stringify().content;
            }

            /**
             * Processes input CSS through synchronous plugins
             * and returns {@link Result#map}.
             *
             * This property will only work with synchronous plugins.
             * If the processor contains any asynchronous plugins
             * it will throw an error. This is why this method is only
             * for debug purpose, you should always use {@link LazyResult#then}.
             *
             * @type {SourceMapGenerator}
             * @see Result#map
             */

        }, {
            key: 'map',
            get: function get() {
                return this.stringify().map;
            }

            /**
             * Processes input CSS through synchronous plugins
             * and returns {@link Result#root}.
             *
             * This property will only work with synchronous plugins. If the processor
             * contains any asynchronous plugins it will throw an error.
             *
             * This is why this method is only for debug purpose,
             * you should always use {@link LazyResult#then}.
             *
             * @type {Root}
             * @see Result#root
             */

        }, {
            key: 'root',
            get: function get() {
                return this.sync().root;
            }

            /**
             * Processes input CSS through synchronous plugins
             * and returns {@link Result#messages}.
             *
             * This property will only work with synchronous plugins. If the processor
             * contains any asynchronous plugins it will throw an error.
             *
             * This is why this method is only for debug purpose,
             * you should always use {@link LazyResult#then}.
             *
             * @type {Message[]}
             * @see Result#messages
             */

        }, {
            key: 'messages',
            get: function get() {
                return this.sync().messages;
            }
        }]);

        return LazyResult;
    }();

    exports.default = LazyResult;

    /**
     * @callback onFulfilled
     * @param {Result} result
     */

    /**
     * @callback onRejected
     * @param {Error} error
     */

    module.exports = exports['default'];
    return module.exports;
});
System.registerDynamic("npm:postcss@5.2.6/lib/processor.js", ["./lazy-result", "process"], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var _lazyResult = $__require("./lazy-result");

  var _lazyResult2 = _interopRequireDefault(_lazyResult);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * Contains plugins to process CSS. Create one `Processor` instance,
   * initialize its plugins, and then use that instance on numerous CSS files.
   *
   * @example
   * const processor = postcss([autoprefixer, precss]);
   * processor.process(css1).then(result => console.log(result.css));
   * processor.process(css2).then(result => console.log(result.css));
   */
  var Processor = function () {

    /**
     * @param {Array.<Plugin|pluginFunction>|Processor} plugins - PostCSS
     *        plugins. See {@link Processor#use} for plugin format.
     */
    function Processor() {
      var plugins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      _classCallCheck(this, Processor);

      /**
       * @member {string} - Current PostCSS version.
       *
       * @example
       * if ( result.processor.version.split('.')[0] !== '5' ) {
       *   throw new Error('This plugin works only with PostCSS 5');
       * }
       */
      this.version = '5.2.6';
      /**
       * @member {pluginFunction[]} - Plugins added to this processor.
       *
       * @example
       * const processor = postcss([autoprefixer, precss]);
       * processor.plugins.length //=> 2
       */
      this.plugins = this.normalize(plugins);
    }

    /**
     * Adds a plugin to be used as a CSS processor.
     *
     * PostCSS plugin can be in 4 formats:
     * * A plugin created by {@link postcss.plugin} method.
     * * A function. PostCSS will pass the function a @{link Root}
     *   as the first argument and current {@link Result} instance
     *   as the second.
     * * An object with a `postcss` method. PostCSS will use that method
     *   as described in #2.
     * * Another {@link Processor} instance. PostCSS will copy plugins
     *   from that instance into this one.
     *
     * Plugins can also be added by passing them as arguments when creating
     * a `postcss` instance (see [`postcss(plugins)`]).
     *
     * Asynchronous plugins should return a `Promise` instance.
     *
     * @param {Plugin|pluginFunction|Processor} plugin - PostCSS plugin
     *                                                   or {@link Processor}
     *                                                   with plugins
     *
     * @example
     * const processor = postcss()
     *   .use(autoprefixer)
     *   .use(precss);
     *
     * @return {Processes} current processor to make methods chain
     */

    Processor.prototype.use = function use(plugin) {
      this.plugins = this.plugins.concat(this.normalize([plugin]));
      return this;
    };

    /**
     * Parses source CSS and returns a {@link LazyResult} Promise proxy.
     * Because some plugins can be asynchronous it doesn’t make
     * any transformations. Transformations will be applied
     * in the {@link LazyResult} methods.
     *
     * @param {string|toString|Result} css - String with input CSS or
     *                                       any object with a `toString()`
     *                                       method, like a Buffer.
     *                                       Optionally, send a {@link Result}
     *                                       instance and the processor will
     *                                       take the {@link Root} from it.
     * @param {processOptions} [opts]      - options
     *
     * @return {LazyResult} Promise proxy
     *
     * @example
     * processor.process(css, { from: 'a.css', to: 'a.out.css' })
     *   .then(result => {
     *      console.log(result.css);
     *   });
     */

    Processor.prototype.process = function process(css) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      return new _lazyResult2.default(this, css, opts);
    };

    Processor.prototype.normalize = function normalize(plugins) {
      var normalized = [];
      for (var _iterator = plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var i = _ref;

        if (i.postcss) i = i.postcss;

        if ((typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object' && Array.isArray(i.plugins)) {
          normalized = normalized.concat(i.plugins);
        } else if (typeof i === 'function') {
          normalized.push(i);
        } else {
          throw new Error(i + ' is not a PostCSS plugin');
        }
      }
      return normalized;
    };

    return Processor;
  }();

  exports.default = Processor;

  /**
   * @callback builder
   * @param {string} part          - part of generated CSS connected to this node
   * @param {Node}   node          - AST node
   * @param {"start"|"end"} [type] - node’s part type
   */

  /**
   * @callback parser
   *
   * @param {string|toString} css   - string with input CSS or any object
   *                                  with toString() method, like a Buffer
   * @param {processOptions} [opts] - options with only `from` and `map` keys
   *
   * @return {Root} PostCSS AST
   */

  /**
   * @callback stringifier
   *
   * @param {Node} node       - start node for stringifing. Usually {@link Root}.
   * @param {builder} builder - function to concatenate CSS from node’s parts
   *                            or generate string and source map
   *
   * @return {void}
   */

  /**
   * @typedef {object} syntax
   * @property {parser} parse          - function to generate AST by string
   * @property {stringifier} stringify - function to generate string by AST
   */

  /**
   * @typedef {object} toString
   * @property {function} toString
   */

  /**
   * @callback pluginFunction
   * @param {Root} root     - parsed input CSS
   * @param {Result} result - result to set warnings or check other plugins
   */

  /**
   * @typedef {object} Plugin
   * @property {function} postcss - PostCSS plugin function
   */

  /**
   * @typedef {object} processOptions
   * @property {string} from             - the path of the CSS source file.
   *                                       You should always set `from`,
   *                                       because it is used in source map
   *                                       generation and syntax error messages.
   * @property {string} to               - the path where you’ll put the output
   *                                       CSS file. You should always set `to`
   *                                       to generate correct source maps.
   * @property {parser} parser           - function to generate AST by string
   * @property {stringifier} stringifier - class to generate string by AST
   * @property {syntax} syntax           - object with `parse` and `stringify`
   * @property {object} map              - source map options
   * @property {boolean} map.inline                    - does source map should
   *                                                     be embedded in the output
   *                                                     CSS as a base64-encoded
   *                                                     comment
   * @property {string|object|false|function} map.prev - source map content
   *                                                     from a previous
   *                                                     processing step
   *                                                     (for example, Sass).
   *                                                     PostCSS will try to find
   *                                                     previous map
   *                                                     automatically, so you
   *                                                     could disable it by
   *                                                     `false` value.
   * @property {boolean} map.sourcesContent            - does PostCSS should set
   *                                                     the origin content to map
   * @property {string|false} map.annotation           - does PostCSS should set
   *                                                     annotation comment to map
   * @property {string} map.from                       - override `from` in map’s
   *                                                     `sources`
   */

  module.exports = exports['default'];
  return module.exports;
});
System.registerDynamic('npm:postcss@5.2.6/lib/root.js', ['./container', './warn-once', './lazy-result', './processor', 'process'], true, function ($__require, exports, module) {
    'use strict';

    var process = $__require('process');
    var define,
        global = this || self,
        GLOBAL = global;
    exports.__esModule = true;

    var _container = $__require('./container');

    var _container2 = _interopRequireDefault(_container);

    var _warnOnce = $__require('./warn-once');

    var _warnOnce2 = _interopRequireDefault(_warnOnce);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    /**
     * Represents a CSS file and contains all its parsed nodes.
     *
     * @extends Container
     *
     * @example
     * const root = postcss.parse('a{color:black} b{z-index:2}');
     * root.type         //=> 'root'
     * root.nodes.length //=> 2
     */
    var Root = function (_Container) {
        _inherits(Root, _Container);

        function Root(defaults) {
            _classCallCheck(this, Root);

            var _this = _possibleConstructorReturn(this, _Container.call(this, defaults));

            _this.type = 'root';
            if (!_this.nodes) _this.nodes = [];
            return _this;
        }

        Root.prototype.removeChild = function removeChild(child) {
            child = this.index(child);

            if (child === 0 && this.nodes.length > 1) {
                this.nodes[1].raws.before = this.nodes[child].raws.before;
            }

            return _Container.prototype.removeChild.call(this, child);
        };

        Root.prototype.normalize = function normalize(child, sample, type) {
            var nodes = _Container.prototype.normalize.call(this, child);

            if (sample) {
                if (type === 'prepend') {
                    if (this.nodes.length > 1) {
                        sample.raws.before = this.nodes[1].raws.before;
                    } else {
                        delete sample.raws.before;
                    }
                } else if (this.first !== sample) {
                    for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                        var _ref;

                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            _i = _iterator.next();
                            if (_i.done) break;
                            _ref = _i.value;
                        }

                        var node = _ref;

                        node.raws.before = sample.raws.before;
                    }
                }
            }

            return nodes;
        };

        /**
         * Returns a {@link Result} instance representing the root’s CSS.
         *
         * @param {processOptions} [opts] - options with only `to` and `map` keys
         *
         * @return {Result} result with current root’s CSS
         *
         * @example
         * const root1 = postcss.parse(css1, { from: 'a.css' });
         * const root2 = postcss.parse(css2, { from: 'b.css' });
         * root1.append(root2);
         * const result = root1.toResult({ to: 'all.css', map: true });
         */

        Root.prototype.toResult = function toResult() {
            var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var LazyResult = $__require('./lazy-result');
            var Processor = $__require('./processor');

            var lazy = new LazyResult(new Processor(), this, opts);
            return lazy.stringify();
        };

        Root.prototype.remove = function remove(child) {
            (0, _warnOnce2.default)('Root#remove is deprecated. Use Root#removeChild');
            this.removeChild(child);
        };

        Root.prototype.prevMap = function prevMap() {
            (0, _warnOnce2.default)('Root#prevMap is deprecated. Use Root#source.input.map');
            return this.source.input.map;
        };

        /**
         * @memberof Root#
         * @member {object} raws - Information to generate byte-to-byte equal
         *                         node string as it was in the origin input.
         *
         * Every parser saves its own properties,
         * but the default CSS parser uses:
         *
         * * `after`: the space symbols after the last child to the end of file.
         * * `semicolon`: is the last child has an (optional) semicolon.
         *
         * @example
         * postcss.parse('a {}\n').raws //=> { after: '\n' }
         * postcss.parse('a {}').raws   //=> { after: '' }
         */

        return Root;
    }(_container2.default);

    exports.default = Root;
    module.exports = exports['default'];
    return module.exports;
});
System.registerDynamic("npm:jspm-nodelibs-process@0.2.0.json", [], false, function() {
  return {
    "main": "./process.js"
  };
});

System.registerDynamic('npm:jspm-nodelibs-process@0.2.0/process.js', ['@system-env'], true, function ($__require, exports, module) {
    var define,
        global = this || self,
        GLOBAL = global;
    // From https://github.com/defunctzombie/node-process/blob/master/browser.js
    // shim for using process in browser

    var productionEnv = $__require('@system-env').production;

    var process = module.exports = {};
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = setTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        clearTimeout(timeout);
    }

    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            setTimeout(drainQueue, 0);
        }
    };

    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {
        NODE_ENV: productionEnv ? 'production' : 'development'
    };
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};

    function noop() {}

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;

    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };

    process.cwd = function () {
        return '/';
    };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function () {
        return 0;
    };
    return module.exports;
});
System.registerDynamic("npm:postcss@5.2.6.json", [], false, function() {
  return {
    "main": "lib/postcss.js",
    "format": "cjs",
    "meta": {
      "*": {
        "globals": {
          "process": "process"
        }
      },
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic('npm:postcss@5.2.6/lib/postcss.js', ['./declaration', './processor', './stringify', './comment', './at-rule', './vendor', './parse', './list', './rule', './root', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _declaration = $__require('./declaration');

  var _declaration2 = _interopRequireDefault(_declaration);

  var _processor = $__require('./processor');

  var _processor2 = _interopRequireDefault(_processor);

  var _stringify = $__require('./stringify');

  var _stringify2 = _interopRequireDefault(_stringify);

  var _comment = $__require('./comment');

  var _comment2 = _interopRequireDefault(_comment);

  var _atRule = $__require('./at-rule');

  var _atRule2 = _interopRequireDefault(_atRule);

  var _vendor = $__require('./vendor');

  var _vendor2 = _interopRequireDefault(_vendor);

  var _parse = $__require('./parse');

  var _parse2 = _interopRequireDefault(_parse);

  var _list = $__require('./list');

  var _list2 = _interopRequireDefault(_list);

  var _rule = $__require('./rule');

  var _rule2 = _interopRequireDefault(_rule);

  var _root = $__require('./root');

  var _root2 = _interopRequireDefault(_root);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  /**
   * Create a new {@link Processor} instance that will apply `plugins`
   * as CSS processors.
   *
   * @param {Array.<Plugin|pluginFunction>|Processor} plugins - PostCSS
   *        plugins. See {@link Processor#use} for plugin format.
   *
   * @return {Processor} Processor to process multiple CSS
   *
   * @example
   * import postcss from 'postcss';
   *
   * postcss(plugins).process(css, { from, to }).then(result => {
   *   console.log(result.css);
   * });
   *
   * @namespace postcss
   */
  function postcss() {
    for (var _len = arguments.length, plugins = Array(_len), _key = 0; _key < _len; _key++) {
      plugins[_key] = arguments[_key];
    }

    if (plugins.length === 1 && Array.isArray(plugins[0])) {
      plugins = plugins[0];
    }
    return new _processor2.default(plugins);
  }

  /**
   * Creates a PostCSS plugin with a standard API.
   *
   * The newly-wrapped function will provide both the name and PostCSS
   * version of the plugin.
   *
   * ```js
   *  const processor = postcss([replace]);
   *  processor.plugins[0].postcssPlugin  //=> 'postcss-replace'
   *  processor.plugins[0].postcssVersion //=> '5.1.0'
   * ```
   *
   * The plugin function receives 2 arguments: {@link Root}
   * and {@link Result} instance. The function should mutate the provided
   * `Root` node. Alternatively, you can create a new `Root` node
   * and override the `result.root` property.
   *
   * ```js
   * const cleaner = postcss.plugin('postcss-cleaner', () => {
   *   return (root, result) => {
   *     result.root = postcss.root();
   *   };
   * });
   * ```
   *
   * As a convenience, plugins also expose a `process` method so that you can use
   * them as standalone tools.
   *
   * ```js
   * cleaner.process(css, options);
   * // This is equivalent to:
   * postcss([ cleaner(options) ]).process(css);
   * ```
   *
   * Asynchronous plugins should return a `Promise` instance.
   *
   * ```js
   * postcss.plugin('postcss-import', () => {
   *   return (root, result) => {
   *     return new Promise( (resolve, reject) => {
   *       fs.readFile('base.css', (base) => {
   *         root.prepend(base);
   *         resolve();
   *       });
   *     });
   *   };
   * });
   * ```
   *
   * Add warnings using the {@link Node#warn} method.
   * Send data to other plugins using the {@link Result#messages} array.
   *
   * ```js
   * postcss.plugin('postcss-caniuse-test', () => {
   *   return (root, result) => {
   *     css.walkDecls(decl => {
   *       if ( !caniuse.support(decl.prop) ) {
   *         decl.warn(result, 'Some browsers do not support ' + decl.prop);
   *       }
   *     });
   *   };
   * });
   * ```
   *
   * @param {string} name          - PostCSS plugin name. Same as in `name`
   *                                 property in `package.json`. It will be saved
   *                                 in `plugin.postcssPlugin` property.
   * @param {function} initializer - will receive plugin options
   *                                 and should return {@link pluginFunction}
   *
   * @return {Plugin} PostCSS plugin
   */
  postcss.plugin = function plugin(name, initializer) {
    var creator = function creator() {
      var transformer = initializer.apply(undefined, arguments);
      transformer.postcssPlugin = name;
      transformer.postcssVersion = new _processor2.default().version;
      return transformer;
    };

    var cache = void 0;
    Object.defineProperty(creator, 'postcss', {
      get: function get() {
        if (!cache) cache = creator();
        return cache;
      }
    });

    creator.process = function (root, opts) {
      return postcss([creator(opts)]).process(root, opts);
    };

    return creator;
  };

  /**
   * Default function to convert a node tree into a CSS string.
   *
   * @param {Node} node       - start node for stringifing. Usually {@link Root}.
   * @param {builder} builder - function to concatenate CSS from node’s parts
   *                            or generate string and source map
   *
   * @return {void}
   *
   * @function
   */
  postcss.stringify = _stringify2.default;

  /**
   * Parses source css and returns a new {@link Root} node,
   * which contains the source CSS nodes.
   *
   * @param {string|toString} css   - string with input CSS or any object
   *                                  with toString() method, like a Buffer
   * @param {processOptions} [opts] - options with only `from` and `map` keys
   *
   * @return {Root} PostCSS AST
   *
   * @example
   * // Simple CSS concatenation with source map support
   * const root1 = postcss.parse(css1, { from: file1 });
   * const root2 = postcss.parse(css2, { from: file2 });
   * root1.append(root2).toResult().css;
   *
   * @function
   */
  postcss.parse = _parse2.default;

  /**
   * @member {vendor} - Contains the {@link vendor} module.
   *
   * @example
   * postcss.vendor.unprefixed('-moz-tab') //=> ['tab']
   */
  postcss.vendor = _vendor2.default;

  /**
   * @member {list} - Contains the {@link list} module.
   *
   * @example
   * postcss.list.space('5px calc(10% + 5px)') //=> ['5px', 'calc(10% + 5px)']
   */
  postcss.list = _list2.default;

  /**
   * Creates a new {@link Comment} node.
   *
   * @param {object} [defaults] - properties for the new node.
   *
   * @return {Comment} new Comment node
   *
   * @example
   * postcss.comment({ text: 'test' })
   */
  postcss.comment = function (defaults) {
    return new _comment2.default(defaults);
  };

  /**
   * Creates a new {@link AtRule} node.
   *
   * @param {object} [defaults] - properties for the new node.
   *
   * @return {AtRule} new AtRule node
   *
   * @example
   * postcss.atRule({ name: 'charset' }).toString() //=> "@charset"
   */
  postcss.atRule = function (defaults) {
    return new _atRule2.default(defaults);
  };

  /**
   * Creates a new {@link Declaration} node.
   *
   * @param {object} [defaults] - properties for the new node.
   *
   * @return {Declaration} new Declaration node
   *
   * @example
   * postcss.decl({ prop: 'color', value: 'red' }).toString() //=> "color: red"
   */
  postcss.decl = function (defaults) {
    return new _declaration2.default(defaults);
  };

  /**
   * Creates a new {@link Rule} node.
   *
   * @param {object} [defaults] - properties for the new node.
   *
   * @return {AtRule} new Rule node
   *
   * @example
   * postcss.rule({ selector: 'a' }).toString() //=> "a {\n}"
   */
  postcss.rule = function (defaults) {
    return new _rule2.default(defaults);
  };

  /**
   * Creates a new {@link Root} node.
   *
   * @param {object} [defaults] - properties for the new node.
   *
   * @return {Root} new Root node
   *
   * @example
   * postcss.root({ after: '\n' }).toString() //=> "\n"
   */
  postcss.root = function (defaults) {
    return new _root2.default(defaults);
  };

  exports.default = postcss;
  module.exports = exports['default'];
  return module.exports;
});
System.registerDynamic("npm:postcss-nested@1.0.0.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic('npm:postcss-nested@1.0.0/index.js', ['postcss'], true, function ($__require, exports, module) {
    var define,
        global = this || self,
        GLOBAL = global;
    var postcss = $__require('postcss');

    function selectors(parent, node) {
        var result = [];
        parent.selectors.forEach(function (i) {
            node.selectors.forEach(function (j) {
                if (j.indexOf('&') === -1) {
                    result.push(i + ' ' + j);
                } else {
                    result.push(j.replace(/&/g, i));
                }
            });
        });
        return result;
    }

    function pickComment(comment, after) {
        if (comment && comment.type === 'comment') {
            return comment.moveAfter(after);
        } else {
            return after;
        }
    }

    function atruleChilds(rule, atrule) {
        var children = [];
        atrule.each(function (child) {
            if (child.type === 'comment') {
                children.push(child);
            }if (child.type === 'decl') {
                children.push(child);
            } else if (child.type === 'rule') {
                child.selectors = selectors(rule, child);
            } else if (child.type === 'atrule') {
                atruleChilds(rule, child);
            }
        });
        if (children.length) {
            var clone = rule.clone({ nodes: [] });
            for (var i = 0; i < children.length; i++) children[i].moveTo(clone);
            atrule.prepend(clone);
        }
    }

    function processRule(rule, bubble) {
        var unwrapped = false;
        var after = rule;
        rule.each(function (child) {
            if (child.type === 'rule') {
                unwrapped = true;
                child.selectors = selectors(rule, child);
                after = pickComment(child.prev(), after);
                after = child.moveAfter(after);
            } else if (child.type === 'atrule') {
                if (bubble.indexOf(child.name) !== -1) {
                    unwrapped = true;
                    atruleChilds(rule, child);
                    after = pickComment(child.prev(), after);
                    after = child.moveAfter(after);
                }
            }
        });
        if (unwrapped) {
            rule.raws.semicolon = true;
            if (rule.nodes.length === 0) rule.remove();
        }
    }

    module.exports = postcss.plugin('postcss-nested', function (opts) {
        var bubble = ['media', 'supports', 'document'];
        if (opts && opts.bubble) {
            bubble = bubble.concat(opts.bubble.map(function (i) {
                return i.replace(/^@/, '');
            }));
        }

        var process = function (node) {
            node.each(function (child) {
                if (child.type === 'rule') {
                    processRule(child, bubble);
                } else if (child.type === 'atrule') {
                    process(child);
                }
            });
        };
        return process;
    });
    return module.exports;
});
System.registerDynamic("github:ajaxorg/ace-builds@1.2.6/ace.js", ["ace/ace"], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, "ace", null);

    (function ($__global) {
        /* ***** BEGIN LICENSE BLOCK *****
         * Distributed under the BSD license:
         *
         * Copyright (c) 2010, Ajax.org B.V.
         * All rights reserved.
         *
         * Redistribution and use in source and binary forms, with or without
         * modification, are permitted provided that the following conditions are met:
         *     * Redistributions of source code must retain the above copyright
         *       notice, this list of conditions and the following disclaimer.
         *     * Redistributions in binary form must reproduce the above copyright
         *       notice, this list of conditions and the following disclaimer in the
         *       documentation and/or other materials provided with the distribution.
         *     * Neither the name of Ajax.org B.V. nor the
         *       names of its contributors may be used to endorse or promote products
         *       derived from this software without specific prior written permission.
         *
         * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
         * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
         * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
         * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
         * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
         * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
         * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
         * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
         * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
         * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
         *
         * ***** END LICENSE BLOCK ***** */

        /**
         * Define a module along with a payload
         * @param module a name for the payload
         * @param payload a function to call with (require, exports, module) params
         */

        (function () {

            var ACE_NAMESPACE = "ace";

            var global = function () {
                return this;
            }();
            if (!global && typeof window != "undefined") global = window; // strict mode


            if (!ACE_NAMESPACE && typeof requirejs !== "undefined") return;

            var define = function (module, deps, payload) {
                if (typeof module !== "string") {
                    if (define.original) define.original.apply(this, arguments);else {
                        console.error("dropping module because define wasn\'t a string.");
                        console.trace();
                    }
                    return;
                }
                if (arguments.length == 2) payload = deps;
                if (!define.modules[module]) {
                    define.payloads[module] = payload;
                    define.modules[module] = null;
                }
            };

            define.modules = {};
            define.payloads = {};

            /**
             * Get at functionality define()ed using the function above
             */
            var _require = function (parentId, module, callback) {
                if (typeof module === "string") {
                    var payload = lookup(parentId, module);
                    if (payload != undefined) {
                        callback && callback();
                        return payload;
                    }
                } else if (Object.prototype.toString.call(module) === "[object Array]") {
                    var params = [];
                    for (var i = 0, l = module.length; i < l; ++i) {
                        var dep = lookup(parentId, module[i]);
                        if (dep == undefined && require.original) return;
                        params.push(dep);
                    }
                    return callback && callback.apply(null, params) || true;
                }
            };

            var require = function (module, callback) {
                var packagedModule = _require("", module, callback);
                if (packagedModule == undefined && require.original) return require.original.apply(this, arguments);
                return packagedModule;
            };

            var normalizeModule = function (parentId, moduleName) {
                // normalize plugin requires
                if (moduleName.indexOf("!") !== -1) {
                    var chunks = moduleName.split("!");
                    return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
                }
                // normalize relative requires
                if (moduleName.charAt(0) == ".") {
                    var base = parentId.split("/").slice(0, -1).join("/");
                    moduleName = base + "/" + moduleName;

                    while (moduleName.indexOf(".") !== -1 && previous != moduleName) {
                        var previous = moduleName;
                        moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
                    }
                }
                return moduleName;
            };

            /**
             * Internal function to lookup moduleNames and resolve them by calling the
             * definition function if needed.
             */
            var lookup = function (parentId, moduleName) {
                moduleName = normalizeModule(parentId, moduleName);

                var module = define.modules[moduleName];
                if (!module) {
                    module = define.payloads[moduleName];
                    if (typeof module === 'function') {
                        var exports = {};
                        var mod = {
                            id: moduleName,
                            uri: '',
                            exports: exports,
                            packaged: true
                        };

                        var req = function (module, callback) {
                            return _require(moduleName, module, callback);
                        };

                        var returnValue = module(req, exports, mod);
                        exports = returnValue || mod.exports;
                        define.modules[moduleName] = exports;
                        delete define.payloads[moduleName];
                    }
                    module = define.modules[moduleName] = exports || module;
                }
                return module;
            };

            function exportAce(ns) {
                var root = global;
                if (ns) {
                    if (!global[ns]) global[ns] = {};
                    root = global[ns];
                }

                if (!root.define || !root.define.packaged) {
                    define.original = root.define;
                    root.define = define;
                    root.define.packaged = true;
                }

                if (!root.require || !root.require.packaged) {
                    require.original = root.require;
                    root.require = require;
                    root.require.packaged = true;
                }
            }

            exportAce(ACE_NAMESPACE);
        })();

        ace.define("ace/lib/regexp", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            var real = {
                exec: RegExp.prototype.exec,
                test: RegExp.prototype.test,
                match: String.prototype.match,
                replace: String.prototype.replace,
                split: String.prototype.split
            },
                compliantExecNpcg = real.exec.call(/()??/, "")[1] === undefined,
                // check `exec` handling of nonparticipating capturing groups
            compliantLastIndexIncrement = function () {
                var x = /^/g;
                real.test.call(x, "");
                return !x.lastIndex;
            }();

            if (compliantLastIndexIncrement && compliantExecNpcg) return;
            RegExp.prototype.exec = function (str) {
                var match = real.exec.apply(this, arguments),
                    name,
                    r2;
                if (typeof str == 'string' && match) {
                    if (!compliantExecNpcg && match.length > 1 && indexOf(match, "") > -1) {
                        r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), "g", ""));
                        real.replace.call(str.slice(match.index), r2, function () {
                            for (var i = 1; i < arguments.length - 2; i++) {
                                if (arguments[i] === undefined) match[i] = undefined;
                            }
                        });
                    }
                    if (this._xregexp && this._xregexp.captureNames) {
                        for (var i = 1; i < match.length; i++) {
                            name = this._xregexp.captureNames[i - 1];
                            if (name) match[name] = match[i];
                        }
                    }
                    if (!compliantLastIndexIncrement && this.global && !match[0].length && this.lastIndex > match.index) this.lastIndex--;
                }
                return match;
            };
            if (!compliantLastIndexIncrement) {
                RegExp.prototype.test = function (str) {
                    var match = real.exec.call(this, str);
                    if (match && this.global && !match[0].length && this.lastIndex > match.index) this.lastIndex--;
                    return !!match;
                };
            }

            function getNativeFlags(regex) {
                return (regex.global ? "g" : "") + (regex.ignoreCase ? "i" : "") + (regex.multiline ? "m" : "") + (regex.extended ? "x" : "") + ( // Proposed for ES4; included in AS3
                regex.sticky ? "y" : "");
            }

            function indexOf(array, item, from) {
                if (Array.prototype.indexOf) // Use the native array method if available
                    return array.indexOf(item, from);
                for (var i = from || 0; i < array.length; i++) {
                    if (array[i] === item) return i;
                }
                return -1;
            }
        });

        ace.define("ace/lib/es5-shim", ["require", "exports", "module"], function (require, exports, module) {

            function Empty() {}

            if (!Function.prototype.bind) {
                Function.prototype.bind = function bind(that) {
                    // .length is 1
                    var target = this;
                    if (typeof target != "function") {
                        throw new TypeError("Function.prototype.bind called on incompatible " + target);
                    }
                    var args = slice.call(arguments, 1); // for normal call
                    var bound = function () {

                        if (this instanceof bound) {

                            var result = target.apply(this, args.concat(slice.call(arguments)));
                            if (Object(result) === result) {
                                return result;
                            }
                            return this;
                        } else {
                            return target.apply(that, args.concat(slice.call(arguments)));
                        }
                    };
                    if (target.prototype) {
                        Empty.prototype = target.prototype;
                        bound.prototype = new Empty();
                        Empty.prototype = null;
                    }
                    return bound;
                };
            }
            var call = Function.prototype.call;
            var prototypeOfArray = Array.prototype;
            var prototypeOfObject = Object.prototype;
            var slice = prototypeOfArray.slice;
            var _toString = call.bind(prototypeOfObject.toString);
            var owns = call.bind(prototypeOfObject.hasOwnProperty);
            var defineGetter;
            var defineSetter;
            var lookupGetter;
            var lookupSetter;
            var supportsAccessors;
            if (supportsAccessors = owns(prototypeOfObject, "__defineGetter__")) {
                defineGetter = call.bind(prototypeOfObject.__defineGetter__);
                defineSetter = call.bind(prototypeOfObject.__defineSetter__);
                lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
                lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
            }
            if ([1, 2].splice(0).length != 2) {
                if (function () {
                    // test IE < 9 to splice bug - see issue #138
                    function makeArray(l) {
                        var a = new Array(l + 2);
                        a[0] = a[1] = 0;
                        return a;
                    }
                    var array = [],
                        lengthBefore;

                    array.splice.apply(array, makeArray(20));
                    array.splice.apply(array, makeArray(26));

                    lengthBefore = array.length; //46
                    array.splice(5, 0, "XXX"); // add one element

                    lengthBefore + 1 == array.length;

                    if (lengthBefore + 1 == array.length) {
                        return true; // has right splice implementation without bugs
                    }
                }()) {
                    //IE 6/7
                    var array_splice = Array.prototype.splice;
                    Array.prototype.splice = function (start, deleteCount) {
                        if (!arguments.length) {
                            return [];
                        } else {
                            return array_splice.apply(this, [start === void 0 ? 0 : start, deleteCount === void 0 ? this.length - start : deleteCount].concat(slice.call(arguments, 2)));
                        }
                    };
                } else {
                    //IE8
                    Array.prototype.splice = function (pos, removeCount) {
                        var length = this.length;
                        if (pos > 0) {
                            if (pos > length) pos = length;
                        } else if (pos == void 0) {
                            pos = 0;
                        } else if (pos < 0) {
                            pos = Math.max(length + pos, 0);
                        }

                        if (!(pos + removeCount < length)) removeCount = length - pos;

                        var removed = this.slice(pos, pos + removeCount);
                        var insert = slice.call(arguments, 2);
                        var add = insert.length;
                        if (pos === length) {
                            if (add) {
                                this.push.apply(this, insert);
                            }
                        } else {
                            var remove = Math.min(removeCount, length - pos);
                            var tailOldPos = pos + remove;
                            var tailNewPos = tailOldPos + add - remove;
                            var tailCount = length - tailOldPos;
                            var lengthAfterRemove = length - remove;

                            if (tailNewPos < tailOldPos) {
                                // case A
                                for (var i = 0; i < tailCount; ++i) {
                                    this[tailNewPos + i] = this[tailOldPos + i];
                                }
                            } else if (tailNewPos > tailOldPos) {
                                // case B
                                for (i = tailCount; i--;) {
                                    this[tailNewPos + i] = this[tailOldPos + i];
                                }
                            } // else, add == remove (nothing to do)

                            if (add && pos === lengthAfterRemove) {
                                this.length = lengthAfterRemove; // truncate array
                                this.push.apply(this, insert);
                            } else {
                                this.length = lengthAfterRemove + add; // reserves space
                                for (i = 0; i < add; ++i) {
                                    this[pos + i] = insert[i];
                                }
                            }
                        }
                        return removed;
                    };
                }
            }
            if (!Array.isArray) {
                Array.isArray = function isArray(obj) {
                    return _toString(obj) == "[object Array]";
                };
            }
            var boxedString = Object("a"),
                splitString = boxedString[0] != "a" || !(0 in boxedString);

            if (!Array.prototype.forEach) {
                Array.prototype.forEach = function forEach(fun /*, thisp*/) {
                    var object = toObject(this),
                        self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
                        thisp = arguments[1],
                        i = -1,
                        length = self.length >>> 0;
                    if (_toString(fun) != "[object Function]") {
                        throw new TypeError(); // TODO message
                    }

                    while (++i < length) {
                        if (i in self) {
                            fun.call(thisp, self[i], i, object);
                        }
                    }
                };
            }
            if (!Array.prototype.map) {
                Array.prototype.map = function map(fun /*, thisp*/) {
                    var object = toObject(this),
                        self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
                        length = self.length >>> 0,
                        result = Array(length),
                        thisp = arguments[1];
                    if (_toString(fun) != "[object Function]") {
                        throw new TypeError(fun + " is not a function");
                    }

                    for (var i = 0; i < length; i++) {
                        if (i in self) result[i] = fun.call(thisp, self[i], i, object);
                    }
                    return result;
                };
            }
            if (!Array.prototype.filter) {
                Array.prototype.filter = function filter(fun /*, thisp */) {
                    var object = toObject(this),
                        self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
                        length = self.length >>> 0,
                        result = [],
                        value,
                        thisp = arguments[1];
                    if (_toString(fun) != "[object Function]") {
                        throw new TypeError(fun + " is not a function");
                    }

                    for (var i = 0; i < length; i++) {
                        if (i in self) {
                            value = self[i];
                            if (fun.call(thisp, value, i, object)) {
                                result.push(value);
                            }
                        }
                    }
                    return result;
                };
            }
            if (!Array.prototype.every) {
                Array.prototype.every = function every(fun /*, thisp */) {
                    var object = toObject(this),
                        self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
                        length = self.length >>> 0,
                        thisp = arguments[1];
                    if (_toString(fun) != "[object Function]") {
                        throw new TypeError(fun + " is not a function");
                    }

                    for (var i = 0; i < length; i++) {
                        if (i in self && !fun.call(thisp, self[i], i, object)) {
                            return false;
                        }
                    }
                    return true;
                };
            }
            if (!Array.prototype.some) {
                Array.prototype.some = function some(fun /*, thisp */) {
                    var object = toObject(this),
                        self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
                        length = self.length >>> 0,
                        thisp = arguments[1];
                    if (_toString(fun) != "[object Function]") {
                        throw new TypeError(fun + " is not a function");
                    }

                    for (var i = 0; i < length; i++) {
                        if (i in self && fun.call(thisp, self[i], i, object)) {
                            return true;
                        }
                    }
                    return false;
                };
            }
            if (!Array.prototype.reduce) {
                Array.prototype.reduce = function reduce(fun /*, initial*/) {
                    var object = toObject(this),
                        self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
                        length = self.length >>> 0;
                    if (_toString(fun) != "[object Function]") {
                        throw new TypeError(fun + " is not a function");
                    }
                    if (!length && arguments.length == 1) {
                        throw new TypeError("reduce of empty array with no initial value");
                    }

                    var i = 0;
                    var result;
                    if (arguments.length >= 2) {
                        result = arguments[1];
                    } else {
                        do {
                            if (i in self) {
                                result = self[i++];
                                break;
                            }
                            if (++i >= length) {
                                throw new TypeError("reduce of empty array with no initial value");
                            }
                        } while (true);
                    }

                    for (; i < length; i++) {
                        if (i in self) {
                            result = fun.call(void 0, result, self[i], i, object);
                        }
                    }

                    return result;
                };
            }
            if (!Array.prototype.reduceRight) {
                Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {
                    var object = toObject(this),
                        self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
                        length = self.length >>> 0;
                    if (_toString(fun) != "[object Function]") {
                        throw new TypeError(fun + " is not a function");
                    }
                    if (!length && arguments.length == 1) {
                        throw new TypeError("reduceRight of empty array with no initial value");
                    }

                    var result,
                        i = length - 1;
                    if (arguments.length >= 2) {
                        result = arguments[1];
                    } else {
                        do {
                            if (i in self) {
                                result = self[i--];
                                break;
                            }
                            if (--i < 0) {
                                throw new TypeError("reduceRight of empty array with no initial value");
                            }
                        } while (true);
                    }

                    do {
                        if (i in this) {
                            result = fun.call(void 0, result, self[i], i, object);
                        }
                    } while (i--);

                    return result;
                };
            }
            if (!Array.prototype.indexOf || [0, 1].indexOf(1, 2) != -1) {
                Array.prototype.indexOf = function indexOf(sought /*, fromIndex */) {
                    var self = splitString && _toString(this) == "[object String]" ? this.split("") : toObject(this),
                        length = self.length >>> 0;

                    if (!length) {
                        return -1;
                    }

                    var i = 0;
                    if (arguments.length > 1) {
                        i = toInteger(arguments[1]);
                    }
                    i = i >= 0 ? i : Math.max(0, length + i);
                    for (; i < length; i++) {
                        if (i in self && self[i] === sought) {
                            return i;
                        }
                    }
                    return -1;
                };
            }
            if (!Array.prototype.lastIndexOf || [0, 1].lastIndexOf(0, -3) != -1) {
                Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {
                    var self = splitString && _toString(this) == "[object String]" ? this.split("") : toObject(this),
                        length = self.length >>> 0;

                    if (!length) {
                        return -1;
                    }
                    var i = length - 1;
                    if (arguments.length > 1) {
                        i = Math.min(i, toInteger(arguments[1]));
                    }
                    i = i >= 0 ? i : length - Math.abs(i);
                    for (; i >= 0; i--) {
                        if (i in self && sought === self[i]) {
                            return i;
                        }
                    }
                    return -1;
                };
            }
            if (!Object.getPrototypeOf) {
                Object.getPrototypeOf = function getPrototypeOf(object) {
                    return object.__proto__ || (object.constructor ? object.constructor.prototype : prototypeOfObject);
                };
            }
            if (!Object.getOwnPropertyDescriptor) {
                var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a " + "non-object: ";
                Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
                    if (typeof object != "object" && typeof object != "function" || object === null) throw new TypeError(ERR_NON_OBJECT + object);
                    if (!owns(object, property)) return;

                    var descriptor, getter, setter;
                    descriptor = { enumerable: true, configurable: true };
                    if (supportsAccessors) {
                        var prototype = object.__proto__;
                        object.__proto__ = prototypeOfObject;

                        var getter = lookupGetter(object, property);
                        var setter = lookupSetter(object, property);
                        object.__proto__ = prototype;

                        if (getter || setter) {
                            if (getter) descriptor.get = getter;
                            if (setter) descriptor.set = setter;
                            return descriptor;
                        }
                    }
                    descriptor.value = object[property];
                    return descriptor;
                };
            }
            if (!Object.getOwnPropertyNames) {
                Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
                    return Object.keys(object);
                };
            }
            if (!Object.create) {
                var createEmpty;
                if (Object.prototype.__proto__ === null) {
                    createEmpty = function () {
                        return { "__proto__": null };
                    };
                } else {
                    createEmpty = function () {
                        var empty = {};
                        for (var i in empty) empty[i] = null;
                        empty.constructor = empty.hasOwnProperty = empty.propertyIsEnumerable = empty.isPrototypeOf = empty.toLocaleString = empty.toString = empty.valueOf = empty.__proto__ = null;
                        return empty;
                    };
                }

                Object.create = function create(prototype, properties) {
                    var object;
                    if (prototype === null) {
                        object = createEmpty();
                    } else {
                        if (typeof prototype != "object") throw new TypeError("typeof prototype[" + typeof prototype + "] != 'object'");
                        var Type = function () {};
                        Type.prototype = prototype;
                        object = new Type();
                        object.__proto__ = prototype;
                    }
                    if (properties !== void 0) Object.defineProperties(object, properties);
                    return object;
                };
            }

            function doesDefinePropertyWork(object) {
                try {
                    Object.defineProperty(object, "sentinel", {});
                    return "sentinel" in object;
                } catch (exception) {}
            }
            if (Object.defineProperty) {
                var definePropertyWorksOnObject = doesDefinePropertyWork({});
                var definePropertyWorksOnDom = typeof document == "undefined" || doesDefinePropertyWork(document.createElement("div"));
                if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
                    var definePropertyFallback = Object.defineProperty;
                }
            }

            if (!Object.defineProperty || definePropertyFallback) {
                var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
                var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: ";
                var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " + "on this javascript engine";

                Object.defineProperty = function defineProperty(object, property, descriptor) {
                    if (typeof object != "object" && typeof object != "function" || object === null) throw new TypeError(ERR_NON_OBJECT_TARGET + object);
                    if (typeof descriptor != "object" && typeof descriptor != "function" || descriptor === null) throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
                    if (definePropertyFallback) {
                        try {
                            return definePropertyFallback.call(Object, object, property, descriptor);
                        } catch (exception) {}
                    }
                    if (owns(descriptor, "value")) {

                        if (supportsAccessors && (lookupGetter(object, property) || lookupSetter(object, property))) {
                            var prototype = object.__proto__;
                            object.__proto__ = prototypeOfObject;
                            delete object[property];
                            object[property] = descriptor.value;
                            object.__proto__ = prototype;
                        } else {
                            object[property] = descriptor.value;
                        }
                    } else {
                        if (!supportsAccessors) throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
                        if (owns(descriptor, "get")) defineGetter(object, property, descriptor.get);
                        if (owns(descriptor, "set")) defineSetter(object, property, descriptor.set);
                    }

                    return object;
                };
            }
            if (!Object.defineProperties) {
                Object.defineProperties = function defineProperties(object, properties) {
                    for (var property in properties) {
                        if (owns(properties, property)) Object.defineProperty(object, property, properties[property]);
                    }
                    return object;
                };
            }
            if (!Object.seal) {
                Object.seal = function seal(object) {
                    return object;
                };
            }
            if (!Object.freeze) {
                Object.freeze = function freeze(object) {
                    return object;
                };
            }
            try {
                Object.freeze(function () {});
            } catch (exception) {
                Object.freeze = function freeze(freezeObject) {
                    return function freeze(object) {
                        if (typeof object == "function") {
                            return object;
                        } else {
                            return freezeObject(object);
                        }
                    };
                }(Object.freeze);
            }
            if (!Object.preventExtensions) {
                Object.preventExtensions = function preventExtensions(object) {
                    return object;
                };
            }
            if (!Object.isSealed) {
                Object.isSealed = function isSealed(object) {
                    return false;
                };
            }
            if (!Object.isFrozen) {
                Object.isFrozen = function isFrozen(object) {
                    return false;
                };
            }
            if (!Object.isExtensible) {
                Object.isExtensible = function isExtensible(object) {
                    if (Object(object) === object) {
                        throw new TypeError(); // TODO message
                    }
                    var name = '';
                    while (owns(object, name)) {
                        name += '?';
                    }
                    object[name] = true;
                    var returnValue = owns(object, name);
                    delete object[name];
                    return returnValue;
                };
            }
            if (!Object.keys) {
                var hasDontEnumBug = true,
                    dontEnums = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"],
                    dontEnumsLength = dontEnums.length;

                for (var key in { "toString": null }) {
                    hasDontEnumBug = false;
                }

                Object.keys = function keys(object) {

                    if (typeof object != "object" && typeof object != "function" || object === null) {
                        throw new TypeError("Object.keys called on a non-object");
                    }

                    var keys = [];
                    for (var name in object) {
                        if (owns(object, name)) {
                            keys.push(name);
                        }
                    }

                    if (hasDontEnumBug) {
                        for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
                            var dontEnum = dontEnums[i];
                            if (owns(object, dontEnum)) {
                                keys.push(dontEnum);
                            }
                        }
                    }
                    return keys;
                };
            }
            if (!Date.now) {
                Date.now = function now() {
                    return new Date().getTime();
                };
            }
            var ws = "\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003" + "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" + "\u2029\uFEFF";
            if (!String.prototype.trim || ws.trim()) {
                ws = "[" + ws + "]";
                var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),
                    trimEndRegexp = new RegExp(ws + ws + "*$");
                String.prototype.trim = function trim() {
                    return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
                };
            }

            function toInteger(n) {
                n = +n;
                if (n !== n) {
                    // isNaN
                    n = 0;
                } else if (n !== 0 && n !== 1 / 0 && n !== -(1 / 0)) {
                    n = (n > 0 || -1) * Math.floor(Math.abs(n));
                }
                return n;
            }

            function isPrimitive(input) {
                var type = typeof input;
                return input === null || type === "undefined" || type === "boolean" || type === "number" || type === "string";
            }

            function toPrimitive(input) {
                var val, valueOf, toString;
                if (isPrimitive(input)) {
                    return input;
                }
                valueOf = input.valueOf;
                if (typeof valueOf === "function") {
                    val = valueOf.call(input);
                    if (isPrimitive(val)) {
                        return val;
                    }
                }
                toString = input.toString;
                if (typeof toString === "function") {
                    val = toString.call(input);
                    if (isPrimitive(val)) {
                        return val;
                    }
                }
                throw new TypeError();
            }
            var toObject = function (o) {
                if (o == null) {
                    // this matches both null and undefined
                    throw new TypeError("can't convert " + o + " to object");
                }
                return Object(o);
            };
        });

        ace.define("ace/lib/fixoldbrowsers", ["require", "exports", "module", "ace/lib/regexp", "ace/lib/es5-shim"], function (require, exports, module) {
            "use strict";

            require("./regexp");
            require("./es5-shim");
        });

        ace.define("ace/lib/dom", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            var XHTML_NS = "http://www.w3.org/1999/xhtml";

            exports.getDocumentHead = function (doc) {
                if (!doc) doc = document;
                return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
            };

            exports.createElement = function (tag, ns) {
                return document.createElementNS ? document.createElementNS(ns || XHTML_NS, tag) : document.createElement(tag);
            };

            exports.hasCssClass = function (el, name) {
                var classes = (el.className + "").split(/\s+/g);
                return classes.indexOf(name) !== -1;
            };
            exports.addCssClass = function (el, name) {
                if (!exports.hasCssClass(el, name)) {
                    el.className += " " + name;
                }
            };
            exports.removeCssClass = function (el, name) {
                var classes = el.className.split(/\s+/g);
                while (true) {
                    var index = classes.indexOf(name);
                    if (index == -1) {
                        break;
                    }
                    classes.splice(index, 1);
                }
                el.className = classes.join(" ");
            };

            exports.toggleCssClass = function (el, name) {
                var classes = el.className.split(/\s+/g),
                    add = true;
                while (true) {
                    var index = classes.indexOf(name);
                    if (index == -1) {
                        break;
                    }
                    add = false;
                    classes.splice(index, 1);
                }
                if (add) classes.push(name);

                el.className = classes.join(" ");
                return add;
            };
            exports.setCssClass = function (node, className, include) {
                if (include) {
                    exports.addCssClass(node, className);
                } else {
                    exports.removeCssClass(node, className);
                }
            };

            exports.hasCssString = function (id, doc) {
                var index = 0,
                    sheets;
                doc = doc || document;

                if (doc.createStyleSheet && (sheets = doc.styleSheets)) {
                    while (index < sheets.length) if (sheets[index++].owningElement.id === id) return true;
                } else if (sheets = doc.getElementsByTagName("style")) {
                    while (index < sheets.length) if (sheets[index++].id === id) return true;
                }

                return false;
            };

            exports.importCssString = function importCssString(cssText, id, doc) {
                doc = doc || document;
                if (id && exports.hasCssString(id, doc)) return null;

                var style;

                if (id) cssText += "\n/*# sourceURL=ace/css/" + id + " */";

                if (doc.createStyleSheet) {
                    style = doc.createStyleSheet();
                    style.cssText = cssText;
                    if (id) style.owningElement.id = id;
                } else {
                    style = exports.createElement("style");
                    style.appendChild(doc.createTextNode(cssText));
                    if (id) style.id = id;

                    exports.getDocumentHead(doc).appendChild(style);
                }
            };

            exports.importCssStylsheet = function (uri, doc) {
                if (doc.createStyleSheet) {
                    doc.createStyleSheet(uri);
                } else {
                    var link = exports.createElement('link');
                    link.rel = 'stylesheet';
                    link.href = uri;

                    exports.getDocumentHead(doc).appendChild(link);
                }
            };

            exports.getInnerWidth = function (element) {
                return parseInt(exports.computedStyle(element, "paddingLeft"), 10) + parseInt(exports.computedStyle(element, "paddingRight"), 10) + element.clientWidth;
            };

            exports.getInnerHeight = function (element) {
                return parseInt(exports.computedStyle(element, "paddingTop"), 10) + parseInt(exports.computedStyle(element, "paddingBottom"), 10) + element.clientHeight;
            };

            exports.scrollbarWidth = function (document) {
                var inner = exports.createElement("ace_inner");
                inner.style.width = "100%";
                inner.style.minWidth = "0px";
                inner.style.height = "200px";
                inner.style.display = "block";

                var outer = exports.createElement("ace_outer");
                var style = outer.style;

                style.position = "absolute";
                style.left = "-10000px";
                style.overflow = "hidden";
                style.width = "200px";
                style.minWidth = "0px";
                style.height = "150px";
                style.display = "block";

                outer.appendChild(inner);

                var body = document.documentElement;
                body.appendChild(outer);

                var noScrollbar = inner.offsetWidth;

                style.overflow = "scroll";
                var withScrollbar = inner.offsetWidth;

                if (noScrollbar == withScrollbar) {
                    withScrollbar = outer.clientWidth;
                }

                body.removeChild(outer);

                return noScrollbar - withScrollbar;
            };

            if (typeof document == "undefined") {
                exports.importCssString = function () {};
                return;
            }

            if (window.pageYOffset !== undefined) {
                exports.getPageScrollTop = function () {
                    return window.pageYOffset;
                };

                exports.getPageScrollLeft = function () {
                    return window.pageXOffset;
                };
            } else {
                exports.getPageScrollTop = function () {
                    return document.body.scrollTop;
                };

                exports.getPageScrollLeft = function () {
                    return document.body.scrollLeft;
                };
            }

            if (window.getComputedStyle) exports.computedStyle = function (element, style) {
                if (style) return (window.getComputedStyle(element, "") || {})[style] || "";
                return window.getComputedStyle(element, "") || {};
            };else exports.computedStyle = function (element, style) {
                if (style) return element.currentStyle[style];
                return element.currentStyle;
            };
            exports.setInnerHtml = function (el, innerHtml) {
                var element = el.cloneNode(false); //document.createElement("div");
                element.innerHTML = innerHtml;
                el.parentNode.replaceChild(element, el);
                return element;
            };

            if ("textContent" in document.documentElement) {
                exports.setInnerText = function (el, innerText) {
                    el.textContent = innerText;
                };

                exports.getInnerText = function (el) {
                    return el.textContent;
                };
            } else {
                exports.setInnerText = function (el, innerText) {
                    el.innerText = innerText;
                };

                exports.getInnerText = function (el) {
                    return el.innerText;
                };
            }

            exports.getParentWindow = function (document) {
                return document.defaultView || document.parentWindow;
            };
        });

        ace.define("ace/lib/oop", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            exports.inherits = function (ctor, superCtor) {
                ctor.super_ = superCtor;
                ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                        value: ctor,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
            };

            exports.mixin = function (obj, mixin) {
                for (var key in mixin) {
                    obj[key] = mixin[key];
                }
                return obj;
            };

            exports.implement = function (proto, mixin) {
                exports.mixin(proto, mixin);
            };
        });

        ace.define("ace/lib/keys", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/oop"], function (require, exports, module) {
            "use strict";

            require("./fixoldbrowsers");

            var oop = require("./oop");
            var Keys = function () {
                var ret = {
                    MODIFIER_KEYS: {
                        16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta'
                    },

                    KEY_MODS: {
                        "ctrl": 1, "alt": 2, "option": 2, "shift": 4,
                        "super": 8, "meta": 8, "command": 8, "cmd": 8
                    },

                    FUNCTION_KEYS: {
                        8: "Backspace",
                        9: "Tab",
                        13: "Return",
                        19: "Pause",
                        27: "Esc",
                        32: "Space",
                        33: "PageUp",
                        34: "PageDown",
                        35: "End",
                        36: "Home",
                        37: "Left",
                        38: "Up",
                        39: "Right",
                        40: "Down",
                        44: "Print",
                        45: "Insert",
                        46: "Delete",
                        96: "Numpad0",
                        97: "Numpad1",
                        98: "Numpad2",
                        99: "Numpad3",
                        100: "Numpad4",
                        101: "Numpad5",
                        102: "Numpad6",
                        103: "Numpad7",
                        104: "Numpad8",
                        105: "Numpad9",
                        '-13': "NumpadEnter",
                        112: "F1",
                        113: "F2",
                        114: "F3",
                        115: "F4",
                        116: "F5",
                        117: "F6",
                        118: "F7",
                        119: "F8",
                        120: "F9",
                        121: "F10",
                        122: "F11",
                        123: "F12",
                        144: "Numlock",
                        145: "Scrolllock"
                    },

                    PRINTABLE_KEYS: {
                        32: ' ', 48: '0', 49: '1', 50: '2', 51: '3', 52: '4', 53: '5',
                        54: '6', 55: '7', 56: '8', 57: '9', 59: ';', 61: '=', 65: 'a',
                        66: 'b', 67: 'c', 68: 'd', 69: 'e', 70: 'f', 71: 'g', 72: 'h',
                        73: 'i', 74: 'j', 75: 'k', 76: 'l', 77: 'm', 78: 'n', 79: 'o',
                        80: 'p', 81: 'q', 82: 'r', 83: 's', 84: 't', 85: 'u', 86: 'v',
                        87: 'w', 88: 'x', 89: 'y', 90: 'z', 107: '+', 109: '-', 110: '.',
                        186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`',
                        219: '[', 220: '\\', 221: ']', 222: "'", 111: '/', 106: '*'
                    }
                };
                var name, i;
                for (i in ret.FUNCTION_KEYS) {
                    name = ret.FUNCTION_KEYS[i].toLowerCase();
                    ret[name] = parseInt(i, 10);
                }
                for (i in ret.PRINTABLE_KEYS) {
                    name = ret.PRINTABLE_KEYS[i].toLowerCase();
                    ret[name] = parseInt(i, 10);
                }
                oop.mixin(ret, ret.MODIFIER_KEYS);
                oop.mixin(ret, ret.PRINTABLE_KEYS);
                oop.mixin(ret, ret.FUNCTION_KEYS);
                ret.enter = ret["return"];
                ret.escape = ret.esc;
                ret.del = ret["delete"];
                ret[173] = '-';

                (function () {
                    var mods = ["cmd", "ctrl", "alt", "shift"];
                    for (var i = Math.pow(2, mods.length); i--;) {
                        ret.KEY_MODS[i] = mods.filter(function (x) {
                            return i & ret.KEY_MODS[x];
                        }).join("-") + "-";
                    }
                })();

                ret.KEY_MODS[0] = "";
                ret.KEY_MODS[-1] = "input-";

                return ret;
            }();
            oop.mixin(exports, Keys);

            exports.keyCodeToString = function (keyCode) {
                var keyString = Keys[keyCode];
                if (typeof keyString != "string") keyString = String.fromCharCode(keyCode);
                return keyString.toLowerCase();
            };
        });

        ace.define("ace/lib/useragent", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            exports.OS = {
                LINUX: "LINUX",
                MAC: "MAC",
                WINDOWS: "WINDOWS"
            };
            exports.getOS = function () {
                if (exports.isMac) {
                    return exports.OS.MAC;
                } else if (exports.isLinux) {
                    return exports.OS.LINUX;
                } else {
                    return exports.OS.WINDOWS;
                }
            };
            if (typeof navigator != "object") return;

            var os = (navigator.platform.match(/mac|win|linux/i) || ["other"])[0].toLowerCase();
            var ua = navigator.userAgent;
            exports.isWin = os == "win";
            exports.isMac = os == "mac";
            exports.isLinux = os == "linux";
            exports.isIE = navigator.appName == "Microsoft Internet Explorer" || navigator.appName.indexOf("MSAppHost") >= 0 ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]) : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]); // for ie

            exports.isOldIE = exports.isIE && exports.isIE < 9;
            exports.isGecko = exports.isMozilla = (window.Controllers || window.controllers) && window.navigator.product === "Gecko";
            exports.isOldGecko = exports.isGecko && parseInt((ua.match(/rv:(\d+)/) || [])[1], 10) < 4;
            exports.isOpera = window.opera && Object.prototype.toString.call(window.opera) == "[object Opera]";
            exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;

            exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;

            exports.isAIR = ua.indexOf("AdobeAIR") >= 0;

            exports.isIPad = ua.indexOf("iPad") >= 0;

            exports.isTouchPad = ua.indexOf("TouchPad") >= 0;

            exports.isChromeOS = ua.indexOf(" CrOS ") >= 0;
        });

        ace.define("ace/lib/event", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function (require, exports, module) {
            "use strict";

            var keys = require("./keys");
            var useragent = require("./useragent");

            var pressedKeys = null;
            var ts = 0;

            exports.addListener = function (elem, type, callback) {
                if (elem.addEventListener) {
                    return elem.addEventListener(type, callback, false);
                }
                if (elem.attachEvent) {
                    var wrapper = function () {
                        callback.call(elem, window.event);
                    };
                    callback._wrapper = wrapper;
                    elem.attachEvent("on" + type, wrapper);
                }
            };

            exports.removeListener = function (elem, type, callback) {
                if (elem.removeEventListener) {
                    return elem.removeEventListener(type, callback, false);
                }
                if (elem.detachEvent) {
                    elem.detachEvent("on" + type, callback._wrapper || callback);
                }
            };
            exports.stopEvent = function (e) {
                exports.stopPropagation(e);
                exports.preventDefault(e);
                return false;
            };

            exports.stopPropagation = function (e) {
                if (e.stopPropagation) e.stopPropagation();else e.cancelBubble = true;
            };

            exports.preventDefault = function (e) {
                if (e.preventDefault) e.preventDefault();else e.returnValue = false;
            };
            exports.getButton = function (e) {
                if (e.type == "dblclick") return 0;
                if (e.type == "contextmenu" || useragent.isMac && e.ctrlKey && !e.altKey && !e.shiftKey) return 2;
                if (e.preventDefault) {
                    return e.button;
                } else {
                    return { 1: 0, 2: 2, 4: 1 }[e.button];
                }
            };

            exports.capture = function (el, eventHandler, releaseCaptureHandler) {
                function onMouseUp(e) {
                    eventHandler && eventHandler(e);
                    releaseCaptureHandler && releaseCaptureHandler(e);

                    exports.removeListener(document, "mousemove", eventHandler, true);
                    exports.removeListener(document, "mouseup", onMouseUp, true);
                    exports.removeListener(document, "dragstart", onMouseUp, true);
                }

                exports.addListener(document, "mousemove", eventHandler, true);
                exports.addListener(document, "mouseup", onMouseUp, true);
                exports.addListener(document, "dragstart", onMouseUp, true);

                return onMouseUp;
            };

            exports.addTouchMoveListener = function (el, callback) {
                if ("ontouchmove" in el) {
                    var startx, starty;
                    exports.addListener(el, "touchstart", function (e) {
                        var touchObj = e.changedTouches[0];
                        startx = touchObj.clientX;
                        starty = touchObj.clientY;
                    });
                    exports.addListener(el, "touchmove", function (e) {
                        var factor = 1,
                            touchObj = e.changedTouches[0];

                        e.wheelX = -(touchObj.clientX - startx) / factor;
                        e.wheelY = -(touchObj.clientY - starty) / factor;

                        startx = touchObj.clientX;
                        starty = touchObj.clientY;

                        callback(e);
                    });
                }
            };

            exports.addMouseWheelListener = function (el, callback) {
                if ("onmousewheel" in el) {
                    exports.addListener(el, "mousewheel", function (e) {
                        var factor = 8;
                        if (e.wheelDeltaX !== undefined) {
                            e.wheelX = -e.wheelDeltaX / factor;
                            e.wheelY = -e.wheelDeltaY / factor;
                        } else {
                            e.wheelX = 0;
                            e.wheelY = -e.wheelDelta / factor;
                        }
                        callback(e);
                    });
                } else if ("onwheel" in el) {
                    exports.addListener(el, "wheel", function (e) {
                        var factor = 0.35;
                        switch (e.deltaMode) {
                            case e.DOM_DELTA_PIXEL:
                                e.wheelX = e.deltaX * factor || 0;
                                e.wheelY = e.deltaY * factor || 0;
                                break;
                            case e.DOM_DELTA_LINE:
                            case e.DOM_DELTA_PAGE:
                                e.wheelX = (e.deltaX || 0) * 5;
                                e.wheelY = (e.deltaY || 0) * 5;
                                break;
                        }

                        callback(e);
                    });
                } else {
                    exports.addListener(el, "DOMMouseScroll", function (e) {
                        if (e.axis && e.axis == e.HORIZONTAL_AXIS) {
                            e.wheelX = (e.detail || 0) * 5;
                            e.wheelY = 0;
                        } else {
                            e.wheelX = 0;
                            e.wheelY = (e.detail || 0) * 5;
                        }
                        callback(e);
                    });
                }
            };

            exports.addMultiMouseDownListener = function (elements, timeouts, eventHandler, callbackName) {
                var clicks = 0;
                var startX, startY, timer;
                var eventNames = {
                    2: "dblclick",
                    3: "tripleclick",
                    4: "quadclick"
                };

                function onMousedown(e) {
                    if (exports.getButton(e) !== 0) {
                        clicks = 0;
                    } else if (e.detail > 1) {
                        clicks++;
                        if (clicks > 4) clicks = 1;
                    } else {
                        clicks = 1;
                    }
                    if (useragent.isIE) {
                        var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
                        if (!timer || isNewClick) clicks = 1;
                        if (timer) clearTimeout(timer);
                        timer = setTimeout(function () {
                            timer = null;
                        }, timeouts[clicks - 1] || 600);

                        if (clicks == 1) {
                            startX = e.clientX;
                            startY = e.clientY;
                        }
                    }

                    e._clicks = clicks;

                    eventHandler[callbackName]("mousedown", e);

                    if (clicks > 4) clicks = 0;else if (clicks > 1) return eventHandler[callbackName](eventNames[clicks], e);
                }
                function onDblclick(e) {
                    clicks = 2;
                    if (timer) clearTimeout(timer);
                    timer = setTimeout(function () {
                        timer = null;
                    }, timeouts[clicks - 1] || 600);
                    eventHandler[callbackName]("mousedown", e);
                    eventHandler[callbackName](eventNames[clicks], e);
                }
                if (!Array.isArray(elements)) elements = [elements];
                elements.forEach(function (el) {
                    exports.addListener(el, "mousedown", onMousedown);
                    if (useragent.isOldIE) exports.addListener(el, "dblclick", onDblclick);
                });
            };

            var getModifierHash = useragent.isMac && useragent.isOpera && !("KeyboardEvent" in window) ? function (e) {
                return 0 | (e.metaKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.ctrlKey ? 8 : 0);
            } : function (e) {
                return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
            };

            exports.getModifierString = function (e) {
                return keys.KEY_MODS[getModifierHash(e)];
            };

            function normalizeCommandKeys(callback, e, keyCode) {
                var hashId = getModifierHash(e);

                if (!useragent.isMac && pressedKeys) {
                    if (e.getModifierState && (e.getModifierState("OS") || e.getModifierState("Win"))) hashId |= 8;
                    if (pressedKeys.altGr) {
                        if ((3 & hashId) != 3) pressedKeys.altGr = 0;else return;
                    }
                    if (keyCode === 18 || keyCode === 17) {
                        var location = "location" in e ? e.location : e.keyLocation;
                        if (keyCode === 17 && location === 1) {
                            if (pressedKeys[keyCode] == 1) ts = e.timeStamp;
                        } else if (keyCode === 18 && hashId === 3 && location === 2) {
                            var dt = e.timeStamp - ts;
                            if (dt < 50) pressedKeys.altGr = true;
                        }
                    }
                }

                if (keyCode in keys.MODIFIER_KEYS) {
                    keyCode = -1;
                }
                if (hashId & 8 && keyCode >= 91 && keyCode <= 93) {
                    keyCode = -1;
                }

                if (!hashId && keyCode === 13) {
                    var location = "location" in e ? e.location : e.keyLocation;
                    if (location === 3) {
                        callback(e, hashId, -keyCode);
                        if (e.defaultPrevented) return;
                    }
                }

                if (useragent.isChromeOS && hashId & 8) {
                    callback(e, hashId, keyCode);
                    if (e.defaultPrevented) return;else hashId &= ~8;
                }
                if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
                    return false;
                }

                return callback(e, hashId, keyCode);
            }

            exports.addCommandKeyListener = function (el, callback) {
                var addListener = exports.addListener;
                if (useragent.isOldGecko || useragent.isOpera && !("KeyboardEvent" in window)) {
                    var lastKeyDownKeyCode = null;
                    addListener(el, "keydown", function (e) {
                        lastKeyDownKeyCode = e.keyCode;
                    });
                    addListener(el, "keypress", function (e) {
                        return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
                    });
                } else {
                    var lastDefaultPrevented = null;

                    addListener(el, "keydown", function (e) {
                        pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
                        var result = normalizeCommandKeys(callback, e, e.keyCode);
                        lastDefaultPrevented = e.defaultPrevented;
                        return result;
                    });

                    addListener(el, "keypress", function (e) {
                        if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
                            exports.stopEvent(e);
                            lastDefaultPrevented = null;
                        }
                    });

                    addListener(el, "keyup", function (e) {
                        pressedKeys[e.keyCode] = null;
                    });

                    if (!pressedKeys) {
                        resetPressedKeys();
                        addListener(window, "focus", resetPressedKeys);
                    }
                }
            };
            function resetPressedKeys() {
                pressedKeys = Object.create(null);
            }

            if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
                var postMessageId = 1;
                exports.nextTick = function (callback, win) {
                    win = win || window;
                    var messageName = "zero-timeout-message-" + postMessageId;
                    exports.addListener(win, "message", function listener(e) {
                        if (e.data == messageName) {
                            exports.stopPropagation(e);
                            exports.removeListener(win, "message", listener);
                            callback();
                        }
                    });
                    win.postMessage(messageName, "*");
                };
            }

            exports.nextFrame = typeof window == "object" && (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame);

            if (exports.nextFrame) exports.nextFrame = exports.nextFrame.bind(window);else exports.nextFrame = function (callback) {
                setTimeout(callback, 17);
            };
        });

        ace.define("ace/lib/lang", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            exports.last = function (a) {
                return a[a.length - 1];
            };

            exports.stringReverse = function (string) {
                return string.split("").reverse().join("");
            };

            exports.stringRepeat = function (string, count) {
                var result = '';
                while (count > 0) {
                    if (count & 1) result += string;

                    if (count >>= 1) string += string;
                }
                return result;
            };

            var trimBeginRegexp = /^\s\s*/;
            var trimEndRegexp = /\s\s*$/;

            exports.stringTrimLeft = function (string) {
                return string.replace(trimBeginRegexp, '');
            };

            exports.stringTrimRight = function (string) {
                return string.replace(trimEndRegexp, '');
            };

            exports.copyObject = function (obj) {
                var copy = {};
                for (var key in obj) {
                    copy[key] = obj[key];
                }
                return copy;
            };

            exports.copyArray = function (array) {
                var copy = [];
                for (var i = 0, l = array.length; i < l; i++) {
                    if (array[i] && typeof array[i] == "object") copy[i] = this.copyObject(array[i]);else copy[i] = array[i];
                }
                return copy;
            };

            exports.deepCopy = function deepCopy(obj) {
                if (typeof obj !== "object" || !obj) return obj;
                var copy;
                if (Array.isArray(obj)) {
                    copy = [];
                    for (var key = 0; key < obj.length; key++) {
                        copy[key] = deepCopy(obj[key]);
                    }
                    return copy;
                }
                if (Object.prototype.toString.call(obj) !== "[object Object]") return obj;

                copy = {};
                for (var key in obj) copy[key] = deepCopy(obj[key]);
                return copy;
            };

            exports.arrayToMap = function (arr) {
                var map = {};
                for (var i = 0; i < arr.length; i++) {
                    map[arr[i]] = 1;
                }
                return map;
            };

            exports.createMap = function (props) {
                var map = Object.create(null);
                for (var i in props) {
                    map[i] = props[i];
                }
                return map;
            };
            exports.arrayRemove = function (array, value) {
                for (var i = 0; i <= array.length; i++) {
                    if (value === array[i]) {
                        array.splice(i, 1);
                    }
                }
            };

            exports.escapeRegExp = function (str) {
                return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
            };

            exports.escapeHTML = function (str) {
                return str.replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
            };

            exports.getMatchOffsets = function (string, regExp) {
                var matches = [];

                string.replace(regExp, function (str) {
                    matches.push({
                        offset: arguments[arguments.length - 2],
                        length: str.length
                    });
                });

                return matches;
            };
            exports.deferredCall = function (fcn) {
                var timer = null;
                var callback = function () {
                    timer = null;
                    fcn();
                };

                var deferred = function (timeout) {
                    deferred.cancel();
                    timer = setTimeout(callback, timeout || 0);
                    return deferred;
                };

                deferred.schedule = deferred;

                deferred.call = function () {
                    this.cancel();
                    fcn();
                    return deferred;
                };

                deferred.cancel = function () {
                    clearTimeout(timer);
                    timer = null;
                    return deferred;
                };

                deferred.isPending = function () {
                    return timer;
                };

                return deferred;
            };

            exports.delayedCall = function (fcn, defaultTimeout) {
                var timer = null;
                var callback = function () {
                    timer = null;
                    fcn();
                };

                var _self = function (timeout) {
                    if (timer == null) timer = setTimeout(callback, timeout || defaultTimeout);
                };

                _self.delay = function (timeout) {
                    timer && clearTimeout(timer);
                    timer = setTimeout(callback, timeout || defaultTimeout);
                };
                _self.schedule = _self;

                _self.call = function () {
                    this.cancel();
                    fcn();
                };

                _self.cancel = function () {
                    timer && clearTimeout(timer);
                    timer = null;
                };

                _self.isPending = function () {
                    return timer;
                };

                return _self;
            };
        });

        ace.define("ace/keyboard/textinput", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/lib/dom", "ace/lib/lang"], function (require, exports, module) {
            "use strict";

            var event = require("../lib/event");
            var useragent = require("../lib/useragent");
            var dom = require("../lib/dom");
            var lang = require("../lib/lang");
            var BROKEN_SETDATA = useragent.isChrome < 18;
            var USE_IE_MIME_TYPE = useragent.isIE;

            var TextInput = function (parentNode, host) {
                var text = dom.createElement("textarea");
                text.className = "ace_text-input";

                if (useragent.isTouchPad) text.setAttribute("x-palm-disable-auto-cap", true);

                text.setAttribute("wrap", "off");
                text.setAttribute("autocorrect", "off");
                text.setAttribute("autocapitalize", "off");
                text.setAttribute("spellcheck", false);

                text.style.opacity = "0";
                if (useragent.isOldIE) text.style.top = "-1000px";
                parentNode.insertBefore(text, parentNode.firstChild);

                var PLACEHOLDER = "\x01\x01";

                var copied = false;
                var pasted = false;
                var inComposition = false;
                var tempStyle = '';
                var isSelectionEmpty = true;
                try {
                    var isFocused = document.activeElement === text;
                } catch (e) {}

                event.addListener(text, "blur", function (e) {
                    host.onBlur(e);
                    isFocused = false;
                });
                event.addListener(text, "focus", function (e) {
                    isFocused = true;
                    host.onFocus(e);
                    resetSelection();
                });
                this.focus = function () {
                    if (tempStyle) return text.focus();
                    var top = text.style.top;
                    text.style.position = "fixed";
                    text.style.top = "0px";
                    text.focus();
                    setTimeout(function () {
                        text.style.position = "";
                        if (text.style.top == "0px") text.style.top = top;
                    }, 0);
                };
                this.blur = function () {
                    text.blur();
                };
                this.isFocused = function () {
                    return isFocused;
                };
                var syncSelection = lang.delayedCall(function () {
                    isFocused && resetSelection(isSelectionEmpty);
                });
                var syncValue = lang.delayedCall(function () {
                    if (!inComposition) {
                        text.value = PLACEHOLDER;
                        isFocused && resetSelection();
                    }
                });

                function resetSelection(isEmpty) {
                    if (inComposition) return;
                    inComposition = true;

                    if (inputHandler) {
                        selectionStart = 0;
                        selectionEnd = isEmpty ? 0 : text.value.length - 1;
                    } else {
                        var selectionStart = isEmpty ? 2 : 1;
                        var selectionEnd = 2;
                    }
                    try {
                        text.setSelectionRange(selectionStart, selectionEnd);
                    } catch (e) {}

                    inComposition = false;
                }

                function resetValue() {
                    if (inComposition) return;
                    text.value = PLACEHOLDER;
                    if (useragent.isWebKit) syncValue.schedule();
                }

                useragent.isWebKit || host.addEventListener('changeSelection', function () {
                    if (host.selection.isEmpty() != isSelectionEmpty) {
                        isSelectionEmpty = !isSelectionEmpty;
                        syncSelection.schedule();
                    }
                });

                resetValue();
                if (isFocused) host.onFocus();

                var isAllSelected = function (text) {
                    return text.selectionStart === 0 && text.selectionEnd === text.value.length;
                };
                if (!text.setSelectionRange && text.createTextRange) {
                    text.setSelectionRange = function (selectionStart, selectionEnd) {
                        var range = this.createTextRange();
                        range.collapse(true);
                        range.moveStart('character', selectionStart);
                        range.moveEnd('character', selectionEnd);
                        range.select();
                    };
                    isAllSelected = function (text) {
                        try {
                            var range = text.ownerDocument.selection.createRange();
                        } catch (e) {}
                        if (!range || range.parentElement() != text) return false;
                        return range.text == text.value;
                    };
                }
                if (useragent.isOldIE) {
                    var inPropertyChange = false;
                    var onPropertyChange = function (e) {
                        if (inPropertyChange) return;
                        var data = text.value;
                        if (inComposition || !data || data == PLACEHOLDER) return;
                        if (e && data == PLACEHOLDER[0]) return syncProperty.schedule();

                        sendText(data);
                        inPropertyChange = true;
                        resetValue();
                        inPropertyChange = false;
                    };
                    var syncProperty = lang.delayedCall(onPropertyChange);
                    event.addListener(text, "propertychange", onPropertyChange);

                    var keytable = { 13: 1, 27: 1 };
                    event.addListener(text, "keyup", function (e) {
                        if (inComposition && (!text.value || keytable[e.keyCode])) setTimeout(onCompositionEnd, 0);
                        if ((text.value.charCodeAt(0) || 0) < 129) {
                            return syncProperty.call();
                        }
                        inComposition ? onCompositionUpdate() : onCompositionStart();
                    });
                    event.addListener(text, "keydown", function (e) {
                        syncProperty.schedule(50);
                    });
                }

                var onSelect = function (e) {
                    if (copied) {
                        copied = false;
                    } else if (isAllSelected(text)) {
                        host.selectAll();
                        resetSelection();
                    } else if (inputHandler) {
                        resetSelection(host.selection.isEmpty());
                    }
                };

                var inputHandler = null;
                this.setInputHandler = function (cb) {
                    inputHandler = cb;
                };
                this.getInputHandler = function () {
                    return inputHandler;
                };
                var afterContextMenu = false;

                var sendText = function (data) {
                    if (inputHandler) {
                        data = inputHandler(data);
                        inputHandler = null;
                    }
                    if (pasted) {
                        resetSelection();
                        if (data) host.onPaste(data);
                        pasted = false;
                    } else if (data == PLACEHOLDER.charAt(0)) {
                        if (afterContextMenu) host.execCommand("del", { source: "ace" });else // some versions of android do not fire keydown when pressing backspace
                            host.execCommand("backspace", { source: "ace" });
                    } else {
                        if (data.substring(0, 2) == PLACEHOLDER) data = data.substr(2);else if (data.charAt(0) == PLACEHOLDER.charAt(0)) data = data.substr(1);else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0)) data = data.slice(0, -1);
                        if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0)) data = data.slice(0, -1);

                        if (data) host.onTextInput(data);
                    }
                    if (afterContextMenu) afterContextMenu = false;
                };
                var onInput = function (e) {
                    if (inComposition) return;
                    var data = text.value;
                    sendText(data);
                    resetValue();
                };

                var handleClipboardData = function (e, data, forceIEMime) {
                    var clipboardData = e.clipboardData || window.clipboardData;
                    if (!clipboardData || BROKEN_SETDATA) return;
                    var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
                    try {
                        if (data) {
                            return clipboardData.setData(mime, data) !== false;
                        } else {
                            return clipboardData.getData(mime);
                        }
                    } catch (e) {
                        if (!forceIEMime) return handleClipboardData(e, data, true);
                    }
                };

                var doCopy = function (e, isCut) {
                    var data = host.getCopyText();
                    if (!data) return event.preventDefault(e);

                    if (handleClipboardData(e, data)) {
                        isCut ? host.onCut() : host.onCopy();
                        event.preventDefault(e);
                    } else {
                        copied = true;
                        text.value = data;
                        text.select();
                        setTimeout(function () {
                            copied = false;
                            resetValue();
                            resetSelection();
                            isCut ? host.onCut() : host.onCopy();
                        });
                    }
                };

                var onCut = function (e) {
                    doCopy(e, true);
                };

                var onCopy = function (e) {
                    doCopy(e, false);
                };

                var onPaste = function (e) {
                    var data = handleClipboardData(e);
                    if (typeof data == "string") {
                        if (data) host.onPaste(data, e);
                        if (useragent.isIE) setTimeout(resetSelection);
                        event.preventDefault(e);
                    } else {
                        text.value = "";
                        pasted = true;
                    }
                };

                event.addCommandKeyListener(text, host.onCommandKey.bind(host));

                event.addListener(text, "select", onSelect);

                event.addListener(text, "input", onInput);

                event.addListener(text, "cut", onCut);
                event.addListener(text, "copy", onCopy);
                event.addListener(text, "paste", onPaste);
                if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)) {
                    event.addListener(parentNode, "keydown", function (e) {
                        if (useragent.isMac && !e.metaKey || !e.ctrlKey) return;

                        switch (e.keyCode) {
                            case 67:
                                onCopy(e);
                                break;
                            case 86:
                                onPaste(e);
                                break;
                            case 88:
                                onCut(e);
                                break;
                        }
                    });
                }
                var onCompositionStart = function (e) {
                    if (inComposition || !host.onCompositionStart || host.$readOnly) return;
                    inComposition = {};
                    inComposition.canUndo = host.session.$undoManager;
                    host.onCompositionStart();
                    setTimeout(onCompositionUpdate, 0);
                    host.on("mousedown", onCompositionEnd);
                    if (inComposition.canUndo && !host.selection.isEmpty()) {
                        host.insert("");
                        host.session.markUndoGroup();
                        host.selection.clearSelection();
                    }
                    host.session.markUndoGroup();
                };

                var onCompositionUpdate = function () {
                    if (!inComposition || !host.onCompositionUpdate || host.$readOnly) return;
                    var val = text.value.replace(/\x01/g, "");
                    if (inComposition.lastValue === val) return;

                    host.onCompositionUpdate(val);
                    if (inComposition.lastValue) host.undo();
                    if (inComposition.canUndo) inComposition.lastValue = val;
                    if (inComposition.lastValue) {
                        var r = host.selection.getRange();
                        host.insert(inComposition.lastValue);
                        host.session.markUndoGroup();
                        inComposition.range = host.selection.getRange();
                        host.selection.setRange(r);
                        host.selection.clearSelection();
                    }
                };

                var onCompositionEnd = function (e) {
                    if (!host.onCompositionEnd || host.$readOnly) return;
                    var c = inComposition;
                    inComposition = false;
                    var timer = setTimeout(function () {
                        timer = null;
                        var str = text.value.replace(/\x01/g, "");
                        if (inComposition) return;else if (str == c.lastValue) resetValue();else if (!c.lastValue && str) {
                            resetValue();
                            sendText(str);
                        }
                    });
                    inputHandler = function compositionInputHandler(str) {
                        if (timer) clearTimeout(timer);
                        str = str.replace(/\x01/g, "");
                        if (str == c.lastValue) return "";
                        if (c.lastValue && timer) host.undo();
                        return str;
                    };
                    host.onCompositionEnd();
                    host.removeListener("mousedown", onCompositionEnd);
                    if (e.type == "compositionend" && c.range) {
                        host.selection.setRange(c.range);
                    }
                    if (useragent.isChrome && useragent.isChrome >= 53) {
                        onInput();
                    }
                };

                var syncComposition = lang.delayedCall(onCompositionUpdate, 50);

                event.addListener(text, "compositionstart", onCompositionStart);
                if (useragent.isGecko) {
                    event.addListener(text, "text", function () {
                        syncComposition.schedule();
                    });
                } else {
                    event.addListener(text, "keyup", function () {
                        syncComposition.schedule();
                    });
                    event.addListener(text, "keydown", function () {
                        syncComposition.schedule();
                    });
                }
                event.addListener(text, "compositionend", onCompositionEnd);

                this.getElement = function () {
                    return text;
                };

                this.setReadOnly = function (readOnly) {
                    text.readOnly = readOnly;
                };

                this.onContextMenu = function (e) {
                    afterContextMenu = true;
                    resetSelection(host.selection.isEmpty());
                    host._emit("nativecontextmenu", { target: host, domEvent: e });
                    this.moveToMouse(e, true);
                };

                this.moveToMouse = function (e, bringToFront) {
                    if (!bringToFront && useragent.isOldIE) return;
                    if (!tempStyle) tempStyle = text.style.cssText;
                    text.style.cssText = (bringToFront ? "z-index:100000;" : "") + "height:" + text.style.height + ";" + (useragent.isIE ? "opacity:0.1;" : "");

                    var rect = host.container.getBoundingClientRect();
                    var style = dom.computedStyle(host.container);
                    var top = rect.top + (parseInt(style.borderTopWidth) || 0);
                    var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
                    var maxTop = rect.bottom - top - text.clientHeight - 2;
                    var move = function (e) {
                        text.style.left = e.clientX - left - 2 + "px";
                        text.style.top = Math.min(e.clientY - top - 2, maxTop) + "px";
                    };
                    move(e);

                    if (e.type != "mousedown") return;

                    if (host.renderer.$keepTextAreaAtCursor) host.renderer.$keepTextAreaAtCursor = null;

                    clearTimeout(closeTimeout);
                    if (useragent.isWin && !useragent.isOldIE) event.capture(host.container, move, onContextMenuClose);
                };

                this.onContextMenuClose = onContextMenuClose;
                var closeTimeout;
                function onContextMenuClose() {
                    clearTimeout(closeTimeout);
                    closeTimeout = setTimeout(function () {
                        if (tempStyle) {
                            text.style.cssText = tempStyle;
                            tempStyle = '';
                        }
                        if (host.renderer.$keepTextAreaAtCursor == null) {
                            host.renderer.$keepTextAreaAtCursor = true;
                            host.renderer.$moveTextAreaToCursor();
                        }
                    }, useragent.isOldIE ? 200 : 0);
                }

                var onContextMenu = function (e) {
                    host.textInput.onContextMenu(e);
                    onContextMenuClose();
                };
                event.addListener(text, "mouseup", onContextMenu);
                event.addListener(text, "mousedown", function (e) {
                    e.preventDefault();
                    onContextMenuClose();
                });
                event.addListener(host.renderer.scroller, "contextmenu", onContextMenu);
                event.addListener(text, "contextmenu", onContextMenu);
            };

            exports.TextInput = TextInput;
        });

        ace.define("ace/mouse/default_handlers", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/lib/useragent"], function (require, exports, module) {
            "use strict";

            var dom = require("../lib/dom");
            var event = require("../lib/event");
            var useragent = require("../lib/useragent");

            var DRAG_OFFSET = 0; // pixels

            function DefaultHandlers(mouseHandler) {
                mouseHandler.$clickSelection = null;

                var editor = mouseHandler.editor;
                editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
                editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
                editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
                editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
                editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
                editor.setDefaultHandler("touchmove", this.onTouchMove.bind(mouseHandler));

                var exports = ["select", "startSelect", "selectEnd", "selectAllEnd", "selectByWordsEnd", "selectByLinesEnd", "dragWait", "dragWaitEnd", "focusWait"];

                exports.forEach(function (x) {
                    mouseHandler[x] = this[x];
                }, this);

                mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
                mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
            }

            (function () {

                this.onMouseDown = function (ev) {
                    var inSelection = ev.inSelection();
                    var pos = ev.getDocumentPosition();
                    this.mousedownEvent = ev;
                    var editor = this.editor;

                    var button = ev.getButton();
                    if (button !== 0) {
                        var selectionRange = editor.getSelectionRange();
                        var selectionEmpty = selectionRange.isEmpty();
                        editor.$blockScrolling++;
                        if (selectionEmpty || button == 1) editor.selection.moveToPosition(pos);
                        editor.$blockScrolling--;
                        if (button == 2) editor.textInput.onContextMenu(ev.domEvent);
                        return; // stopping event here breaks contextmenu on ff mac
                    }

                    this.mousedownEvent.time = Date.now();
                    if (inSelection && !editor.isFocused()) {
                        editor.focus();
                        if (this.$focusTimout && !this.$clickSelection && !editor.inMultiSelectMode) {
                            this.setState("focusWait");
                            this.captureMouse(ev);
                            return;
                        }
                    }

                    this.captureMouse(ev);
                    this.startSelect(pos, ev.domEvent._clicks > 1);
                    return ev.preventDefault();
                };

                this.startSelect = function (pos, waitForClickSelection) {
                    pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
                    var editor = this.editor;
                    editor.$blockScrolling++;
                    if (this.mousedownEvent.getShiftKey()) editor.selection.selectToPosition(pos);else if (!waitForClickSelection) editor.selection.moveToPosition(pos);
                    if (!waitForClickSelection) this.select();
                    if (editor.renderer.scroller.setCapture) {
                        editor.renderer.scroller.setCapture();
                    }
                    editor.setStyle("ace_selecting");
                    this.setState("select");
                    editor.$blockScrolling--;
                };

                this.select = function () {
                    var anchor,
                        editor = this.editor;
                    var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
                    editor.$blockScrolling++;
                    if (this.$clickSelection) {
                        var cmp = this.$clickSelection.comparePoint(cursor);

                        if (cmp == -1) {
                            anchor = this.$clickSelection.end;
                        } else if (cmp == 1) {
                            anchor = this.$clickSelection.start;
                        } else {
                            var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                            cursor = orientedRange.cursor;
                            anchor = orientedRange.anchor;
                        }
                        editor.selection.setSelectionAnchor(anchor.row, anchor.column);
                    }
                    editor.selection.selectToPosition(cursor);
                    editor.$blockScrolling--;
                    editor.renderer.scrollCursorIntoView();
                };

                this.extendSelectionBy = function (unitName) {
                    var anchor,
                        editor = this.editor;
                    var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
                    var range = editor.selection[unitName](cursor.row, cursor.column);
                    editor.$blockScrolling++;
                    if (this.$clickSelection) {
                        var cmpStart = this.$clickSelection.comparePoint(range.start);
                        var cmpEnd = this.$clickSelection.comparePoint(range.end);

                        if (cmpStart == -1 && cmpEnd <= 0) {
                            anchor = this.$clickSelection.end;
                            if (range.end.row != cursor.row || range.end.column != cursor.column) cursor = range.start;
                        } else if (cmpEnd == 1 && cmpStart >= 0) {
                            anchor = this.$clickSelection.start;
                            if (range.start.row != cursor.row || range.start.column != cursor.column) cursor = range.end;
                        } else if (cmpStart == -1 && cmpEnd == 1) {
                            cursor = range.end;
                            anchor = range.start;
                        } else {
                            var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                            cursor = orientedRange.cursor;
                            anchor = orientedRange.anchor;
                        }
                        editor.selection.setSelectionAnchor(anchor.row, anchor.column);
                    }
                    editor.selection.selectToPosition(cursor);
                    editor.$blockScrolling--;
                    editor.renderer.scrollCursorIntoView();
                };

                this.selectEnd = this.selectAllEnd = this.selectByWordsEnd = this.selectByLinesEnd = function () {
                    this.$clickSelection = null;
                    this.editor.unsetStyle("ace_selecting");
                    if (this.editor.renderer.scroller.releaseCapture) {
                        this.editor.renderer.scroller.releaseCapture();
                    }
                };

                this.focusWait = function () {
                    var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
                    var time = Date.now();

                    if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimout) this.startSelect(this.mousedownEvent.getDocumentPosition());
                };

                this.onDoubleClick = function (ev) {
                    var pos = ev.getDocumentPosition();
                    var editor = this.editor;
                    var session = editor.session;

                    var range = session.getBracketRange(pos);
                    if (range) {
                        if (range.isEmpty()) {
                            range.start.column--;
                            range.end.column++;
                        }
                        this.setState("select");
                    } else {
                        range = editor.selection.getWordRange(pos.row, pos.column);
                        this.setState("selectByWords");
                    }
                    this.$clickSelection = range;
                    this.select();
                };

                this.onTripleClick = function (ev) {
                    var pos = ev.getDocumentPosition();
                    var editor = this.editor;

                    this.setState("selectByLines");
                    var range = editor.getSelectionRange();
                    if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
                        this.$clickSelection = editor.selection.getLineRange(range.start.row);
                        this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
                    } else {
                        this.$clickSelection = editor.selection.getLineRange(pos.row);
                    }
                    this.select();
                };

                this.onQuadClick = function (ev) {
                    var editor = this.editor;

                    editor.selectAll();
                    this.$clickSelection = editor.getSelectionRange();
                    this.setState("selectAll");
                };

                this.onMouseWheel = function (ev) {
                    if (ev.getAccelKey()) return;
                    if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
                        ev.wheelX = ev.wheelY;
                        ev.wheelY = 0;
                    }

                    var t = ev.domEvent.timeStamp;
                    var dt = t - (this.$lastScrollTime || 0);

                    var editor = this.editor;
                    var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
                    if (isScrolable || dt < 200) {
                        this.$lastScrollTime = t;
                        editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
                        return ev.stop();
                    }
                };

                this.onTouchMove = function (ev) {
                    var t = ev.domEvent.timeStamp;
                    var dt = t - (this.$lastScrollTime || 0);

                    var editor = this.editor;
                    var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
                    if (isScrolable || dt < 200) {
                        this.$lastScrollTime = t;
                        editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
                        return ev.stop();
                    }
                };
            }).call(DefaultHandlers.prototype);

            exports.DefaultHandlers = DefaultHandlers;

            function calcDistance(ax, ay, bx, by) {
                return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
            }

            function calcRangeOrientation(range, cursor) {
                if (range.start.row == range.end.row) var cmp = 2 * cursor.column - range.start.column - range.end.column;else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column) var cmp = cursor.column - 4;else var cmp = 2 * cursor.row - range.start.row - range.end.row;

                if (cmp < 0) return { cursor: range.start, anchor: range.end };else return { cursor: range.end, anchor: range.start };
            }
        });

        ace.define("ace/tooltip", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var dom = require("./lib/dom");
            function Tooltip(parentNode) {
                this.isOpen = false;
                this.$element = null;
                this.$parentNode = parentNode;
            }

            (function () {
                this.$init = function () {
                    this.$element = dom.createElement("div");
                    this.$element.className = "ace_tooltip";
                    this.$element.style.display = "none";
                    this.$parentNode.appendChild(this.$element);
                    return this.$element;
                };
                this.getElement = function () {
                    return this.$element || this.$init();
                };
                this.setText = function (text) {
                    dom.setInnerText(this.getElement(), text);
                };
                this.setHtml = function (html) {
                    this.getElement().innerHTML = html;
                };
                this.setPosition = function (x, y) {
                    this.getElement().style.left = x + "px";
                    this.getElement().style.top = y + "px";
                };
                this.setClassName = function (className) {
                    dom.addCssClass(this.getElement(), className);
                };
                this.show = function (text, x, y) {
                    if (text != null) this.setText(text);
                    if (x != null && y != null) this.setPosition(x, y);
                    if (!this.isOpen) {
                        this.getElement().style.display = "block";
                        this.isOpen = true;
                    }
                };

                this.hide = function () {
                    if (this.isOpen) {
                        this.getElement().style.display = "none";
                        this.isOpen = false;
                    }
                };
                this.getHeight = function () {
                    return this.getElement().offsetHeight;
                };
                this.getWidth = function () {
                    return this.getElement().offsetWidth;
                };
            }).call(Tooltip.prototype);

            exports.Tooltip = Tooltip;
        });

        ace.define("ace/mouse/default_gutter_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/event", "ace/tooltip"], function (require, exports, module) {
            "use strict";

            var dom = require("../lib/dom");
            var oop = require("../lib/oop");
            var event = require("../lib/event");
            var Tooltip = require("../tooltip").Tooltip;

            function GutterHandler(mouseHandler) {
                var editor = mouseHandler.editor;
                var gutter = editor.renderer.$gutterLayer;
                var tooltip = new GutterTooltip(editor.container);

                mouseHandler.editor.setDefaultHandler("guttermousedown", function (e) {
                    if (!editor.isFocused() || e.getButton() != 0) return;
                    var gutterRegion = gutter.getRegion(e);

                    if (gutterRegion == "foldWidgets") return;

                    var row = e.getDocumentPosition().row;
                    var selection = editor.session.selection;

                    if (e.getShiftKey()) selection.selectTo(row, 0);else {
                        if (e.domEvent.detail == 2) {
                            editor.selectAll();
                            return e.preventDefault();
                        }
                        mouseHandler.$clickSelection = editor.selection.getLineRange(row);
                    }
                    mouseHandler.setState("selectByLines");
                    mouseHandler.captureMouse(e);
                    return e.preventDefault();
                });

                var tooltipTimeout, mouseEvent, tooltipAnnotation;

                function showTooltip() {
                    var row = mouseEvent.getDocumentPosition().row;
                    var annotation = gutter.$annotations[row];
                    if (!annotation) return hideTooltip();

                    var maxRow = editor.session.getLength();
                    if (row == maxRow) {
                        var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
                        var pos = mouseEvent.$pos;
                        if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column)) return hideTooltip();
                    }

                    if (tooltipAnnotation == annotation) return;
                    tooltipAnnotation = annotation.text.join("<br/>");

                    tooltip.setHtml(tooltipAnnotation);
                    tooltip.show();
                    editor._signal("showGutterTooltip", tooltip);
                    editor.on("mousewheel", hideTooltip);

                    if (mouseHandler.$tooltipFollowsMouse) {
                        moveTooltip(mouseEvent);
                    } else {
                        var gutterElement = mouseEvent.domEvent.target;
                        var rect = gutterElement.getBoundingClientRect();
                        var style = tooltip.getElement().style;
                        style.left = rect.right + "px";
                        style.top = rect.bottom + "px";
                    }
                }

                function hideTooltip() {
                    if (tooltipTimeout) tooltipTimeout = clearTimeout(tooltipTimeout);
                    if (tooltipAnnotation) {
                        tooltip.hide();
                        tooltipAnnotation = null;
                        editor._signal("hideGutterTooltip", tooltip);
                        editor.removeEventListener("mousewheel", hideTooltip);
                    }
                }

                function moveTooltip(e) {
                    tooltip.setPosition(e.x, e.y);
                }

                mouseHandler.editor.setDefaultHandler("guttermousemove", function (e) {
                    var target = e.domEvent.target || e.domEvent.srcElement;
                    if (dom.hasCssClass(target, "ace_fold-widget")) return hideTooltip();

                    if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse) moveTooltip(e);

                    mouseEvent = e;
                    if (tooltipTimeout) return;
                    tooltipTimeout = setTimeout(function () {
                        tooltipTimeout = null;
                        if (mouseEvent && !mouseHandler.isMousePressed) showTooltip();else hideTooltip();
                    }, 50);
                });

                event.addListener(editor.renderer.$gutter, "mouseout", function (e) {
                    mouseEvent = null;
                    if (!tooltipAnnotation || tooltipTimeout) return;

                    tooltipTimeout = setTimeout(function () {
                        tooltipTimeout = null;
                        hideTooltip();
                    }, 50);
                });

                editor.on("changeSession", hideTooltip);
            }

            function GutterTooltip(parentNode) {
                Tooltip.call(this, parentNode);
            }

            oop.inherits(GutterTooltip, Tooltip);

            (function () {
                this.setPosition = function (x, y) {
                    var windowWidth = window.innerWidth || document.documentElement.clientWidth;
                    var windowHeight = window.innerHeight || document.documentElement.clientHeight;
                    var width = this.getWidth();
                    var height = this.getHeight();
                    x += 15;
                    y += 15;
                    if (x + width > windowWidth) {
                        x -= x + width - windowWidth;
                    }
                    if (y + height > windowHeight) {
                        y -= 20 + height;
                    }
                    Tooltip.prototype.setPosition.call(this, x, y);
                };
            }).call(GutterTooltip.prototype);

            exports.GutterHandler = GutterHandler;
        });

        ace.define("ace/mouse/mouse_event", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function (require, exports, module) {
            "use strict";

            var event = require("../lib/event");
            var useragent = require("../lib/useragent");
            var MouseEvent = exports.MouseEvent = function (domEvent, editor) {
                this.domEvent = domEvent;
                this.editor = editor;

                this.x = this.clientX = domEvent.clientX;
                this.y = this.clientY = domEvent.clientY;

                this.$pos = null;
                this.$inSelection = null;

                this.propagationStopped = false;
                this.defaultPrevented = false;
            };

            (function () {

                this.stopPropagation = function () {
                    event.stopPropagation(this.domEvent);
                    this.propagationStopped = true;
                };

                this.preventDefault = function () {
                    event.preventDefault(this.domEvent);
                    this.defaultPrevented = true;
                };

                this.stop = function () {
                    this.stopPropagation();
                    this.preventDefault();
                };
                this.getDocumentPosition = function () {
                    if (this.$pos) return this.$pos;

                    this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
                    return this.$pos;
                };
                this.inSelection = function () {
                    if (this.$inSelection !== null) return this.$inSelection;

                    var editor = this.editor;

                    var selectionRange = editor.getSelectionRange();
                    if (selectionRange.isEmpty()) this.$inSelection = false;else {
                        var pos = this.getDocumentPosition();
                        this.$inSelection = selectionRange.contains(pos.row, pos.column);
                    }

                    return this.$inSelection;
                };
                this.getButton = function () {
                    return event.getButton(this.domEvent);
                };
                this.getShiftKey = function () {
                    return this.domEvent.shiftKey;
                };

                this.getAccelKey = useragent.isMac ? function () {
                    return this.domEvent.metaKey;
                } : function () {
                    return this.domEvent.ctrlKey;
                };
            }).call(MouseEvent.prototype);
        });

        ace.define("ace/mouse/dragdrop_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/lib/useragent"], function (require, exports, module) {
            "use strict";

            var dom = require("../lib/dom");
            var event = require("../lib/event");
            var useragent = require("../lib/useragent");

            var AUTOSCROLL_DELAY = 200;
            var SCROLL_CURSOR_DELAY = 200;
            var SCROLL_CURSOR_HYSTERESIS = 5;

            function DragdropHandler(mouseHandler) {

                var editor = mouseHandler.editor;

                var blankImage = dom.createElement("img");
                blankImage.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
                if (useragent.isOpera) blankImage.style.cssText = "width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;";

                var exports = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];

                exports.forEach(function (x) {
                    mouseHandler[x] = this[x];
                }, this);
                editor.addEventListener("mousedown", this.onMouseDown.bind(mouseHandler));

                var mouseTarget = editor.container;
                var dragSelectionMarker, x, y;
                var timerId, range;
                var dragCursor,
                    counter = 0;
                var dragOperation;
                var isInternal;
                var autoScrollStartTime;
                var cursorMovedTime;
                var cursorPointOnCaretMoved;

                this.onDragStart = function (e) {
                    if (this.cancelDrag || !mouseTarget.draggable) {
                        var self = this;
                        setTimeout(function () {
                            self.startSelect();
                            self.captureMouse(e);
                        }, 0);
                        return e.preventDefault();
                    }
                    range = editor.getSelectionRange();

                    var dataTransfer = e.dataTransfer;
                    dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
                    if (useragent.isOpera) {
                        editor.container.appendChild(blankImage);
                        blankImage.scrollTop = 0;
                    }
                    dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);
                    if (useragent.isOpera) {
                        editor.container.removeChild(blankImage);
                    }
                    dataTransfer.clearData();
                    dataTransfer.setData("Text", editor.session.getTextRange());

                    isInternal = true;
                    this.setState("drag");
                };

                this.onDragEnd = function (e) {
                    mouseTarget.draggable = false;
                    isInternal = false;
                    this.setState(null);
                    if (!editor.getReadOnly()) {
                        var dropEffect = e.dataTransfer.dropEffect;
                        if (!dragOperation && dropEffect == "move") editor.session.remove(editor.getSelectionRange());
                        editor.renderer.$cursorLayer.setBlinking(true);
                    }
                    this.editor.unsetStyle("ace_dragging");
                    this.editor.renderer.setCursorStyle("");
                };

                this.onDragEnter = function (e) {
                    if (editor.getReadOnly() || !canAccept(e.dataTransfer)) return;
                    x = e.clientX;
                    y = e.clientY;
                    if (!dragSelectionMarker) addDragMarker();
                    counter++;
                    e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
                    return event.preventDefault(e);
                };

                this.onDragOver = function (e) {
                    if (editor.getReadOnly() || !canAccept(e.dataTransfer)) return;
                    x = e.clientX;
                    y = e.clientY;
                    if (!dragSelectionMarker) {
                        addDragMarker();
                        counter++;
                    }
                    if (onMouseMoveTimer !== null) onMouseMoveTimer = null;

                    e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
                    return event.preventDefault(e);
                };

                this.onDragLeave = function (e) {
                    counter--;
                    if (counter <= 0 && dragSelectionMarker) {
                        clearDragMarker();
                        dragOperation = null;
                        return event.preventDefault(e);
                    }
                };

                this.onDrop = function (e) {
                    if (!dragCursor) return;
                    var dataTransfer = e.dataTransfer;
                    if (isInternal) {
                        switch (dragOperation) {
                            case "move":
                                if (range.contains(dragCursor.row, dragCursor.column)) {
                                    range = {
                                        start: dragCursor,
                                        end: dragCursor
                                    };
                                } else {
                                    range = editor.moveText(range, dragCursor);
                                }
                                break;
                            case "copy":
                                range = editor.moveText(range, dragCursor, true);
                                break;
                        }
                    } else {
                        var dropData = dataTransfer.getData('Text');
                        range = {
                            start: dragCursor,
                            end: editor.session.insert(dragCursor, dropData)
                        };
                        editor.focus();
                        dragOperation = null;
                    }
                    clearDragMarker();
                    return event.preventDefault(e);
                };

                event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler));
                event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler));
                event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler));
                event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler));
                event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler));
                event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler));

                function scrollCursorIntoView(cursor, prevCursor) {
                    var now = Date.now();
                    var vMovement = !prevCursor || cursor.row != prevCursor.row;
                    var hMovement = !prevCursor || cursor.column != prevCursor.column;
                    if (!cursorMovedTime || vMovement || hMovement) {
                        editor.$blockScrolling += 1;
                        editor.moveCursorToPosition(cursor);
                        editor.$blockScrolling -= 1;
                        cursorMovedTime = now;
                        cursorPointOnCaretMoved = { x: x, y: y };
                    } else {
                        var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
                        if (distance > SCROLL_CURSOR_HYSTERESIS) {
                            cursorMovedTime = null;
                        } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
                            editor.renderer.scrollCursorIntoView();
                            cursorMovedTime = null;
                        }
                    }
                }

                function autoScroll(cursor, prevCursor) {
                    var now = Date.now();
                    var lineHeight = editor.renderer.layerConfig.lineHeight;
                    var characterWidth = editor.renderer.layerConfig.characterWidth;
                    var editorRect = editor.renderer.scroller.getBoundingClientRect();
                    var offsets = {
                        x: {
                            left: x - editorRect.left,
                            right: editorRect.right - x
                        },
                        y: {
                            top: y - editorRect.top,
                            bottom: editorRect.bottom - y
                        }
                    };
                    var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
                    var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
                    var scrollCursor = { row: cursor.row, column: cursor.column };
                    if (nearestXOffset / characterWidth <= 2) {
                        scrollCursor.column += offsets.x.left < offsets.x.right ? -3 : +2;
                    }
                    if (nearestYOffset / lineHeight <= 1) {
                        scrollCursor.row += offsets.y.top < offsets.y.bottom ? -1 : +1;
                    }
                    var vScroll = cursor.row != scrollCursor.row;
                    var hScroll = cursor.column != scrollCursor.column;
                    var vMovement = !prevCursor || cursor.row != prevCursor.row;
                    if (vScroll || hScroll && !vMovement) {
                        if (!autoScrollStartTime) autoScrollStartTime = now;else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY) editor.renderer.scrollCursorIntoView(scrollCursor);
                    } else {
                        autoScrollStartTime = null;
                    }
                }

                function onDragInterval() {
                    var prevCursor = dragCursor;
                    dragCursor = editor.renderer.screenToTextCoordinates(x, y);
                    scrollCursorIntoView(dragCursor, prevCursor);
                    autoScroll(dragCursor, prevCursor);
                }

                function addDragMarker() {
                    range = editor.selection.toOrientedRange();
                    dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
                    editor.clearSelection();
                    if (editor.isFocused()) editor.renderer.$cursorLayer.setBlinking(false);
                    clearInterval(timerId);
                    onDragInterval();
                    timerId = setInterval(onDragInterval, 20);
                    counter = 0;
                    event.addListener(document, "mousemove", onMouseMove);
                }

                function clearDragMarker() {
                    clearInterval(timerId);
                    editor.session.removeMarker(dragSelectionMarker);
                    dragSelectionMarker = null;
                    editor.$blockScrolling += 1;
                    editor.selection.fromOrientedRange(range);
                    editor.$blockScrolling -= 1;
                    if (editor.isFocused() && !isInternal) editor.renderer.$cursorLayer.setBlinking(!editor.getReadOnly());
                    range = null;
                    dragCursor = null;
                    counter = 0;
                    autoScrollStartTime = null;
                    cursorMovedTime = null;
                    event.removeListener(document, "mousemove", onMouseMove);
                }
                var onMouseMoveTimer = null;
                function onMouseMove() {
                    if (onMouseMoveTimer == null) {
                        onMouseMoveTimer = setTimeout(function () {
                            if (onMouseMoveTimer != null && dragSelectionMarker) clearDragMarker();
                        }, 20);
                    }
                }

                function canAccept(dataTransfer) {
                    var types = dataTransfer.types;
                    return !types || Array.prototype.some.call(types, function (type) {
                        return type == 'text/plain' || type == 'Text';
                    });
                }

                function getDropEffect(e) {
                    var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];
                    var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];

                    var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
                    var effectAllowed = "uninitialized";
                    try {
                        effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
                    } catch (e) {}
                    var dropEffect = "none";

                    if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0) dropEffect = "copy";else if (moveAllowed.indexOf(effectAllowed) >= 0) dropEffect = "move";else if (copyAllowed.indexOf(effectAllowed) >= 0) dropEffect = "copy";

                    return dropEffect;
                }
            }

            (function () {

                this.dragWait = function () {
                    var interval = Date.now() - this.mousedownEvent.time;
                    if (interval > this.editor.getDragDelay()) this.startDrag();
                };

                this.dragWaitEnd = function () {
                    var target = this.editor.container;
                    target.draggable = false;
                    this.startSelect(this.mousedownEvent.getDocumentPosition());
                    this.selectEnd();
                };

                this.dragReadyEnd = function (e) {
                    this.editor.renderer.$cursorLayer.setBlinking(!this.editor.getReadOnly());
                    this.editor.unsetStyle("ace_dragging");
                    this.editor.renderer.setCursorStyle("");
                    this.dragWaitEnd();
                };

                this.startDrag = function () {
                    this.cancelDrag = false;
                    var editor = this.editor;
                    var target = editor.container;
                    target.draggable = true;
                    editor.renderer.$cursorLayer.setBlinking(false);
                    editor.setStyle("ace_dragging");
                    var cursorStyle = useragent.isWin ? "default" : "move";
                    editor.renderer.setCursorStyle(cursorStyle);
                    this.setState("dragReady");
                };

                this.onMouseDrag = function (e) {
                    var target = this.editor.container;
                    if (useragent.isIE && this.state == "dragReady") {
                        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
                        if (distance > 3) target.dragDrop();
                    }
                    if (this.state === "dragWait") {
                        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
                        if (distance > 0) {
                            target.draggable = false;
                            this.startSelect(this.mousedownEvent.getDocumentPosition());
                        }
                    }
                };

                this.onMouseDown = function (e) {
                    if (!this.$dragEnabled) return;
                    this.mousedownEvent = e;
                    var editor = this.editor;

                    var inSelection = e.inSelection();
                    var button = e.getButton();
                    var clickCount = e.domEvent.detail || 1;
                    if (clickCount === 1 && button === 0 && inSelection) {
                        if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey())) return;
                        this.mousedownEvent.time = Date.now();
                        var eventTarget = e.domEvent.target || e.domEvent.srcElement;
                        if ("unselectable" in eventTarget) eventTarget.unselectable = "on";
                        if (editor.getDragDelay()) {
                            if (useragent.isWebKit) {
                                this.cancelDrag = true;
                                var mouseTarget = editor.container;
                                mouseTarget.draggable = true;
                            }
                            this.setState("dragWait");
                        } else {
                            this.startDrag();
                        }
                        this.captureMouse(e, this.onMouseDrag.bind(this));
                        e.defaultPrevented = true;
                    }
                };
            }).call(DragdropHandler.prototype);

            function calcDistance(ax, ay, bx, by) {
                return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
            }

            exports.DragdropHandler = DragdropHandler;
        });

        ace.define("ace/lib/net", ["require", "exports", "module", "ace/lib/dom"], function (require, exports, module) {
            "use strict";

            var dom = require("./dom");

            exports.get = function (url, callback) {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        callback(xhr.responseText);
                    }
                };
                xhr.send(null);
            };

            exports.loadScript = function (path, callback) {
                var head = dom.getDocumentHead();
                var s = document.createElement('script');

                s.src = path;
                head.appendChild(s);

                s.onload = s.onreadystatechange = function (_, isAbort) {
                    if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
                        s = s.onload = s.onreadystatechange = null;
                        if (!isAbort) callback();
                    }
                };
            };
            exports.qualifyURL = function (url) {
                var a = document.createElement('a');
                a.href = url;
                return a.href;
            };
        });

        ace.define("ace/lib/event_emitter", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            var EventEmitter = {};
            var stopPropagation = function () {
                this.propagationStopped = true;
            };
            var preventDefault = function () {
                this.defaultPrevented = true;
            };

            EventEmitter._emit = EventEmitter._dispatchEvent = function (eventName, e) {
                this._eventRegistry || (this._eventRegistry = {});
                this._defaultHandlers || (this._defaultHandlers = {});

                var listeners = this._eventRegistry[eventName] || [];
                var defaultHandler = this._defaultHandlers[eventName];
                if (!listeners.length && !defaultHandler) return;

                if (typeof e != "object" || !e) e = {};

                if (!e.type) e.type = eventName;
                if (!e.stopPropagation) e.stopPropagation = stopPropagation;
                if (!e.preventDefault) e.preventDefault = preventDefault;

                listeners = listeners.slice();
                for (var i = 0; i < listeners.length; i++) {
                    listeners[i](e, this);
                    if (e.propagationStopped) break;
                }

                if (defaultHandler && !e.defaultPrevented) return defaultHandler(e, this);
            };

            EventEmitter._signal = function (eventName, e) {
                var listeners = (this._eventRegistry || {})[eventName];
                if (!listeners) return;
                listeners = listeners.slice();
                for (var i = 0; i < listeners.length; i++) listeners[i](e, this);
            };

            EventEmitter.once = function (eventName, callback) {
                var _self = this;
                callback && this.addEventListener(eventName, function newCallback() {
                    _self.removeEventListener(eventName, newCallback);
                    callback.apply(null, arguments);
                });
            };

            EventEmitter.setDefaultHandler = function (eventName, callback) {
                var handlers = this._defaultHandlers;
                if (!handlers) handlers = this._defaultHandlers = { _disabled_: {} };

                if (handlers[eventName]) {
                    var old = handlers[eventName];
                    var disabled = handlers._disabled_[eventName];
                    if (!disabled) handlers._disabled_[eventName] = disabled = [];
                    disabled.push(old);
                    var i = disabled.indexOf(callback);
                    if (i != -1) disabled.splice(i, 1);
                }
                handlers[eventName] = callback;
            };
            EventEmitter.removeDefaultHandler = function (eventName, callback) {
                var handlers = this._defaultHandlers;
                if (!handlers) return;
                var disabled = handlers._disabled_[eventName];

                if (handlers[eventName] == callback) {
                    var old = handlers[eventName];
                    if (disabled) this.setDefaultHandler(eventName, disabled.pop());
                } else if (disabled) {
                    var i = disabled.indexOf(callback);
                    if (i != -1) disabled.splice(i, 1);
                }
            };

            EventEmitter.on = EventEmitter.addEventListener = function (eventName, callback, capturing) {
                this._eventRegistry = this._eventRegistry || {};

                var listeners = this._eventRegistry[eventName];
                if (!listeners) listeners = this._eventRegistry[eventName] = [];

                if (listeners.indexOf(callback) == -1) listeners[capturing ? "unshift" : "push"](callback);
                return callback;
            };

            EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function (eventName, callback) {
                this._eventRegistry = this._eventRegistry || {};

                var listeners = this._eventRegistry[eventName];
                if (!listeners) return;

                var index = listeners.indexOf(callback);
                if (index !== -1) listeners.splice(index, 1);
            };

            EventEmitter.removeAllListeners = function (eventName) {
                if (this._eventRegistry) this._eventRegistry[eventName] = [];
            };

            exports.EventEmitter = EventEmitter;
        });

        ace.define("ace/lib/app_config", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function (require, exports, module) {
            "no use strict";

            var oop = require("./oop");
            var EventEmitter = require("./event_emitter").EventEmitter;

            var optionsProvider = {
                setOptions: function (optList) {
                    Object.keys(optList).forEach(function (key) {
                        this.setOption(key, optList[key]);
                    }, this);
                },
                getOptions: function (optionNames) {
                    var result = {};
                    if (!optionNames) {
                        optionNames = Object.keys(this.$options);
                    } else if (!Array.isArray(optionNames)) {
                        result = optionNames;
                        optionNames = Object.keys(result);
                    }
                    optionNames.forEach(function (key) {
                        result[key] = this.getOption(key);
                    }, this);
                    return result;
                },
                setOption: function (name, value) {
                    if (this["$" + name] === value) return;
                    var opt = this.$options[name];
                    if (!opt) {
                        return warn('misspelled option "' + name + '"');
                    }
                    if (opt.forwardTo) return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);

                    if (!opt.handlesSet) this["$" + name] = value;
                    if (opt && opt.set) opt.set.call(this, value);
                },
                getOption: function (name) {
                    var opt = this.$options[name];
                    if (!opt) {
                        return warn('misspelled option "' + name + '"');
                    }
                    if (opt.forwardTo) return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
                    return opt && opt.get ? opt.get.call(this) : this["$" + name];
                }
            };

            function warn(message) {
                if (typeof console != "undefined" && console.warn) console.warn.apply(console, arguments);
            }

            function reportError(msg, data) {
                var e = new Error(msg);
                e.data = data;
                if (typeof console == "object" && console.error) console.error(e);
                setTimeout(function () {
                    throw e;
                });
            }

            var AppConfig = function () {
                this.$defaultOptions = {};
            };

            (function () {
                oop.implement(this, EventEmitter);
                this.defineOptions = function (obj, path, options) {
                    if (!obj.$options) this.$defaultOptions[path] = obj.$options = {};

                    Object.keys(options).forEach(function (key) {
                        var opt = options[key];
                        if (typeof opt == "string") opt = { forwardTo: opt };

                        opt.name || (opt.name = key);
                        obj.$options[opt.name] = opt;
                        if ("initialValue" in opt) obj["$" + opt.name] = opt.initialValue;
                    });
                    oop.implement(obj, optionsProvider);

                    return this;
                };

                this.resetOptions = function (obj) {
                    Object.keys(obj.$options).forEach(function (key) {
                        var opt = obj.$options[key];
                        if ("value" in opt) obj.setOption(key, opt.value);
                    });
                };

                this.setDefaultValue = function (path, name, value) {
                    var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
                    if (opts[name]) {
                        if (opts.forwardTo) this.setDefaultValue(opts.forwardTo, name, value);else opts[name].value = value;
                    }
                };

                this.setDefaultValues = function (path, optionHash) {
                    Object.keys(optionHash).forEach(function (key) {
                        this.setDefaultValue(path, key, optionHash[key]);
                    }, this);
                };

                this.warn = warn;
                this.reportError = reportError;
            }).call(AppConfig.prototype);

            exports.AppConfig = AppConfig;
        });

        ace.define("ace/config", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/lib/net", "ace/lib/app_config"], function (require, exports, module) {
            "no use strict";

            var lang = require("./lib/lang");
            var oop = require("./lib/oop");
            var net = require("./lib/net");
            var AppConfig = require("./lib/app_config").AppConfig;

            module.exports = exports = new AppConfig();

            var global = function () {
                return this || typeof window != "undefined" && window;
            }();

            var options = {
                packaged: false,
                workerPath: null,
                modePath: null,
                themePath: null,
                basePath: "",
                suffix: ".js",
                $moduleUrls: {}
            };

            exports.get = function (key) {
                if (!options.hasOwnProperty(key)) throw new Error("Unknown config key: " + key);

                return options[key];
            };

            exports.set = function (key, value) {
                if (!options.hasOwnProperty(key)) throw new Error("Unknown config key: " + key);

                options[key] = value;
            };

            exports.all = function () {
                return lang.copyObject(options);
            };
            exports.moduleUrl = function (name, component) {
                if (options.$moduleUrls[name]) return options.$moduleUrls[name];

                var parts = name.split("/");
                component = component || parts[parts.length - 2] || "";
                var sep = component == "snippets" ? "/" : "-";
                var base = parts[parts.length - 1];
                if (component == "worker" && sep == "-") {
                    var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
                    base = base.replace(re, "");
                }

                if ((!base || base == component) && parts.length > 1) base = parts[parts.length - 2];
                var path = options[component + "Path"];
                if (path == null) {
                    path = options.basePath;
                } else if (sep == "/") {
                    component = sep = "";
                }
                if (path && path.slice(-1) != "/") path += "/";
                return path + component + sep + base + this.get("suffix");
            };

            exports.setModuleUrl = function (name, subst) {
                return options.$moduleUrls[name] = subst;
            };

            exports.$loading = {};
            exports.loadModule = function (moduleName, onLoad) {
                var module, moduleType;
                if (Array.isArray(moduleName)) {
                    moduleType = moduleName[0];
                    moduleName = moduleName[1];
                }

                try {
                    module = require(moduleName);
                } catch (e) {}
                if (module && !exports.$loading[moduleName]) return onLoad && onLoad(module);

                if (!exports.$loading[moduleName]) exports.$loading[moduleName] = [];

                exports.$loading[moduleName].push(onLoad);

                if (exports.$loading[moduleName].length > 1) return;

                var afterLoad = function () {
                    require([moduleName], function (module) {
                        exports._emit("load.module", { name: moduleName, module: module });
                        var listeners = exports.$loading[moduleName];
                        exports.$loading[moduleName] = null;
                        listeners.forEach(function (onLoad) {
                            onLoad && onLoad(module);
                        });
                    });
                };

                if (!exports.get("packaged")) return afterLoad();
                net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
            };
            init(true);function init(packaged) {

                if (!global || !global.document) return;

                options.packaged = packaged || require.packaged || module.packaged || global.define && define.packaged;

                var scriptOptions = {};
                var scriptUrl = "";
                var currentScript = document.currentScript || document._currentScript; // native or polyfill
                var currentDocument = currentScript && currentScript.ownerDocument || document;

                var scripts = currentDocument.getElementsByTagName("script");
                for (var i = 0; i < scripts.length; i++) {
                    var script = scripts[i];

                    var src = script.src || script.getAttribute("src");
                    if (!src) continue;

                    var attributes = script.attributes;
                    for (var j = 0, l = attributes.length; j < l; j++) {
                        var attr = attributes[j];
                        if (attr.name.indexOf("data-ace-") === 0) {
                            scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
                        }
                    }

                    var m = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
                    if (m) scriptUrl = m[1];
                }

                if (scriptUrl) {
                    scriptOptions.base = scriptOptions.base || scriptUrl;
                    scriptOptions.packaged = true;
                }

                scriptOptions.basePath = scriptOptions.base;
                scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
                scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
                scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
                delete scriptOptions.base;

                for (var key in scriptOptions) if (typeof scriptOptions[key] !== "undefined") exports.set(key, scriptOptions[key]);
            }

            exports.init = init;

            function deHyphenate(str) {
                return str.replace(/-(.)/g, function (m, m1) {
                    return m1.toUpperCase();
                });
            }
        });

        ace.define("ace/mouse/mouse_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/mouse/default_handlers", "ace/mouse/default_gutter_handler", "ace/mouse/mouse_event", "ace/mouse/dragdrop_handler", "ace/config"], function (require, exports, module) {
            "use strict";

            var event = require("../lib/event");
            var useragent = require("../lib/useragent");
            var DefaultHandlers = require("./default_handlers").DefaultHandlers;
            var DefaultGutterHandler = require("./default_gutter_handler").GutterHandler;
            var MouseEvent = require("./mouse_event").MouseEvent;
            var DragdropHandler = require("./dragdrop_handler").DragdropHandler;
            var config = require("../config");

            var MouseHandler = function (editor) {
                var _self = this;
                this.editor = editor;

                new DefaultHandlers(this);
                new DefaultGutterHandler(this);
                new DragdropHandler(this);

                var focusEditor = function (e) {
                    var windowBlurred = !document.hasFocus || !document.hasFocus() || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());
                    if (windowBlurred) window.focus();
                    editor.focus();
                };

                var mouseTarget = editor.renderer.getMouseEventTarget();
                event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"));
                event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"));
                event.addMultiMouseDownListener([mouseTarget, editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner, editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner, editor.textInput && editor.textInput.getElement()].filter(Boolean), [400, 300, 250], this, "onMouseEvent");
                event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"));
                event.addTouchMoveListener(editor.container, this.onTouchMove.bind(this, "touchmove"));

                var gutterEl = editor.renderer.$gutter;
                event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"));
                event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"));
                event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"));
                event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"));

                event.addListener(mouseTarget, "mousedown", focusEditor);
                event.addListener(gutterEl, "mousedown", focusEditor);
                if (useragent.isIE && editor.renderer.scrollBarV) {
                    event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor);
                    event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor);
                }

                editor.on("mousemove", function (e) {
                    if (_self.state || _self.$dragDelay || !_self.$dragEnabled) return;

                    var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
                    var range = editor.session.selection.getRange();
                    var renderer = editor.renderer;

                    if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
                        renderer.setCursorStyle("default");
                    } else {
                        renderer.setCursorStyle("");
                    }
                });
            };

            (function () {
                this.onMouseEvent = function (name, e) {
                    this.editor._emit(name, new MouseEvent(e, this.editor));
                };

                this.onMouseMove = function (name, e) {
                    var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
                    if (!listeners || !listeners.length) return;

                    this.editor._emit(name, new MouseEvent(e, this.editor));
                };

                this.onMouseWheel = function (name, e) {
                    var mouseEvent = new MouseEvent(e, this.editor);
                    mouseEvent.speed = this.$scrollSpeed * 2;
                    mouseEvent.wheelX = e.wheelX;
                    mouseEvent.wheelY = e.wheelY;

                    this.editor._emit(name, mouseEvent);
                };

                this.onTouchMove = function (name, e) {
                    var mouseEvent = new MouseEvent(e, this.editor);
                    mouseEvent.speed = 1; //this.$scrollSpeed * 2;
                    mouseEvent.wheelX = e.wheelX;
                    mouseEvent.wheelY = e.wheelY;
                    this.editor._emit(name, mouseEvent);
                };

                this.setState = function (state) {
                    this.state = state;
                };

                this.captureMouse = function (ev, mouseMoveHandler) {
                    this.x = ev.x;
                    this.y = ev.y;

                    this.isMousePressed = true;
                    var renderer = this.editor.renderer;
                    if (renderer.$keepTextAreaAtCursor) renderer.$keepTextAreaAtCursor = null;

                    var self = this;
                    var onMouseMove = function (e) {
                        if (!e) return;
                        if (useragent.isWebKit && !e.which && self.releaseMouse) return self.releaseMouse();

                        self.x = e.clientX;
                        self.y = e.clientY;
                        mouseMoveHandler && mouseMoveHandler(e);
                        self.mouseEvent = new MouseEvent(e, self.editor);
                        self.$mouseMoved = true;
                    };

                    var onCaptureEnd = function (e) {
                        clearInterval(timerId);
                        onCaptureInterval();
                        self[self.state + "End"] && self[self.state + "End"](e);
                        self.state = "";
                        if (renderer.$keepTextAreaAtCursor == null) {
                            renderer.$keepTextAreaAtCursor = true;
                            renderer.$moveTextAreaToCursor();
                        }
                        self.isMousePressed = false;
                        self.$onCaptureMouseMove = self.releaseMouse = null;
                        e && self.onMouseEvent("mouseup", e);
                    };

                    var onCaptureInterval = function () {
                        self[self.state] && self[self.state]();
                        self.$mouseMoved = false;
                    };

                    if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
                        return setTimeout(function () {
                            onCaptureEnd(ev);
                        });
                    }

                    self.$onCaptureMouseMove = onMouseMove;
                    self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
                    var timerId = setInterval(onCaptureInterval, 20);
                };
                this.releaseMouse = null;
                this.cancelContextMenu = function () {
                    var stop = function (e) {
                        if (e && e.domEvent && e.domEvent.type != "contextmenu") return;
                        this.editor.off("nativecontextmenu", stop);
                        if (e && e.domEvent) event.stopEvent(e.domEvent);
                    }.bind(this);
                    setTimeout(stop, 10);
                    this.editor.on("nativecontextmenu", stop);
                };
            }).call(MouseHandler.prototype);

            config.defineOptions(MouseHandler.prototype, "mouseHandler", {
                scrollSpeed: { initialValue: 2 },
                dragDelay: { initialValue: useragent.isMac ? 150 : 0 },
                dragEnabled: { initialValue: true },
                focusTimout: { initialValue: 0 },
                tooltipFollowsMouse: { initialValue: true }
            });

            exports.MouseHandler = MouseHandler;
        });

        ace.define("ace/mouse/fold_handler", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            function FoldHandler(editor) {

                editor.on("click", function (e) {
                    var position = e.getDocumentPosition();
                    var session = editor.session;
                    var fold = session.getFoldAt(position.row, position.column, 1);
                    if (fold) {
                        if (e.getAccelKey()) session.removeFold(fold);else session.expandFold(fold);

                        e.stop();
                    }
                });

                editor.on("gutterclick", function (e) {
                    var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

                    if (gutterRegion == "foldWidgets") {
                        var row = e.getDocumentPosition().row;
                        var session = editor.session;
                        if (session.foldWidgets && session.foldWidgets[row]) editor.session.onFoldWidgetClick(row, e);
                        if (!editor.isFocused()) editor.focus();
                        e.stop();
                    }
                });

                editor.on("gutterdblclick", function (e) {
                    var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

                    if (gutterRegion == "foldWidgets") {
                        var row = e.getDocumentPosition().row;
                        var session = editor.session;
                        var data = session.getParentFoldRangeData(row, true);
                        var range = data.range || data.firstRange;

                        if (range) {
                            row = range.start.row;
                            var fold = session.getFoldAt(row, session.getLine(row).length, 1);

                            if (fold) {
                                session.removeFold(fold);
                            } else {
                                session.addFold("...", range);
                                editor.renderer.scrollCursorIntoView({ row: range.start.row, column: 0 });
                            }
                        }
                        e.stop();
                    }
                });
            }

            exports.FoldHandler = FoldHandler;
        });

        ace.define("ace/keyboard/keybinding", ["require", "exports", "module", "ace/lib/keys", "ace/lib/event"], function (require, exports, module) {
            "use strict";

            var keyUtil = require("../lib/keys");
            var event = require("../lib/event");

            var KeyBinding = function (editor) {
                this.$editor = editor;
                this.$data = { editor: editor };
                this.$handlers = [];
                this.setDefaultHandler(editor.commands);
            };

            (function () {
                this.setDefaultHandler = function (kb) {
                    this.removeKeyboardHandler(this.$defaultHandler);
                    this.$defaultHandler = kb;
                    this.addKeyboardHandler(kb, 0);
                };

                this.setKeyboardHandler = function (kb) {
                    var h = this.$handlers;
                    if (h[h.length - 1] == kb) return;

                    while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler) this.removeKeyboardHandler(h[h.length - 1]);

                    this.addKeyboardHandler(kb, 1);
                };

                this.addKeyboardHandler = function (kb, pos) {
                    if (!kb) return;
                    if (typeof kb == "function" && !kb.handleKeyboard) kb.handleKeyboard = kb;
                    var i = this.$handlers.indexOf(kb);
                    if (i != -1) this.$handlers.splice(i, 1);

                    if (pos == undefined) this.$handlers.push(kb);else this.$handlers.splice(pos, 0, kb);

                    if (i == -1 && kb.attach) kb.attach(this.$editor);
                };

                this.removeKeyboardHandler = function (kb) {
                    var i = this.$handlers.indexOf(kb);
                    if (i == -1) return false;
                    this.$handlers.splice(i, 1);
                    kb.detach && kb.detach(this.$editor);
                    return true;
                };

                this.getKeyboardHandler = function () {
                    return this.$handlers[this.$handlers.length - 1];
                };

                this.getStatusText = function () {
                    var data = this.$data;
                    var editor = data.editor;
                    return this.$handlers.map(function (h) {
                        return h.getStatusText && h.getStatusText(editor, data) || "";
                    }).filter(Boolean).join(" ");
                };

                this.$callKeyboardHandlers = function (hashId, keyString, keyCode, e) {
                    var toExecute;
                    var success = false;
                    var commands = this.$editor.commands;

                    for (var i = this.$handlers.length; i--;) {
                        toExecute = this.$handlers[i].handleKeyboard(this.$data, hashId, keyString, keyCode, e);
                        if (!toExecute || !toExecute.command) continue;
                        if (toExecute.command == "null") {
                            success = true;
                        } else {
                            success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
                        }
                        if (success && e && hashId != -1 && toExecute.passEvent != true && toExecute.command.passEvent != true) {
                            event.stopEvent(e);
                        }
                        if (success) break;
                    }

                    if (!success && hashId == -1) {
                        toExecute = { command: "insertstring" };
                        success = commands.exec("insertstring", this.$editor, keyString);
                    }

                    if (success && this.$editor._signal) this.$editor._signal("keyboardActivity", toExecute);

                    return success;
                };

                this.onCommandKey = function (e, hashId, keyCode) {
                    var keyString = keyUtil.keyCodeToString(keyCode);
                    this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
                };

                this.onTextInput = function (text) {
                    this.$callKeyboardHandlers(-1, text);
                };
            }).call(KeyBinding.prototype);

            exports.KeyBinding = KeyBinding;
        });

        ace.define("ace/range", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            var comparePoints = function (p1, p2) {
                return p1.row - p2.row || p1.column - p2.column;
            };
            var Range = function (startRow, startColumn, endRow, endColumn) {
                this.start = {
                    row: startRow,
                    column: startColumn
                };

                this.end = {
                    row: endRow,
                    column: endColumn
                };
            };

            (function () {
                this.isEqual = function (range) {
                    return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;
                };
                this.toString = function () {
                    return "Range: [" + this.start.row + "/" + this.start.column + "] -> [" + this.end.row + "/" + this.end.column + "]";
                };

                this.contains = function (row, column) {
                    return this.compare(row, column) == 0;
                };
                this.compareRange = function (range) {
                    var cmp,
                        end = range.end,
                        start = range.start;

                    cmp = this.compare(end.row, end.column);
                    if (cmp == 1) {
                        cmp = this.compare(start.row, start.column);
                        if (cmp == 1) {
                            return 2;
                        } else if (cmp == 0) {
                            return 1;
                        } else {
                            return 0;
                        }
                    } else if (cmp == -1) {
                        return -2;
                    } else {
                        cmp = this.compare(start.row, start.column);
                        if (cmp == -1) {
                            return -1;
                        } else if (cmp == 1) {
                            return 42;
                        } else {
                            return 0;
                        }
                    }
                };
                this.comparePoint = function (p) {
                    return this.compare(p.row, p.column);
                };
                this.containsRange = function (range) {
                    return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
                };
                this.intersects = function (range) {
                    var cmp = this.compareRange(range);
                    return cmp == -1 || cmp == 0 || cmp == 1;
                };
                this.isEnd = function (row, column) {
                    return this.end.row == row && this.end.column == column;
                };
                this.isStart = function (row, column) {
                    return this.start.row == row && this.start.column == column;
                };
                this.setStart = function (row, column) {
                    if (typeof row == "object") {
                        this.start.column = row.column;
                        this.start.row = row.row;
                    } else {
                        this.start.row = row;
                        this.start.column = column;
                    }
                };
                this.setEnd = function (row, column) {
                    if (typeof row == "object") {
                        this.end.column = row.column;
                        this.end.row = row.row;
                    } else {
                        this.end.row = row;
                        this.end.column = column;
                    }
                };
                this.inside = function (row, column) {
                    if (this.compare(row, column) == 0) {
                        if (this.isEnd(row, column) || this.isStart(row, column)) {
                            return false;
                        } else {
                            return true;
                        }
                    }
                    return false;
                };
                this.insideStart = function (row, column) {
                    if (this.compare(row, column) == 0) {
                        if (this.isEnd(row, column)) {
                            return false;
                        } else {
                            return true;
                        }
                    }
                    return false;
                };
                this.insideEnd = function (row, column) {
                    if (this.compare(row, column) == 0) {
                        if (this.isStart(row, column)) {
                            return false;
                        } else {
                            return true;
                        }
                    }
                    return false;
                };
                this.compare = function (row, column) {
                    if (!this.isMultiLine()) {
                        if (row === this.start.row) {
                            return column < this.start.column ? -1 : column > this.end.column ? 1 : 0;
                        }
                    }

                    if (row < this.start.row) return -1;

                    if (row > this.end.row) return 1;

                    if (this.start.row === row) return column >= this.start.column ? 0 : -1;

                    if (this.end.row === row) return column <= this.end.column ? 0 : 1;

                    return 0;
                };
                this.compareStart = function (row, column) {
                    if (this.start.row == row && this.start.column == column) {
                        return -1;
                    } else {
                        return this.compare(row, column);
                    }
                };
                this.compareEnd = function (row, column) {
                    if (this.end.row == row && this.end.column == column) {
                        return 1;
                    } else {
                        return this.compare(row, column);
                    }
                };
                this.compareInside = function (row, column) {
                    if (this.end.row == row && this.end.column == column) {
                        return 1;
                    } else if (this.start.row == row && this.start.column == column) {
                        return -1;
                    } else {
                        return this.compare(row, column);
                    }
                };
                this.clipRows = function (firstRow, lastRow) {
                    if (this.end.row > lastRow) var end = { row: lastRow + 1, column: 0 };else if (this.end.row < firstRow) var end = { row: firstRow, column: 0 };

                    if (this.start.row > lastRow) var start = { row: lastRow + 1, column: 0 };else if (this.start.row < firstRow) var start = { row: firstRow, column: 0 };

                    return Range.fromPoints(start || this.start, end || this.end);
                };
                this.extend = function (row, column) {
                    var cmp = this.compare(row, column);

                    if (cmp == 0) return this;else if (cmp == -1) var start = { row: row, column: column };else var end = { row: row, column: column };

                    return Range.fromPoints(start || this.start, end || this.end);
                };

                this.isEmpty = function () {
                    return this.start.row === this.end.row && this.start.column === this.end.column;
                };
                this.isMultiLine = function () {
                    return this.start.row !== this.end.row;
                };
                this.clone = function () {
                    return Range.fromPoints(this.start, this.end);
                };
                this.collapseRows = function () {
                    if (this.end.column == 0) return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);else return new Range(this.start.row, 0, this.end.row, 0);
                };
                this.toScreenRange = function (session) {
                    var screenPosStart = session.documentToScreenPosition(this.start);
                    var screenPosEnd = session.documentToScreenPosition(this.end);

                    return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
                };
                this.moveBy = function (row, column) {
                    this.start.row += row;
                    this.start.column += column;
                    this.end.row += row;
                    this.end.column += column;
                };
            }).call(Range.prototype);
            Range.fromPoints = function (start, end) {
                return new Range(start.row, start.column, end.row, end.column);
            };
            Range.comparePoints = comparePoints;

            Range.comparePoints = function (p1, p2) {
                return p1.row - p2.row || p1.column - p2.column;
            };

            exports.Range = Range;
        });

        ace.define("ace/selection", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/range"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var lang = require("./lib/lang");
            var EventEmitter = require("./lib/event_emitter").EventEmitter;
            var Range = require("./range").Range;
            var Selection = function (session) {
                this.session = session;
                this.doc = session.getDocument();

                this.clearSelection();
                this.lead = this.selectionLead = this.doc.createAnchor(0, 0);
                this.anchor = this.selectionAnchor = this.doc.createAnchor(0, 0);

                var self = this;
                this.lead.on("change", function (e) {
                    self._emit("changeCursor");
                    if (!self.$isEmpty) self._emit("changeSelection");
                    if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column) self.$desiredColumn = null;
                });

                this.selectionAnchor.on("change", function () {
                    if (!self.$isEmpty) self._emit("changeSelection");
                });
            };

            (function () {

                oop.implement(this, EventEmitter);
                this.isEmpty = function () {
                    return this.$isEmpty || this.anchor.row == this.lead.row && this.anchor.column == this.lead.column;
                };
                this.isMultiLine = function () {
                    if (this.isEmpty()) {
                        return false;
                    }

                    return this.getRange().isMultiLine();
                };
                this.getCursor = function () {
                    return this.lead.getPosition();
                };
                this.setSelectionAnchor = function (row, column) {
                    this.anchor.setPosition(row, column);

                    if (this.$isEmpty) {
                        this.$isEmpty = false;
                        this._emit("changeSelection");
                    }
                };
                this.getSelectionAnchor = function () {
                    if (this.$isEmpty) return this.getSelectionLead();else return this.anchor.getPosition();
                };
                this.getSelectionLead = function () {
                    return this.lead.getPosition();
                };
                this.shiftSelection = function (columns) {
                    if (this.$isEmpty) {
                        this.moveCursorTo(this.lead.row, this.lead.column + columns);
                        return;
                    }

                    var anchor = this.getSelectionAnchor();
                    var lead = this.getSelectionLead();

                    var isBackwards = this.isBackwards();

                    if (!isBackwards || anchor.column !== 0) this.setSelectionAnchor(anchor.row, anchor.column + columns);

                    if (isBackwards || lead.column !== 0) {
                        this.$moveSelection(function () {
                            this.moveCursorTo(lead.row, lead.column + columns);
                        });
                    }
                };
                this.isBackwards = function () {
                    var anchor = this.anchor;
                    var lead = this.lead;
                    return anchor.row > lead.row || anchor.row == lead.row && anchor.column > lead.column;
                };
                this.getRange = function () {
                    var anchor = this.anchor;
                    var lead = this.lead;

                    if (this.isEmpty()) return Range.fromPoints(lead, lead);

                    if (this.isBackwards()) {
                        return Range.fromPoints(lead, anchor);
                    } else {
                        return Range.fromPoints(anchor, lead);
                    }
                };
                this.clearSelection = function () {
                    if (!this.$isEmpty) {
                        this.$isEmpty = true;
                        this._emit("changeSelection");
                    }
                };
                this.selectAll = function () {
                    var lastRow = this.doc.getLength() - 1;
                    this.setSelectionAnchor(0, 0);
                    this.moveCursorTo(lastRow, this.doc.getLine(lastRow).length);
                };
                this.setRange = this.setSelectionRange = function (range, reverse) {
                    if (reverse) {
                        this.setSelectionAnchor(range.end.row, range.end.column);
                        this.selectTo(range.start.row, range.start.column);
                    } else {
                        this.setSelectionAnchor(range.start.row, range.start.column);
                        this.selectTo(range.end.row, range.end.column);
                    }
                    if (this.getRange().isEmpty()) this.$isEmpty = true;
                    this.$desiredColumn = null;
                };

                this.$moveSelection = function (mover) {
                    var lead = this.lead;
                    if (this.$isEmpty) this.setSelectionAnchor(lead.row, lead.column);

                    mover.call(this);
                };
                this.selectTo = function (row, column) {
                    this.$moveSelection(function () {
                        this.moveCursorTo(row, column);
                    });
                };
                this.selectToPosition = function (pos) {
                    this.$moveSelection(function () {
                        this.moveCursorToPosition(pos);
                    });
                };
                this.moveTo = function (row, column) {
                    this.clearSelection();
                    this.moveCursorTo(row, column);
                };
                this.moveToPosition = function (pos) {
                    this.clearSelection();
                    this.moveCursorToPosition(pos);
                };
                this.selectUp = function () {
                    this.$moveSelection(this.moveCursorUp);
                };
                this.selectDown = function () {
                    this.$moveSelection(this.moveCursorDown);
                };
                this.selectRight = function () {
                    this.$moveSelection(this.moveCursorRight);
                };
                this.selectLeft = function () {
                    this.$moveSelection(this.moveCursorLeft);
                };
                this.selectLineStart = function () {
                    this.$moveSelection(this.moveCursorLineStart);
                };
                this.selectLineEnd = function () {
                    this.$moveSelection(this.moveCursorLineEnd);
                };
                this.selectFileEnd = function () {
                    this.$moveSelection(this.moveCursorFileEnd);
                };
                this.selectFileStart = function () {
                    this.$moveSelection(this.moveCursorFileStart);
                };
                this.selectWordRight = function () {
                    this.$moveSelection(this.moveCursorWordRight);
                };
                this.selectWordLeft = function () {
                    this.$moveSelection(this.moveCursorWordLeft);
                };
                this.getWordRange = function (row, column) {
                    if (typeof column == "undefined") {
                        var cursor = row || this.lead;
                        row = cursor.row;
                        column = cursor.column;
                    }
                    return this.session.getWordRange(row, column);
                };
                this.selectWord = function () {
                    this.setSelectionRange(this.getWordRange());
                };
                this.selectAWord = function () {
                    var cursor = this.getCursor();
                    var range = this.session.getAWordRange(cursor.row, cursor.column);
                    this.setSelectionRange(range);
                };

                this.getLineRange = function (row, excludeLastChar) {
                    var rowStart = typeof row == "number" ? row : this.lead.row;
                    var rowEnd;

                    var foldLine = this.session.getFoldLine(rowStart);
                    if (foldLine) {
                        rowStart = foldLine.start.row;
                        rowEnd = foldLine.end.row;
                    } else {
                        rowEnd = rowStart;
                    }
                    if (excludeLastChar === true) return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);else return new Range(rowStart, 0, rowEnd + 1, 0);
                };
                this.selectLine = function () {
                    this.setSelectionRange(this.getLineRange());
                };
                this.moveCursorUp = function () {
                    this.moveCursorBy(-1, 0);
                };
                this.moveCursorDown = function () {
                    this.moveCursorBy(1, 0);
                };
                this.moveCursorLeft = function () {
                    var cursor = this.lead.getPosition(),
                        fold;

                    if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
                        this.moveCursorTo(fold.start.row, fold.start.column);
                    } else if (cursor.column === 0) {
                        if (cursor.row > 0) {
                            this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
                        }
                    } else {
                        var tabSize = this.session.getTabSize();
                        if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column - tabSize, cursor.column).split(" ").length - 1 == tabSize) this.moveCursorBy(0, -tabSize);else this.moveCursorBy(0, -1);
                    }
                };
                this.moveCursorRight = function () {
                    var cursor = this.lead.getPosition(),
                        fold;
                    if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
                        this.moveCursorTo(fold.end.row, fold.end.column);
                    } else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
                        if (this.lead.row < this.doc.getLength() - 1) {
                            this.moveCursorTo(this.lead.row + 1, 0);
                        }
                    } else {
                        var tabSize = this.session.getTabSize();
                        var cursor = this.lead;
                        if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column, cursor.column + tabSize).split(" ").length - 1 == tabSize) this.moveCursorBy(0, tabSize);else this.moveCursorBy(0, 1);
                    }
                };
                this.moveCursorLineStart = function () {
                    var row = this.lead.row;
                    var column = this.lead.column;
                    var screenRow = this.session.documentToScreenRow(row, column);
                    var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
                    var beforeCursor = this.session.getDisplayLine(row, null, firstColumnPosition.row, firstColumnPosition.column);

                    var leadingSpace = beforeCursor.match(/^\s*/);
                    if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart) firstColumnPosition.column += leadingSpace[0].length;
                    this.moveCursorToPosition(firstColumnPosition);
                };
                this.moveCursorLineEnd = function () {
                    var lead = this.lead;
                    var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
                    if (this.lead.column == lineEnd.column) {
                        var line = this.session.getLine(lineEnd.row);
                        if (lineEnd.column == line.length) {
                            var textEnd = line.search(/\s+$/);
                            if (textEnd > 0) lineEnd.column = textEnd;
                        }
                    }

                    this.moveCursorTo(lineEnd.row, lineEnd.column);
                };
                this.moveCursorFileEnd = function () {
                    var row = this.doc.getLength() - 1;
                    var column = this.doc.getLine(row).length;
                    this.moveCursorTo(row, column);
                };
                this.moveCursorFileStart = function () {
                    this.moveCursorTo(0, 0);
                };
                this.moveCursorLongWordRight = function () {
                    var row = this.lead.row;
                    var column = this.lead.column;
                    var line = this.doc.getLine(row);
                    var rightOfCursor = line.substring(column);

                    var match;
                    this.session.nonTokenRe.lastIndex = 0;
                    this.session.tokenRe.lastIndex = 0;
                    var fold = this.session.getFoldAt(row, column, 1);
                    if (fold) {
                        this.moveCursorTo(fold.end.row, fold.end.column);
                        return;
                    }
                    if (match = this.session.nonTokenRe.exec(rightOfCursor)) {
                        column += this.session.nonTokenRe.lastIndex;
                        this.session.nonTokenRe.lastIndex = 0;
                        rightOfCursor = line.substring(column);
                    }
                    if (column >= line.length) {
                        this.moveCursorTo(row, line.length);
                        this.moveCursorRight();
                        if (row < this.doc.getLength() - 1) this.moveCursorWordRight();
                        return;
                    }
                    if (match = this.session.tokenRe.exec(rightOfCursor)) {
                        column += this.session.tokenRe.lastIndex;
                        this.session.tokenRe.lastIndex = 0;
                    }

                    this.moveCursorTo(row, column);
                };
                this.moveCursorLongWordLeft = function () {
                    var row = this.lead.row;
                    var column = this.lead.column;
                    var fold;
                    if (fold = this.session.getFoldAt(row, column, -1)) {
                        this.moveCursorTo(fold.start.row, fold.start.column);
                        return;
                    }

                    var str = this.session.getFoldStringAt(row, column, -1);
                    if (str == null) {
                        str = this.doc.getLine(row).substring(0, column);
                    }

                    var leftOfCursor = lang.stringReverse(str);
                    var match;
                    this.session.nonTokenRe.lastIndex = 0;
                    this.session.tokenRe.lastIndex = 0;
                    if (match = this.session.nonTokenRe.exec(leftOfCursor)) {
                        column -= this.session.nonTokenRe.lastIndex;
                        leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
                        this.session.nonTokenRe.lastIndex = 0;
                    }
                    if (column <= 0) {
                        this.moveCursorTo(row, 0);
                        this.moveCursorLeft();
                        if (row > 0) this.moveCursorWordLeft();
                        return;
                    }
                    if (match = this.session.tokenRe.exec(leftOfCursor)) {
                        column -= this.session.tokenRe.lastIndex;
                        this.session.tokenRe.lastIndex = 0;
                    }

                    this.moveCursorTo(row, column);
                };

                this.$shortWordEndIndex = function (rightOfCursor) {
                    var match,
                        index = 0,
                        ch;
                    var whitespaceRe = /\s/;
                    var tokenRe = this.session.tokenRe;

                    tokenRe.lastIndex = 0;
                    if (match = this.session.tokenRe.exec(rightOfCursor)) {
                        index = this.session.tokenRe.lastIndex;
                    } else {
                        while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch)) index++;

                        if (index < 1) {
                            tokenRe.lastIndex = 0;
                            while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
                                tokenRe.lastIndex = 0;
                                index++;
                                if (whitespaceRe.test(ch)) {
                                    if (index > 2) {
                                        index--;
                                        break;
                                    } else {
                                        while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch)) index++;
                                        if (index > 2) break;
                                    }
                                }
                            }
                        }
                    }
                    tokenRe.lastIndex = 0;

                    return index;
                };

                this.moveCursorShortWordRight = function () {
                    var row = this.lead.row;
                    var column = this.lead.column;
                    var line = this.doc.getLine(row);
                    var rightOfCursor = line.substring(column);

                    var fold = this.session.getFoldAt(row, column, 1);
                    if (fold) return this.moveCursorTo(fold.end.row, fold.end.column);

                    if (column == line.length) {
                        var l = this.doc.getLength();
                        do {
                            row++;
                            rightOfCursor = this.doc.getLine(row);
                        } while (row < l && /^\s*$/.test(rightOfCursor));

                        if (!/^\s+/.test(rightOfCursor)) rightOfCursor = "";
                        column = 0;
                    }

                    var index = this.$shortWordEndIndex(rightOfCursor);

                    this.moveCursorTo(row, column + index);
                };

                this.moveCursorShortWordLeft = function () {
                    var row = this.lead.row;
                    var column = this.lead.column;

                    var fold;
                    if (fold = this.session.getFoldAt(row, column, -1)) return this.moveCursorTo(fold.start.row, fold.start.column);

                    var line = this.session.getLine(row).substring(0, column);
                    if (column === 0) {
                        do {
                            row--;
                            line = this.doc.getLine(row);
                        } while (row > 0 && /^\s*$/.test(line));

                        column = line.length;
                        if (!/\s+$/.test(line)) line = "";
                    }

                    var leftOfCursor = lang.stringReverse(line);
                    var index = this.$shortWordEndIndex(leftOfCursor);

                    return this.moveCursorTo(row, column - index);
                };

                this.moveCursorWordRight = function () {
                    if (this.session.$selectLongWords) this.moveCursorLongWordRight();else this.moveCursorShortWordRight();
                };

                this.moveCursorWordLeft = function () {
                    if (this.session.$selectLongWords) this.moveCursorLongWordLeft();else this.moveCursorShortWordLeft();
                };
                this.moveCursorBy = function (rows, chars) {
                    var screenPos = this.session.documentToScreenPosition(this.lead.row, this.lead.column);

                    if (chars === 0) {
                        if (this.$desiredColumn) screenPos.column = this.$desiredColumn;else this.$desiredColumn = screenPos.column;
                    }

                    var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column);

                    if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {
                        if (this.session.lineWidgets && this.session.lineWidgets[docPos.row]) {
                            if (docPos.row > 0 || rows > 0) docPos.row++;
                        }
                    }
                    this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
                };
                this.moveCursorToPosition = function (position) {
                    this.moveCursorTo(position.row, position.column);
                };
                this.moveCursorTo = function (row, column, keepDesiredColumn) {
                    var fold = this.session.getFoldAt(row, column, 1);
                    if (fold) {
                        row = fold.start.row;
                        column = fold.start.column;
                    }

                    this.$keepDesiredColumnOnChange = true;
                    this.lead.setPosition(row, column);
                    this.$keepDesiredColumnOnChange = false;

                    if (!keepDesiredColumn) this.$desiredColumn = null;
                };
                this.moveCursorToScreen = function (row, column, keepDesiredColumn) {
                    var pos = this.session.screenToDocumentPosition(row, column);
                    this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
                };
                this.detach = function () {
                    this.lead.detach();
                    this.anchor.detach();
                    this.session = this.doc = null;
                };

                this.fromOrientedRange = function (range) {
                    this.setSelectionRange(range, range.cursor == range.start);
                    this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
                };

                this.toOrientedRange = function (range) {
                    var r = this.getRange();
                    if (range) {
                        range.start.column = r.start.column;
                        range.start.row = r.start.row;
                        range.end.column = r.end.column;
                        range.end.row = r.end.row;
                    } else {
                        range = r;
                    }

                    range.cursor = this.isBackwards() ? range.start : range.end;
                    range.desiredColumn = this.$desiredColumn;
                    return range;
                };
                this.getRangeOfMovements = function (func) {
                    var start = this.getCursor();
                    try {
                        func(this);
                        var end = this.getCursor();
                        return Range.fromPoints(start, end);
                    } catch (e) {
                        return Range.fromPoints(start, start);
                    } finally {
                        this.moveCursorToPosition(start);
                    }
                };

                this.toJSON = function () {
                    if (this.rangeCount) {
                        var data = this.ranges.map(function (r) {
                            var r1 = r.clone();
                            r1.isBackwards = r.cursor == r.start;
                            return r1;
                        });
                    } else {
                        var data = this.getRange();
                        data.isBackwards = this.isBackwards();
                    }
                    return data;
                };

                this.fromJSON = function (data) {
                    if (data.start == undefined) {
                        if (this.rangeList) {
                            this.toSingleRange(data[0]);
                            for (var i = data.length; i--;) {
                                var r = Range.fromPoints(data[i].start, data[i].end);
                                if (data[i].isBackwards) r.cursor = r.start;
                                this.addRange(r, true);
                            }
                            return;
                        } else data = data[0];
                    }
                    if (this.rangeList) this.toSingleRange(data);
                    this.setSelectionRange(data, data.isBackwards);
                };

                this.isEqual = function (data) {
                    if ((data.length || this.rangeCount) && data.length != this.rangeCount) return false;
                    if (!data.length || !this.ranges) return this.getRange().isEqual(data);

                    for (var i = this.ranges.length; i--;) {
                        if (!this.ranges[i].isEqual(data[i])) return false;
                    }
                    return true;
                };
            }).call(Selection.prototype);

            exports.Selection = Selection;
        });

        ace.define("ace/tokenizer", ["require", "exports", "module", "ace/config"], function (require, exports, module) {
            "use strict";

            var config = require("./config");
            var MAX_TOKEN_COUNT = 2000;
            var Tokenizer = function (rules) {
                this.states = rules;

                this.regExps = {};
                this.matchMappings = {};
                for (var key in this.states) {
                    var state = this.states[key];
                    var ruleRegExps = [];
                    var matchTotal = 0;
                    var mapping = this.matchMappings[key] = { defaultToken: "text" };
                    var flag = "g";

                    var splitterRurles = [];
                    for (var i = 0; i < state.length; i++) {
                        var rule = state[i];
                        if (rule.defaultToken) mapping.defaultToken = rule.defaultToken;
                        if (rule.caseInsensitive) flag = "gi";
                        if (rule.regex == null) continue;

                        if (rule.regex instanceof RegExp) rule.regex = rule.regex.toString().slice(1, -1);
                        var adjustedregex = rule.regex;
                        var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
                        if (Array.isArray(rule.token)) {
                            if (rule.token.length == 1 || matchcount == 1) {
                                rule.token = rule.token[0];
                            } else if (matchcount - 1 != rule.token.length) {
                                this.reportError("number of classes and regexp groups doesn't match", {
                                    rule: rule,
                                    groupCount: matchcount - 1
                                });
                                rule.token = rule.token[0];
                            } else {
                                rule.tokenArray = rule.token;
                                rule.token = null;
                                rule.onMatch = this.$arrayTokens;
                            }
                        } else if (typeof rule.token == "function" && !rule.onMatch) {
                            if (matchcount > 1) rule.onMatch = this.$applyToken;else rule.onMatch = rule.token;
                        }

                        if (matchcount > 1) {
                            if (/\\\d/.test(rule.regex)) {
                                adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function (match, digit) {
                                    return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                                });
                            } else {
                                matchcount = 1;
                                adjustedregex = this.removeCapturingGroups(rule.regex);
                            }
                            if (!rule.splitRegex && typeof rule.token != "string") splitterRurles.push(rule); // flag will be known only at the very end
                        }

                        mapping[matchTotal] = i;
                        matchTotal += matchcount;

                        ruleRegExps.push(adjustedregex);
                        if (!rule.onMatch) rule.onMatch = null;
                    }

                    if (!ruleRegExps.length) {
                        mapping[0] = 0;
                        ruleRegExps.push("$");
                    }

                    splitterRurles.forEach(function (rule) {
                        rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
                    }, this);

                    this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
                }
            };

            (function () {
                this.$setMaxTokenCount = function (m) {
                    MAX_TOKEN_COUNT = m | 0;
                };

                this.$applyToken = function (str) {
                    var values = this.splitRegex.exec(str).slice(1);
                    var types = this.token.apply(this, values);
                    if (typeof types === "string") return [{ type: types, value: str }];

                    var tokens = [];
                    for (var i = 0, l = types.length; i < l; i++) {
                        if (values[i]) tokens[tokens.length] = {
                            type: types[i],
                            value: values[i]
                        };
                    }
                    return tokens;
                };

                this.$arrayTokens = function (str) {
                    if (!str) return [];
                    var values = this.splitRegex.exec(str);
                    if (!values) return "text";
                    var tokens = [];
                    var types = this.tokenArray;
                    for (var i = 0, l = types.length; i < l; i++) {
                        if (values[i + 1]) tokens[tokens.length] = {
                            type: types[i],
                            value: values[i + 1]
                        };
                    }
                    return tokens;
                };

                this.removeCapturingGroups = function (src) {
                    var r = src.replace(/\[(?:\\.|[^\]])*?\]|\\.|\(\?[:=!]|(\()/g, function (x, y) {
                        return y ? "(?:" : x;
                    });
                    return r;
                };

                this.createSplitterRegexp = function (src, flag) {
                    if (src.indexOf("(?=") != -1) {
                        var stack = 0;
                        var inChClass = false;
                        var lastCapture = {};
                        src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function (m, esc, parenOpen, parenClose, square, index) {
                            if (inChClass) {
                                inChClass = square != "]";
                            } else if (square) {
                                inChClass = true;
                            } else if (parenClose) {
                                if (stack == lastCapture.stack) {
                                    lastCapture.end = index + 1;
                                    lastCapture.stack = -1;
                                }
                                stack--;
                            } else if (parenOpen) {
                                stack++;
                                if (parenOpen.length != 1) {
                                    lastCapture.stack = stack;
                                    lastCapture.start = index;
                                }
                            }
                            return m;
                        });

                        if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end))) src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
                    }
                    if (src.charAt(0) != "^") src = "^" + src;
                    if (src.charAt(src.length - 1) != "$") src += "$";

                    return new RegExp(src, (flag || "").replace("g", ""));
                };
                this.getLineTokens = function (line, startState) {
                    if (startState && typeof startState != "string") {
                        var stack = startState.slice(0);
                        startState = stack[0];
                        if (startState === "#tmp") {
                            stack.shift();
                            startState = stack.shift();
                        }
                    } else var stack = [];

                    var currentState = startState || "start";
                    var state = this.states[currentState];
                    if (!state) {
                        currentState = "start";
                        state = this.states[currentState];
                    }
                    var mapping = this.matchMappings[currentState];
                    var re = this.regExps[currentState];
                    re.lastIndex = 0;

                    var match,
                        tokens = [];
                    var lastIndex = 0;
                    var matchAttempts = 0;

                    var token = { type: null, value: "" };

                    while (match = re.exec(line)) {
                        var type = mapping.defaultToken;
                        var rule = null;
                        var value = match[0];
                        var index = re.lastIndex;

                        if (index - value.length > lastIndex) {
                            var skipped = line.substring(lastIndex, index - value.length);
                            if (token.type == type) {
                                token.value += skipped;
                            } else {
                                if (token.type) tokens.push(token);
                                token = { type: type, value: skipped };
                            }
                        }

                        for (var i = 0; i < match.length - 2; i++) {
                            if (match[i + 1] === undefined) continue;

                            rule = state[mapping[i]];

                            if (rule.onMatch) type = rule.onMatch(value, currentState, stack);else type = rule.token;

                            if (rule.next) {
                                if (typeof rule.next == "string") {
                                    currentState = rule.next;
                                } else {
                                    currentState = rule.next(currentState, stack);
                                }

                                state = this.states[currentState];
                                if (!state) {
                                    this.reportError("state doesn't exist", currentState);
                                    currentState = "start";
                                    state = this.states[currentState];
                                }
                                mapping = this.matchMappings[currentState];
                                lastIndex = index;
                                re = this.regExps[currentState];
                                re.lastIndex = index;
                            }
                            break;
                        }

                        if (value) {
                            if (typeof type === "string") {
                                if ((!rule || rule.merge !== false) && token.type === type) {
                                    token.value += value;
                                } else {
                                    if (token.type) tokens.push(token);
                                    token = { type: type, value: value };
                                }
                            } else if (type) {
                                if (token.type) tokens.push(token);
                                token = { type: null, value: "" };
                                for (var i = 0; i < type.length; i++) tokens.push(type[i]);
                            }
                        }

                        if (lastIndex == line.length) break;

                        lastIndex = index;

                        if (matchAttempts++ > MAX_TOKEN_COUNT) {
                            if (matchAttempts > 2 * line.length) {
                                this.reportError("infinite loop with in ace tokenizer", {
                                    startState: startState,
                                    line: line
                                });
                            }
                            while (lastIndex < line.length) {
                                if (token.type) tokens.push(token);
                                token = {
                                    value: line.substring(lastIndex, lastIndex += 2000),
                                    type: "overflow"
                                };
                            }
                            currentState = "start";
                            stack = [];
                            break;
                        }
                    }

                    if (token.type) tokens.push(token);

                    if (stack.length > 1) {
                        if (stack[0] !== currentState) stack.unshift("#tmp", currentState);
                    }
                    return {
                        tokens: tokens,
                        state: stack.length ? stack : currentState
                    };
                };

                this.reportError = config.reportError;
            }).call(Tokenizer.prototype);

            exports.Tokenizer = Tokenizer;
        });

        ace.define("ace/mode/text_highlight_rules", ["require", "exports", "module", "ace/lib/lang"], function (require, exports, module) {
            "use strict";

            var lang = require("../lib/lang");

            var TextHighlightRules = function () {

                this.$rules = {
                    "start": [{
                        token: "empty_line",
                        regex: '^$'
                    }, {
                        defaultToken: "text"
                    }]
                };
            };

            (function () {

                this.addRules = function (rules, prefix) {
                    if (!prefix) {
                        for (var key in rules) this.$rules[key] = rules[key];
                        return;
                    }
                    for (var key in rules) {
                        var state = rules[key];
                        for (var i = 0; i < state.length; i++) {
                            var rule = state[i];
                            if (rule.next || rule.onMatch) {
                                if (typeof rule.next == "string") {
                                    if (rule.next.indexOf(prefix) !== 0) rule.next = prefix + rule.next;
                                }
                                if (rule.nextState && rule.nextState.indexOf(prefix) !== 0) rule.nextState = prefix + rule.nextState;
                            }
                        }
                        this.$rules[prefix + key] = state;
                    }
                };

                this.getRules = function () {
                    return this.$rules;
                };

                this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {
                    var embedRules = typeof HighlightRules == "function" ? new HighlightRules().getRules() : HighlightRules;
                    if (states) {
                        for (var i = 0; i < states.length; i++) states[i] = prefix + states[i];
                    } else {
                        states = [];
                        for (var key in embedRules) states.push(prefix + key);
                    }

                    this.addRules(embedRules, prefix);

                    if (escapeRules) {
                        var addRules = Array.prototype[append ? "push" : "unshift"];
                        for (var i = 0; i < states.length; i++) addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
                    }

                    if (!this.$embeds) this.$embeds = [];
                    this.$embeds.push(prefix);
                };

                this.getEmbeds = function () {
                    return this.$embeds;
                };

                var pushState = function (currentState, stack) {
                    if (currentState != "start" || stack.length) stack.unshift(this.nextState, currentState);
                    return this.nextState;
                };
                var popState = function (currentState, stack) {
                    stack.shift();
                    return stack.shift() || "start";
                };

                this.normalizeRules = function () {
                    var id = 0;
                    var rules = this.$rules;
                    function processState(key) {
                        var state = rules[key];
                        state.processed = true;
                        for (var i = 0; i < state.length; i++) {
                            var rule = state[i];
                            var toInsert = null;
                            if (Array.isArray(rule)) {
                                toInsert = rule;
                                rule = {};
                            }
                            if (!rule.regex && rule.start) {
                                rule.regex = rule.start;
                                if (!rule.next) rule.next = [];
                                rule.next.push({
                                    defaultToken: rule.token
                                }, {
                                    token: rule.token + ".end",
                                    regex: rule.end || rule.start,
                                    next: "pop"
                                });
                                rule.token = rule.token + ".start";
                                rule.push = true;
                            }
                            var next = rule.next || rule.push;
                            if (next && Array.isArray(next)) {
                                var stateName = rule.stateName;
                                if (!stateName) {
                                    stateName = rule.token;
                                    if (typeof stateName != "string") stateName = stateName[0] || "";
                                    if (rules[stateName]) stateName += id++;
                                }
                                rules[stateName] = next;
                                rule.next = stateName;
                                processState(stateName);
                            } else if (next == "pop") {
                                rule.next = popState;
                            }

                            if (rule.push) {
                                rule.nextState = rule.next || rule.push;
                                rule.next = pushState;
                                delete rule.push;
                            }

                            if (rule.rules) {
                                for (var r in rule.rules) {
                                    if (rules[r]) {
                                        if (rules[r].push) rules[r].push.apply(rules[r], rule.rules[r]);
                                    } else {
                                        rules[r] = rule.rules[r];
                                    }
                                }
                            }
                            var includeName = typeof rule == "string" ? rule : typeof rule.include == "string" ? rule.include : "";
                            if (includeName) {
                                toInsert = rules[includeName];
                            }

                            if (toInsert) {
                                var args = [i, 1].concat(toInsert);
                                if (rule.noEscape) args = args.filter(function (x) {
                                    return !x.next;
                                });
                                state.splice.apply(state, args);
                                i--;
                            }

                            if (rule.keywordMap) {
                                rule.token = this.createKeywordMapper(rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive);
                                delete rule.defaultToken;
                            }
                        }
                    }
                    Object.keys(rules).forEach(processState, this);
                };

                this.createKeywordMapper = function (map, defaultToken, ignoreCase, splitChar) {
                    var keywords = Object.create(null);
                    Object.keys(map).forEach(function (className) {
                        var a = map[className];
                        if (ignoreCase) a = a.toLowerCase();
                        var list = a.split(splitChar || "|");
                        for (var i = list.length; i--;) keywords[list[i]] = className;
                    });
                    if (Object.getPrototypeOf(keywords)) {
                        keywords.__proto__ = null;
                    }
                    this.$keywordList = Object.keys(keywords);
                    map = null;
                    return ignoreCase ? function (value) {
                        return keywords[value.toLowerCase()] || defaultToken;
                    } : function (value) {
                        return keywords[value] || defaultToken;
                    };
                };

                this.getKeywords = function () {
                    return this.$keywords;
                };
            }).call(TextHighlightRules.prototype);

            exports.TextHighlightRules = TextHighlightRules;
        });

        ace.define("ace/mode/behaviour", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            var Behaviour = function () {
                this.$behaviours = {};
            };

            (function () {

                this.add = function (name, action, callback) {
                    switch (undefined) {
                        case this.$behaviours:
                            this.$behaviours = {};
                        case this.$behaviours[name]:
                            this.$behaviours[name] = {};
                    }
                    this.$behaviours[name][action] = callback;
                };

                this.addBehaviours = function (behaviours) {
                    for (var key in behaviours) {
                        for (var action in behaviours[key]) {
                            this.add(key, action, behaviours[key][action]);
                        }
                    }
                };

                this.remove = function (name) {
                    if (this.$behaviours && this.$behaviours[name]) {
                        delete this.$behaviours[name];
                    }
                };

                this.inherit = function (mode, filter) {
                    if (typeof mode === "function") {
                        var behaviours = new mode().getBehaviours(filter);
                    } else {
                        var behaviours = mode.getBehaviours(filter);
                    }
                    this.addBehaviours(behaviours);
                };

                this.getBehaviours = function (filter) {
                    if (!filter) {
                        return this.$behaviours;
                    } else {
                        var ret = {};
                        for (var i = 0; i < filter.length; i++) {
                            if (this.$behaviours[filter[i]]) {
                                ret[filter[i]] = this.$behaviours[filter[i]];
                            }
                        }
                        return ret;
                    }
                };
            }).call(Behaviour.prototype);

            exports.Behaviour = Behaviour;
        });

        ace.define("ace/token_iterator", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            var TokenIterator = function (session, initialRow, initialColumn) {
                this.$session = session;
                this.$row = initialRow;
                this.$rowTokens = session.getTokens(initialRow);

                var token = session.getTokenAt(initialRow, initialColumn);
                this.$tokenIndex = token ? token.index : -1;
            };

            (function () {
                this.stepBackward = function () {
                    this.$tokenIndex -= 1;

                    while (this.$tokenIndex < 0) {
                        this.$row -= 1;
                        if (this.$row < 0) {
                            this.$row = 0;
                            return null;
                        }

                        this.$rowTokens = this.$session.getTokens(this.$row);
                        this.$tokenIndex = this.$rowTokens.length - 1;
                    }

                    return this.$rowTokens[this.$tokenIndex];
                };
                this.stepForward = function () {
                    this.$tokenIndex += 1;
                    var rowCount;
                    while (this.$tokenIndex >= this.$rowTokens.length) {
                        this.$row += 1;
                        if (!rowCount) rowCount = this.$session.getLength();
                        if (this.$row >= rowCount) {
                            this.$row = rowCount - 1;
                            return null;
                        }

                        this.$rowTokens = this.$session.getTokens(this.$row);
                        this.$tokenIndex = 0;
                    }

                    return this.$rowTokens[this.$tokenIndex];
                };
                this.getCurrentToken = function () {
                    return this.$rowTokens[this.$tokenIndex];
                };
                this.getCurrentTokenRow = function () {
                    return this.$row;
                };
                this.getCurrentTokenColumn = function () {
                    var rowTokens = this.$rowTokens;
                    var tokenIndex = this.$tokenIndex;
                    var column = rowTokens[tokenIndex].start;
                    if (column !== undefined) return column;

                    column = 0;
                    while (tokenIndex > 0) {
                        tokenIndex -= 1;
                        column += rowTokens[tokenIndex].value.length;
                    }

                    return column;
                };
                this.getCurrentTokenPosition = function () {
                    return { row: this.$row, column: this.getCurrentTokenColumn() };
                };
            }).call(TokenIterator.prototype);

            exports.TokenIterator = TokenIterator;
        });

        ace.define("ace/mode/behaviour/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/token_iterator", "ace/lib/lang"], function (require, exports, module) {
            "use strict";

            var oop = require("../../lib/oop");
            var Behaviour = require("../behaviour").Behaviour;
            var TokenIterator = require("../../token_iterator").TokenIterator;
            var lang = require("../../lib/lang");

            var SAFE_INSERT_IN_TOKENS = ["text", "paren.rparen", "punctuation.operator"];
            var SAFE_INSERT_BEFORE_TOKENS = ["text", "paren.rparen", "punctuation.operator", "comment"];

            var context;
            var contextCache = {};
            var initContext = function (editor) {
                var id = -1;
                if (editor.multiSelect) {
                    id = editor.selection.index;
                    if (contextCache.rangeCount != editor.multiSelect.rangeCount) contextCache = { rangeCount: editor.multiSelect.rangeCount };
                }
                if (contextCache[id]) return context = contextCache[id];
                context = contextCache[id] = {
                    autoInsertedBrackets: 0,
                    autoInsertedRow: -1,
                    autoInsertedLineEnd: "",
                    maybeInsertedBrackets: 0,
                    maybeInsertedRow: -1,
                    maybeInsertedLineStart: "",
                    maybeInsertedLineEnd: ""
                };
            };

            var getWrapped = function (selection, selected, opening, closing) {
                var rowDiff = selection.end.row - selection.start.row;
                return {
                    text: opening + selected + closing,
                    selection: [0, selection.start.column + 1, rowDiff, selection.end.column + (rowDiff ? 0 : 1)]
                };
            };

            var CstyleBehaviour = function () {
                this.add("braces", "insertion", function (state, action, editor, session, text) {
                    var cursor = editor.getCursorPosition();
                    var line = session.doc.getLine(cursor.row);
                    if (text == '{') {
                        initContext(editor);
                        var selection = editor.getSelectionRange();
                        var selected = session.doc.getTextRange(selection);
                        if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
                            return getWrapped(selection, selected, '{', '}');
                        } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                            if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode) {
                                CstyleBehaviour.recordAutoInsert(editor, session, "}");
                                return {
                                    text: '{}',
                                    selection: [1, 1]
                                };
                            } else {
                                CstyleBehaviour.recordMaybeInsert(editor, session, "{");
                                return {
                                    text: '{',
                                    selection: [1, 1]
                                };
                            }
                        }
                    } else if (text == '}') {
                        initContext(editor);
                        var rightChar = line.substring(cursor.column, cursor.column + 1);
                        if (rightChar == '}') {
                            var matching = session.$findOpeningBracket('}', { column: cursor.column + 1, row: cursor.row });
                            if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                                CstyleBehaviour.popAutoInsertedClosing();
                                return {
                                    text: '',
                                    selection: [1, 1]
                                };
                            }
                        }
                    } else if (text == "\n" || text == "\r\n") {
                        initContext(editor);
                        var closing = "";
                        if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
                            closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
                            CstyleBehaviour.clearMaybeInsertedClosing();
                        }
                        var rightChar = line.substring(cursor.column, cursor.column + 1);
                        if (rightChar === '}') {
                            var openBracePos = session.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 }, '}');
                            if (!openBracePos) return null;
                            var next_indent = this.$getIndent(session.getLine(openBracePos.row));
                        } else if (closing) {
                            var next_indent = this.$getIndent(line);
                        } else {
                            CstyleBehaviour.clearMaybeInsertedClosing();
                            return;
                        }
                        var indent = next_indent + session.getTabString();

                        return {
                            text: '\n' + indent + '\n' + next_indent + closing,
                            selection: [1, indent.length, 1, indent.length]
                        };
                    } else {
                        CstyleBehaviour.clearMaybeInsertedClosing();
                    }
                });

                this.add("braces", "deletion", function (state, action, editor, session, range) {
                    var selected = session.doc.getTextRange(range);
                    if (!range.isMultiLine() && selected == '{') {
                        initContext(editor);
                        var line = session.doc.getLine(range.start.row);
                        var rightChar = line.substring(range.end.column, range.end.column + 1);
                        if (rightChar == '}') {
                            range.end.column++;
                            return range;
                        } else {
                            context.maybeInsertedBrackets--;
                        }
                    }
                });

                this.add("parens", "insertion", function (state, action, editor, session, text) {
                    if (text == '(') {
                        initContext(editor);
                        var selection = editor.getSelectionRange();
                        var selected = session.doc.getTextRange(selection);
                        if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                            return getWrapped(selection, selected, '(', ')');
                        } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                            CstyleBehaviour.recordAutoInsert(editor, session, ")");
                            return {
                                text: '()',
                                selection: [1, 1]
                            };
                        }
                    } else if (text == ')') {
                        initContext(editor);
                        var cursor = editor.getCursorPosition();
                        var line = session.doc.getLine(cursor.row);
                        var rightChar = line.substring(cursor.column, cursor.column + 1);
                        if (rightChar == ')') {
                            var matching = session.$findOpeningBracket(')', { column: cursor.column + 1, row: cursor.row });
                            if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                                CstyleBehaviour.popAutoInsertedClosing();
                                return {
                                    text: '',
                                    selection: [1, 1]
                                };
                            }
                        }
                    }
                });

                this.add("parens", "deletion", function (state, action, editor, session, range) {
                    var selected = session.doc.getTextRange(range);
                    if (!range.isMultiLine() && selected == '(') {
                        initContext(editor);
                        var line = session.doc.getLine(range.start.row);
                        var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                        if (rightChar == ')') {
                            range.end.column++;
                            return range;
                        }
                    }
                });

                this.add("brackets", "insertion", function (state, action, editor, session, text) {
                    if (text == '[') {
                        initContext(editor);
                        var selection = editor.getSelectionRange();
                        var selected = session.doc.getTextRange(selection);
                        if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                            return getWrapped(selection, selected, '[', ']');
                        } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                            CstyleBehaviour.recordAutoInsert(editor, session, "]");
                            return {
                                text: '[]',
                                selection: [1, 1]
                            };
                        }
                    } else if (text == ']') {
                        initContext(editor);
                        var cursor = editor.getCursorPosition();
                        var line = session.doc.getLine(cursor.row);
                        var rightChar = line.substring(cursor.column, cursor.column + 1);
                        if (rightChar == ']') {
                            var matching = session.$findOpeningBracket(']', { column: cursor.column + 1, row: cursor.row });
                            if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                                CstyleBehaviour.popAutoInsertedClosing();
                                return {
                                    text: '',
                                    selection: [1, 1]
                                };
                            }
                        }
                    }
                });

                this.add("brackets", "deletion", function (state, action, editor, session, range) {
                    var selected = session.doc.getTextRange(range);
                    if (!range.isMultiLine() && selected == '[') {
                        initContext(editor);
                        var line = session.doc.getLine(range.start.row);
                        var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                        if (rightChar == ']') {
                            range.end.column++;
                            return range;
                        }
                    }
                });

                this.add("string_dquotes", "insertion", function (state, action, editor, session, text) {
                    if (text == '"' || text == "'") {
                        if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1) return;
                        initContext(editor);
                        var quote = text;
                        var selection = editor.getSelectionRange();
                        var selected = session.doc.getTextRange(selection);
                        if (selected !== "" && selected !== "'" && selected != '"' && editor.getWrapBehavioursEnabled()) {
                            return getWrapped(selection, selected, quote, quote);
                        } else if (!selected) {
                            var cursor = editor.getCursorPosition();
                            var line = session.doc.getLine(cursor.row);
                            var leftChar = line.substring(cursor.column - 1, cursor.column);
                            var rightChar = line.substring(cursor.column, cursor.column + 1);

                            var token = session.getTokenAt(cursor.row, cursor.column);
                            var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
                            if (leftChar == "\\" && token && /escape/.test(token.type)) return null;

                            var stringBefore = token && /string|escape/.test(token.type);
                            var stringAfter = !rightToken || /string|escape/.test(rightToken.type);

                            var pair;
                            if (rightChar == quote) {
                                pair = stringBefore !== stringAfter;
                                if (pair && /string\.end/.test(rightToken.type)) pair = false;
                            } else {
                                if (stringBefore && !stringAfter) return null; // wrap string with different quote
                                if (stringBefore && stringAfter) return null; // do not pair quotes inside strings
                                var wordRe = session.$mode.tokenRe;
                                wordRe.lastIndex = 0;
                                var isWordBefore = wordRe.test(leftChar);
                                wordRe.lastIndex = 0;
                                var isWordAfter = wordRe.test(leftChar);
                                if (isWordBefore || isWordAfter) return null; // before or after alphanumeric
                                if (rightChar && !/[\s;,.})\]\\]/.test(rightChar)) return null; // there is rightChar and it isn't closing
                                pair = true;
                            }
                            return {
                                text: pair ? quote + quote : "",
                                selection: [1, 1]
                            };
                        }
                    }
                });

                this.add("string_dquotes", "deletion", function (state, action, editor, session, range) {
                    var selected = session.doc.getTextRange(range);
                    if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
                        initContext(editor);
                        var line = session.doc.getLine(range.start.row);
                        var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                        if (rightChar == selected) {
                            range.end.column++;
                            return range;
                        }
                    }
                });
            };

            CstyleBehaviour.isSaneInsertion = function (editor, session) {
                var cursor = editor.getCursorPosition();
                var iterator = new TokenIterator(session, cursor.row, cursor.column);
                if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
                    var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
                    if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) return false;
                }
                iterator.stepForward();
                return iterator.getCurrentTokenRow() !== cursor.row || this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
            };

            CstyleBehaviour.$matchTokenType = function (token, types) {
                return types.indexOf(token.type || token) > -1;
            };

            CstyleBehaviour.recordAutoInsert = function (editor, session, bracket) {
                var cursor = editor.getCursorPosition();
                var line = session.doc.getLine(cursor.row);
                if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0])) context.autoInsertedBrackets = 0;
                context.autoInsertedRow = cursor.row;
                context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
                context.autoInsertedBrackets++;
            };

            CstyleBehaviour.recordMaybeInsert = function (editor, session, bracket) {
                var cursor = editor.getCursorPosition();
                var line = session.doc.getLine(cursor.row);
                if (!this.isMaybeInsertedClosing(cursor, line)) context.maybeInsertedBrackets = 0;
                context.maybeInsertedRow = cursor.row;
                context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
                context.maybeInsertedLineEnd = line.substr(cursor.column);
                context.maybeInsertedBrackets++;
            };

            CstyleBehaviour.isAutoInsertedClosing = function (cursor, line, bracket) {
                return context.autoInsertedBrackets > 0 && cursor.row === context.autoInsertedRow && bracket === context.autoInsertedLineEnd[0] && line.substr(cursor.column) === context.autoInsertedLineEnd;
            };

            CstyleBehaviour.isMaybeInsertedClosing = function (cursor, line) {
                return context.maybeInsertedBrackets > 0 && cursor.row === context.maybeInsertedRow && line.substr(cursor.column) === context.maybeInsertedLineEnd && line.substr(0, cursor.column) == context.maybeInsertedLineStart;
            };

            CstyleBehaviour.popAutoInsertedClosing = function () {
                context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
                context.autoInsertedBrackets--;
            };

            CstyleBehaviour.clearMaybeInsertedClosing = function () {
                if (context) {
                    context.maybeInsertedBrackets = 0;
                    context.maybeInsertedRow = -1;
                }
            };

            oop.inherits(CstyleBehaviour, Behaviour);

            exports.CstyleBehaviour = CstyleBehaviour;
        });

        ace.define("ace/unicode", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            exports.packages = {};

            addUnicodePackage({
                L: "0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
                Ll: "0061-007A00AA00B500BA00DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F0521052305250561-05871D00-1D2B1D62-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7C2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2D00-2D25A641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CFB00-FB06FB13-FB17FF41-FF5A",
                Lu: "0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E0520052205240531-055610A0-10C51E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CEDA640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BFF21-FF3A",
                Lt: "01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC",
                Lm: "02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D611D781D9B-1DBF2071207F2090-20942C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A9CFAA70AADDFF70FF9EFF9F",
                Lo: "01BB01C0-01C3029405D0-05EA05F0-05F20621-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150904-0939093D09500958-096109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF12135-21382D30-2D652D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
                M: "0300-036F0483-04890591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DE-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0903093C093E-094E0951-0955096209630981-098309BC09BE-09C409C709C809CB-09CD09D709E209E30A01-0A030A3C0A3E-0A420A470A480A4B-0A4D0A510A700A710A750A81-0A830ABC0ABE-0AC50AC7-0AC90ACB-0ACD0AE20AE30B01-0B030B3C0B3E-0B440B470B480B4B-0B4D0B560B570B620B630B820BBE-0BC20BC6-0BC80BCA-0BCD0BD70C01-0C030C3E-0C440C46-0C480C4A-0C4D0C550C560C620C630C820C830CBC0CBE-0CC40CC6-0CC80CCA-0CCD0CD50CD60CE20CE30D020D030D3E-0D440D46-0D480D4A-0D4D0D570D620D630D820D830DCA0DCF-0DD40DD60DD8-0DDF0DF20DF30E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F3E0F3F0F71-0F840F860F870F90-0F970F99-0FBC0FC6102B-103E1056-1059105E-10601062-10641067-106D1071-10741082-108D108F109A-109D135F1712-17141732-1734175217531772177317B6-17D317DD180B-180D18A91920-192B1930-193B19B0-19C019C819C91A17-1A1B1A55-1A5E1A60-1A7C1A7F1B00-1B041B34-1B441B6B-1B731B80-1B821BA1-1BAA1C24-1C371CD0-1CD21CD4-1CE81CED1CF21DC0-1DE61DFD-1DFF20D0-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66F-A672A67CA67DA6F0A6F1A802A806A80BA823-A827A880A881A8B4-A8C4A8E0-A8F1A926-A92DA947-A953A980-A983A9B3-A9C0AA29-AA36AA43AA4CAA4DAA7BAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE3-ABEAABECABEDFB1EFE00-FE0FFE20-FE26",
                Mn: "0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0902093C0941-0948094D0951-095509620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F90-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135F1712-17141732-1734175217531772177317B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1DC0-1DE61DFD-1DFF20D0-20DC20E120E5-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66FA67CA67DA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26",
                Mc: "0903093E-09400949-094C094E0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1C24-1C2B1C341C351CE11CF2A823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BABE3ABE4ABE6ABE7ABE9ABEAABEC",
                Me: "0488048906DE20DD-20E020E2-20E4A670-A672",
                N: "0030-003900B200B300B900BC-00BE0660-066906F0-06F907C0-07C90966-096F09E6-09EF09F4-09F90A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BF20C66-0C6F0C78-0C7E0CE6-0CEF0D66-0D750E50-0E590ED0-0ED90F20-0F331040-10491090-10991369-137C16EE-16F017E0-17E917F0-17F91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C5920702074-20792080-20892150-21822185-21892460-249B24EA-24FF2776-27932CFD30073021-30293038-303A3192-31953220-32293251-325F3280-328932B1-32BFA620-A629A6E6-A6EFA830-A835A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
                Nd: "0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
                Nl: "16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF",
                No: "00B200B300B900BC-00BE09F4-09F90BF0-0BF20C78-0C7E0D70-0D750F2A-0F331369-137C17F0-17F920702074-20792080-20892150-215F21892460-249B24EA-24FF2776-27932CFD3192-31953220-32293251-325F3280-328932B1-32BFA830-A835",
                P: "0021-00230025-002A002C-002F003A003B003F0040005B-005D005F007B007D00A100AB00B700BB00BF037E0387055A-055F0589058A05BE05C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F3A-0F3D0F850FD0-0FD4104A-104F10FB1361-13681400166D166E169B169C16EB-16ED1735173617D4-17D617D8-17DA1800-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD32010-20272030-20432045-20512053-205E207D207E208D208E2329232A2768-277527C527C627E6-27EF2983-299829D8-29DB29FC29FD2CF9-2CFC2CFE2CFF2E00-2E2E2E302E313001-30033008-30113014-301F3030303D30A030FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFD3EFD3FFE10-FE19FE30-FE52FE54-FE61FE63FE68FE6AFE6BFF01-FF03FF05-FF0AFF0C-FF0FFF1AFF1BFF1FFF20FF3B-FF3DFF3FFF5BFF5DFF5F-FF65",
                Pd: "002D058A05BE140018062010-20152E172E1A301C303030A0FE31FE32FE58FE63FF0D",
                Ps: "0028005B007B0F3A0F3C169B201A201E2045207D208D23292768276A276C276E27702772277427C527E627E827EA27EC27EE2983298529872989298B298D298F299129932995299729D829DA29FC2E222E242E262E283008300A300C300E3010301430163018301A301DFD3EFE17FE35FE37FE39FE3BFE3DFE3FFE41FE43FE47FE59FE5BFE5DFF08FF3BFF5BFF5FFF62",
                Pe: "0029005D007D0F3B0F3D169C2046207E208E232A2769276B276D276F27712773277527C627E727E927EB27ED27EF298429862988298A298C298E2990299229942996299829D929DB29FD2E232E252E272E293009300B300D300F3011301530173019301B301E301FFD3FFE18FE36FE38FE3AFE3CFE3EFE40FE42FE44FE48FE5AFE5CFE5EFF09FF3DFF5DFF60FF63",
                Pi: "00AB2018201B201C201F20392E022E042E092E0C2E1C2E20",
                Pf: "00BB2019201D203A2E032E052E0A2E0D2E1D2E21",
                Pc: "005F203F20402054FE33FE34FE4D-FE4FFF3F",
                Po: "0021-00230025-0027002A002C002E002F003A003B003F0040005C00A100B700BF037E0387055A-055F058905C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F850FD0-0FD4104A-104F10FB1361-1368166D166E16EB-16ED1735173617D4-17D617D8-17DA1800-18051807-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD3201620172020-20272030-2038203B-203E2041-20432047-205120532055-205E2CF9-2CFC2CFE2CFF2E002E012E06-2E082E0B2E0E-2E162E182E192E1B2E1E2E1F2E2A-2E2E2E302E313001-3003303D30FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFE10-FE16FE19FE30FE45FE46FE49-FE4CFE50-FE52FE54-FE57FE5F-FE61FE68FE6AFE6BFF01-FF03FF05-FF07FF0AFF0CFF0EFF0FFF1AFF1BFF1FFF20FF3CFF61FF64FF65",
                S: "0024002B003C-003E005E0060007C007E00A2-00A900AC00AE-00B100B400B600B800D700F702C2-02C502D2-02DF02E5-02EB02ED02EF-02FF03750384038503F604820606-0608060B060E060F06E906FD06FE07F609F209F309FA09FB0AF10B700BF3-0BFA0C7F0CF10CF20D790E3F0F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-139917DB194019E0-19FF1B61-1B6A1B74-1B7C1FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE20442052207A-207C208A-208C20A0-20B8210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B2140-2144214A-214D214F2190-2328232B-23E82400-24262440-244A249C-24E92500-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE27C0-27C427C7-27CA27CC27D0-27E527F0-29822999-29D729DC-29FB29FE-2B4C2B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F309B309C319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A700-A716A720A721A789A78AA828-A82BA836-A839AA77-AA79FB29FDFCFDFDFE62FE64-FE66FE69FF04FF0BFF1C-FF1EFF3EFF40FF5CFF5EFFE0-FFE6FFE8-FFEEFFFCFFFD",
                Sm: "002B003C-003E007C007E00AC00B100D700F703F60606-060820442052207A-207C208A-208C2140-2144214B2190-2194219A219B21A021A321A621AE21CE21CF21D221D421F4-22FF2308-230B23202321237C239B-23B323DC-23E125B725C125F8-25FF266F27C0-27C427C7-27CA27CC27D0-27E527F0-27FF2900-29822999-29D729DC-29FB29FE-2AFF2B30-2B442B47-2B4CFB29FE62FE64-FE66FF0BFF1C-FF1EFF5CFF5EFFE2FFE9-FFEC",
                Sc: "002400A2-00A5060B09F209F309FB0AF10BF90E3F17DB20A0-20B8A838FDFCFE69FF04FFE0FFE1FFE5FFE6",
                Sk: "005E006000A800AF00B400B802C2-02C502D2-02DF02E5-02EB02ED02EF-02FF0375038403851FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE309B309CA700-A716A720A721A789A78AFF3EFF40FFE3",
                So: "00A600A700A900AE00B000B60482060E060F06E906FD06FE07F609FA0B700BF3-0BF80BFA0C7F0CF10CF20D790F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-1399194019E0-19FF1B61-1B6A1B74-1B7C210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B214A214C214D214F2195-2199219C-219F21A121A221A421A521A7-21AD21AF-21CD21D021D121D321D5-21F32300-2307230C-231F2322-2328232B-237B237D-239A23B4-23DB23E2-23E82400-24262440-244A249C-24E92500-25B625B8-25C025C2-25F72600-266E2670-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE2800-28FF2B00-2B2F2B452B462B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A828-A82BA836A837A839AA77-AA79FDFDFFE4FFE8FFEDFFEEFFFCFFFD",
                Z: "002000A01680180E2000-200A20282029202F205F3000",
                Zs: "002000A01680180E2000-200A202F205F3000",
                Zl: "2028",
                Zp: "2029",
                C: "0000-001F007F-009F00AD03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-0605061C061D0620065F06DD070E070F074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17B417B517DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF200B-200F202A-202E2060-206F20722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-F8FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFD-FF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFFBFFFEFFFF",
                Cc: "0000-001F007F-009F",
                Cf: "00AD0600-060306DD070F17B417B5200B-200F202A-202E2060-2064206A-206FFEFFFFF9-FFFB",
                Co: "E000-F8FF",
                Cs: "D800-DFFF",
                Cn: "03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-05FF06040605061C061D0620065F070E074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF2065-206920722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-D7FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFDFEFEFF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFF8FFFEFFFF"
            });

            function addUnicodePackage(pack) {
                var codePoint = /\w{4}/g;
                for (var name in pack) exports.packages[name] = pack[name].replace(codePoint, "\\u$&");
            }
        });

        ace.define("ace/mode/text", ["require", "exports", "module", "ace/tokenizer", "ace/mode/text_highlight_rules", "ace/mode/behaviour/cstyle", "ace/unicode", "ace/lib/lang", "ace/token_iterator", "ace/range"], function (require, exports, module) {
            "use strict";

            var Tokenizer = require("../tokenizer").Tokenizer;
            var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
            var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
            var unicode = require("../unicode");
            var lang = require("../lib/lang");
            var TokenIterator = require("../token_iterator").TokenIterator;
            var Range = require("../range").Range;

            var Mode = function () {
                this.HighlightRules = TextHighlightRules;
            };

            (function () {
                this.$defaultBehaviour = new CstyleBehaviour();

                this.tokenRe = new RegExp("^[" + unicode.packages.L + unicode.packages.Mn + unicode.packages.Mc + unicode.packages.Nd + unicode.packages.Pc + "\\$_]+", "g");

                this.nonTokenRe = new RegExp("^(?:[^" + unicode.packages.L + unicode.packages.Mn + unicode.packages.Mc + unicode.packages.Nd + unicode.packages.Pc + "\\$_]|\\s])+", "g");

                this.getTokenizer = function () {
                    if (!this.$tokenizer) {
                        this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
                        this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
                    }
                    return this.$tokenizer;
                };

                this.lineCommentStart = "";
                this.blockComment = "";

                this.toggleCommentLines = function (state, session, startRow, endRow) {
                    var doc = session.doc;

                    var ignoreBlankLines = true;
                    var shouldRemove = true;
                    var minIndent = Infinity;
                    var tabSize = session.getTabSize();
                    var insertAtTabStop = false;

                    if (!this.lineCommentStart) {
                        if (!this.blockComment) return false;
                        var lineCommentStart = this.blockComment.start;
                        var lineCommentEnd = this.blockComment.end;
                        var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
                        var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");

                        var comment = function (line, i) {
                            if (testRemove(line, i)) return;
                            if (!ignoreBlankLines || /\S/.test(line)) {
                                doc.insertInLine({ row: i, column: line.length }, lineCommentEnd);
                                doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);
                            }
                        };

                        var uncomment = function (line, i) {
                            var m;
                            if (m = line.match(regexpEnd)) doc.removeInLine(i, line.length - m[0].length, line.length);
                            if (m = line.match(regexpStart)) doc.removeInLine(i, m[1].length, m[0].length);
                        };

                        var testRemove = function (line, row) {
                            if (regexpStart.test(line)) return true;
                            var tokens = session.getTokens(row);
                            for (var i = 0; i < tokens.length; i++) {
                                if (tokens[i].type === "comment") return true;
                            }
                        };
                    } else {
                        if (Array.isArray(this.lineCommentStart)) {
                            var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
                            var lineCommentStart = this.lineCommentStart[0];
                        } else {
                            var regexpStart = lang.escapeRegExp(this.lineCommentStart);
                            var lineCommentStart = this.lineCommentStart;
                        }
                        regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");

                        insertAtTabStop = session.getUseSoftTabs();

                        var uncomment = function (line, i) {
                            var m = line.match(regexpStart);
                            if (!m) return;
                            var start = m[1].length,
                                end = m[0].length;
                            if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ") end--;
                            doc.removeInLine(i, start, end);
                        };
                        var commentWithSpace = lineCommentStart + " ";
                        var comment = function (line, i) {
                            if (!ignoreBlankLines || /\S/.test(line)) {
                                if (shouldInsertSpace(line, minIndent, minIndent)) doc.insertInLine({ row: i, column: minIndent }, commentWithSpace);else doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);
                            }
                        };
                        var testRemove = function (line, i) {
                            return regexpStart.test(line);
                        };

                        var shouldInsertSpace = function (line, before, after) {
                            var spaces = 0;
                            while (before-- && line.charAt(before) == " ") spaces++;
                            if (spaces % tabSize != 0) return false;
                            var spaces = 0;
                            while (line.charAt(after++) == " ") spaces++;
                            if (tabSize > 2) return spaces % tabSize != tabSize - 1;else return spaces % tabSize == 0;
                            return true;
                        };
                    }

                    function iter(fun) {
                        for (var i = startRow; i <= endRow; i++) fun(doc.getLine(i), i);
                    }

                    var minEmptyLength = Infinity;
                    iter(function (line, i) {
                        var indent = line.search(/\S/);
                        if (indent !== -1) {
                            if (indent < minIndent) minIndent = indent;
                            if (shouldRemove && !testRemove(line, i)) shouldRemove = false;
                        } else if (minEmptyLength > line.length) {
                            minEmptyLength = line.length;
                        }
                    });

                    if (minIndent == Infinity) {
                        minIndent = minEmptyLength;
                        ignoreBlankLines = false;
                        shouldRemove = false;
                    }

                    if (insertAtTabStop && minIndent % tabSize != 0) minIndent = Math.floor(minIndent / tabSize) * tabSize;

                    iter(shouldRemove ? uncomment : comment);
                };

                this.toggleBlockComment = function (state, session, range, cursor) {
                    var comment = this.blockComment;
                    if (!comment) return;
                    if (!comment.start && comment[0]) comment = comment[0];

                    var iterator = new TokenIterator(session, cursor.row, cursor.column);
                    var token = iterator.getCurrentToken();

                    var sel = session.selection;
                    var initialRange = session.selection.toOrientedRange();
                    var startRow, colDiff;

                    if (token && /comment/.test(token.type)) {
                        var startRange, endRange;
                        while (token && /comment/.test(token.type)) {
                            var i = token.value.indexOf(comment.start);
                            if (i != -1) {
                                var row = iterator.getCurrentTokenRow();
                                var column = iterator.getCurrentTokenColumn() + i;
                                startRange = new Range(row, column, row, column + comment.start.length);
                                break;
                            }
                            token = iterator.stepBackward();
                        }

                        var iterator = new TokenIterator(session, cursor.row, cursor.column);
                        var token = iterator.getCurrentToken();
                        while (token && /comment/.test(token.type)) {
                            var i = token.value.indexOf(comment.end);
                            if (i != -1) {
                                var row = iterator.getCurrentTokenRow();
                                var column = iterator.getCurrentTokenColumn() + i;
                                endRange = new Range(row, column, row, column + comment.end.length);
                                break;
                            }
                            token = iterator.stepForward();
                        }
                        if (endRange) session.remove(endRange);
                        if (startRange) {
                            session.remove(startRange);
                            startRow = startRange.start.row;
                            colDiff = -comment.start.length;
                        }
                    } else {
                        colDiff = comment.start.length;
                        startRow = range.start.row;
                        session.insert(range.end, comment.end);
                        session.insert(range.start, comment.start);
                    }
                    if (initialRange.start.row == startRow) initialRange.start.column += colDiff;
                    if (initialRange.end.row == startRow) initialRange.end.column += colDiff;
                    session.selection.fromOrientedRange(initialRange);
                };

                this.getNextLineIndent = function (state, line, tab) {
                    return this.$getIndent(line);
                };

                this.checkOutdent = function (state, line, input) {
                    return false;
                };

                this.autoOutdent = function (state, doc, row) {};

                this.$getIndent = function (line) {
                    return line.match(/^\s*/)[0];
                };

                this.createWorker = function (session) {
                    return null;
                };

                this.createModeDelegates = function (mapping) {
                    this.$embeds = [];
                    this.$modes = {};
                    for (var i in mapping) {
                        if (mapping[i]) {
                            this.$embeds.push(i);
                            this.$modes[i] = new mapping[i]();
                        }
                    }

                    var delegations = ["toggleBlockComment", "toggleCommentLines", "getNextLineIndent", "checkOutdent", "autoOutdent", "transformAction", "getCompletions"];

                    for (var i = 0; i < delegations.length; i++) {
                        (function (scope) {
                            var functionName = delegations[i];
                            var defaultHandler = scope[functionName];
                            scope[delegations[i]] = function () {
                                return this.$delegator(functionName, arguments, defaultHandler);
                            };
                        })(this);
                    }
                };

                this.$delegator = function (method, args, defaultHandler) {
                    var state = args[0];
                    if (typeof state != "string") state = state[0];
                    for (var i = 0; i < this.$embeds.length; i++) {
                        if (!this.$modes[this.$embeds[i]]) continue;

                        var split = state.split(this.$embeds[i]);
                        if (!split[0] && split[1]) {
                            args[0] = split[1];
                            var mode = this.$modes[this.$embeds[i]];
                            return mode[method].apply(mode, args);
                        }
                    }
                    var ret = defaultHandler.apply(this, args);
                    return defaultHandler ? ret : undefined;
                };

                this.transformAction = function (state, action, editor, session, param) {
                    if (this.$behaviour) {
                        var behaviours = this.$behaviour.getBehaviours();
                        for (var key in behaviours) {
                            if (behaviours[key][action]) {
                                var ret = behaviours[key][action].apply(this, arguments);
                                if (ret) {
                                    return ret;
                                }
                            }
                        }
                    }
                };

                this.getKeywords = function (append) {
                    if (!this.completionKeywords) {
                        var rules = this.$tokenizer.rules;
                        var completionKeywords = [];
                        for (var rule in rules) {
                            var ruleItr = rules[rule];
                            for (var r = 0, l = ruleItr.length; r < l; r++) {
                                if (typeof ruleItr[r].token === "string") {
                                    if (/keyword|support|storage/.test(ruleItr[r].token)) completionKeywords.push(ruleItr[r].regex);
                                } else if (typeof ruleItr[r].token === "object") {
                                    for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {
                                        if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                                            var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                                            completionKeywords.push(rule.substr(1, rule.length - 2));
                                        }
                                    }
                                }
                            }
                        }
                        this.completionKeywords = completionKeywords;
                    }
                    if (!append) return this.$keywordList;
                    return completionKeywords.concat(this.$keywordList || []);
                };

                this.$createKeywordList = function () {
                    if (!this.$highlightRules) this.getTokenizer();
                    return this.$keywordList = this.$highlightRules.$keywordList || [];
                };

                this.getCompletions = function (state, session, pos, prefix) {
                    var keywords = this.$keywordList || this.$createKeywordList();
                    return keywords.map(function (word) {
                        return {
                            name: word,
                            value: word,
                            score: 0,
                            meta: "keyword"
                        };
                    });
                };

                this.$id = "ace/mode/text";
            }).call(Mode.prototype);

            exports.Mode = Mode;
        });

        ace.define("ace/apply_delta", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            function throwDeltaError(delta, errorText) {
                console.log("Invalid Delta:", delta);
                throw "Invalid Delta: " + errorText;
            }

            function positionInDocument(docLines, position) {
                return position.row >= 0 && position.row < docLines.length && position.column >= 0 && position.column <= docLines[position.row].length;
            }

            function validateDelta(docLines, delta) {
                if (delta.action != "insert" && delta.action != "remove") throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
                if (!(delta.lines instanceof Array)) throwDeltaError(delta, "delta.lines must be an Array");
                if (!delta.start || !delta.end) throwDeltaError(delta, "delta.start/end must be an present");
                var start = delta.start;
                if (!positionInDocument(docLines, delta.start)) throwDeltaError(delta, "delta.start must be contained in document");
                var end = delta.end;
                if (delta.action == "remove" && !positionInDocument(docLines, end)) throwDeltaError(delta, "delta.end must contained in document for 'remove' actions");
                var numRangeRows = end.row - start.row;
                var numRangeLastLineChars = end.column - (numRangeRows == 0 ? start.column : 0);
                if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars) throwDeltaError(delta, "delta.range must match delta lines");
            }

            exports.applyDelta = function (docLines, delta, doNotValidate) {

                var row = delta.start.row;
                var startColumn = delta.start.column;
                var line = docLines[row] || "";
                switch (delta.action) {
                    case "insert":
                        var lines = delta.lines;
                        if (lines.length === 1) {
                            docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
                        } else {
                            var args = [row, 1].concat(delta.lines);
                            docLines.splice.apply(docLines, args);
                            docLines[row] = line.substring(0, startColumn) + docLines[row];
                            docLines[row + delta.lines.length - 1] += line.substring(startColumn);
                        }
                        break;
                    case "remove":
                        var endColumn = delta.end.column;
                        var endRow = delta.end.row;
                        if (row === endRow) {
                            docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
                        } else {
                            docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));
                        }
                        break;
                }
            };
        });

        ace.define("ace/anchor", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var EventEmitter = require("./lib/event_emitter").EventEmitter;

            var Anchor = exports.Anchor = function (doc, row, column) {
                this.$onChange = this.onChange.bind(this);
                this.attach(doc);

                if (typeof column == "undefined") this.setPosition(row.row, row.column);else this.setPosition(row, column);
            };

            (function () {

                oop.implement(this, EventEmitter);
                this.getPosition = function () {
                    return this.$clipPositionToDocument(this.row, this.column);
                };
                this.getDocument = function () {
                    return this.document;
                };
                this.$insertRight = false;
                this.onChange = function (delta) {
                    if (delta.start.row == delta.end.row && delta.start.row != this.row) return;

                    if (delta.start.row > this.row) return;

                    var point = $getTransformedPoint(delta, { row: this.row, column: this.column }, this.$insertRight);
                    this.setPosition(point.row, point.column, true);
                };

                function $pointsInOrder(point1, point2, equalPointsInOrder) {
                    var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
                    return point1.row < point2.row || point1.row == point2.row && bColIsAfter;
                }

                function $getTransformedPoint(delta, point, moveIfEqual) {
                    var deltaIsInsert = delta.action == "insert";
                    var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);
                    var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
                    var deltaStart = delta.start;
                    var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
                    if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
                        return {
                            row: point.row,
                            column: point.column
                        };
                    }
                    if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
                        return {
                            row: point.row + deltaRowShift,
                            column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
                        };
                    }

                    return {
                        row: deltaStart.row,
                        column: deltaStart.column
                    };
                }
                this.setPosition = function (row, column, noClip) {
                    var pos;
                    if (noClip) {
                        pos = {
                            row: row,
                            column: column
                        };
                    } else {
                        pos = this.$clipPositionToDocument(row, column);
                    }

                    if (this.row == pos.row && this.column == pos.column) return;

                    var old = {
                        row: this.row,
                        column: this.column
                    };

                    this.row = pos.row;
                    this.column = pos.column;
                    this._signal("change", {
                        old: old,
                        value: pos
                    });
                };
                this.detach = function () {
                    this.document.removeEventListener("change", this.$onChange);
                };
                this.attach = function (doc) {
                    this.document = doc || this.document;
                    this.document.on("change", this.$onChange);
                };
                this.$clipPositionToDocument = function (row, column) {
                    var pos = {};

                    if (row >= this.document.getLength()) {
                        pos.row = Math.max(0, this.document.getLength() - 1);
                        pos.column = this.document.getLine(pos.row).length;
                    } else if (row < 0) {
                        pos.row = 0;
                        pos.column = 0;
                    } else {
                        pos.row = row;
                        pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
                    }

                    if (column < 0) pos.column = 0;

                    return pos;
                };
            }).call(Anchor.prototype);
        });

        ace.define("ace/document", ["require", "exports", "module", "ace/lib/oop", "ace/apply_delta", "ace/lib/event_emitter", "ace/range", "ace/anchor"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var applyDelta = require("./apply_delta").applyDelta;
            var EventEmitter = require("./lib/event_emitter").EventEmitter;
            var Range = require("./range").Range;
            var Anchor = require("./anchor").Anchor;

            var Document = function (textOrLines) {
                this.$lines = [""];
                if (textOrLines.length === 0) {
                    this.$lines = [""];
                } else if (Array.isArray(textOrLines)) {
                    this.insertMergedLines({ row: 0, column: 0 }, textOrLines);
                } else {
                    this.insert({ row: 0, column: 0 }, textOrLines);
                }
            };

            (function () {

                oop.implement(this, EventEmitter);
                this.setValue = function (text) {
                    var len = this.getLength() - 1;
                    this.remove(new Range(0, 0, len, this.getLine(len).length));
                    this.insert({ row: 0, column: 0 }, text);
                };
                this.getValue = function () {
                    return this.getAllLines().join(this.getNewLineCharacter());
                };
                this.createAnchor = function (row, column) {
                    return new Anchor(this, row, column);
                };
                if ("aaa".split(/a/).length === 0) {
                    this.$split = function (text) {
                        return text.replace(/\r\n|\r/g, "\n").split("\n");
                    };
                } else {
                    this.$split = function (text) {
                        return text.split(/\r\n|\r|\n/);
                    };
                }

                this.$detectNewLine = function (text) {
                    var match = text.match(/^.*?(\r\n|\r|\n)/m);
                    this.$autoNewLine = match ? match[1] : "\n";
                    this._signal("changeNewLineMode");
                };
                this.getNewLineCharacter = function () {
                    switch (this.$newLineMode) {
                        case "windows":
                            return "\r\n";
                        case "unix":
                            return "\n";
                        default:
                            return this.$autoNewLine || "\n";
                    }
                };

                this.$autoNewLine = "";
                this.$newLineMode = "auto";
                this.setNewLineMode = function (newLineMode) {
                    if (this.$newLineMode === newLineMode) return;

                    this.$newLineMode = newLineMode;
                    this._signal("changeNewLineMode");
                };
                this.getNewLineMode = function () {
                    return this.$newLineMode;
                };
                this.isNewLine = function (text) {
                    return text == "\r\n" || text == "\r" || text == "\n";
                };
                this.getLine = function (row) {
                    return this.$lines[row] || "";
                };
                this.getLines = function (firstRow, lastRow) {
                    return this.$lines.slice(firstRow, lastRow + 1);
                };
                this.getAllLines = function () {
                    return this.getLines(0, this.getLength());
                };
                this.getLength = function () {
                    return this.$lines.length;
                };
                this.getTextRange = function (range) {
                    return this.getLinesForRange(range).join(this.getNewLineCharacter());
                };
                this.getLinesForRange = function (range) {
                    var lines;
                    if (range.start.row === range.end.row) {
                        lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
                    } else {
                        lines = this.getLines(range.start.row, range.end.row);
                        lines[0] = (lines[0] || "").substring(range.start.column);
                        var l = lines.length - 1;
                        if (range.end.row - range.start.row == l) lines[l] = lines[l].substring(0, range.end.column);
                    }
                    return lines;
                };
                this.insertLines = function (row, lines) {
                    console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
                    return this.insertFullLines(row, lines);
                };
                this.removeLines = function (firstRow, lastRow) {
                    console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
                    return this.removeFullLines(firstRow, lastRow);
                };
                this.insertNewLine = function (position) {
                    console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
                    return this.insertMergedLines(position, ["", ""]);
                };
                this.insert = function (position, text) {
                    if (this.getLength() <= 1) this.$detectNewLine(text);

                    return this.insertMergedLines(position, this.$split(text));
                };
                this.insertInLine = function (position, text) {
                    var start = this.clippedPos(position.row, position.column);
                    var end = this.pos(position.row, position.column + text.length);

                    this.applyDelta({
                        start: start,
                        end: end,
                        action: "insert",
                        lines: [text]
                    }, true);

                    return this.clonePos(end);
                };

                this.clippedPos = function (row, column) {
                    var length = this.getLength();
                    if (row === undefined) {
                        row = length;
                    } else if (row < 0) {
                        row = 0;
                    } else if (row >= length) {
                        row = length - 1;
                        column = undefined;
                    }
                    var line = this.getLine(row);
                    if (column == undefined) column = line.length;
                    column = Math.min(Math.max(column, 0), line.length);
                    return { row: row, column: column };
                };

                this.clonePos = function (pos) {
                    return { row: pos.row, column: pos.column };
                };

                this.pos = function (row, column) {
                    return { row: row, column: column };
                };

                this.$clipPosition = function (position) {
                    var length = this.getLength();
                    if (position.row >= length) {
                        position.row = Math.max(0, length - 1);
                        position.column = this.getLine(length - 1).length;
                    } else {
                        position.row = Math.max(0, position.row);
                        position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
                    }
                    return position;
                };
                this.insertFullLines = function (row, lines) {
                    row = Math.min(Math.max(row, 0), this.getLength());
                    var column = 0;
                    if (row < this.getLength()) {
                        lines = lines.concat([""]);
                        column = 0;
                    } else {
                        lines = [""].concat(lines);
                        row--;
                        column = this.$lines[row].length;
                    }
                    this.insertMergedLines({ row: row, column: column }, lines);
                };
                this.insertMergedLines = function (position, lines) {
                    var start = this.clippedPos(position.row, position.column);
                    var end = {
                        row: start.row + lines.length - 1,
                        column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
                    };

                    this.applyDelta({
                        start: start,
                        end: end,
                        action: "insert",
                        lines: lines
                    });

                    return this.clonePos(end);
                };
                this.remove = function (range) {
                    var start = this.clippedPos(range.start.row, range.start.column);
                    var end = this.clippedPos(range.end.row, range.end.column);
                    this.applyDelta({
                        start: start,
                        end: end,
                        action: "remove",
                        lines: this.getLinesForRange({ start: start, end: end })
                    });
                    return this.clonePos(start);
                };
                this.removeInLine = function (row, startColumn, endColumn) {
                    var start = this.clippedPos(row, startColumn);
                    var end = this.clippedPos(row, endColumn);

                    this.applyDelta({
                        start: start,
                        end: end,
                        action: "remove",
                        lines: this.getLinesForRange({ start: start, end: end })
                    }, true);

                    return this.clonePos(start);
                };
                this.removeFullLines = function (firstRow, lastRow) {
                    firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
                    lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);
                    var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
                    var deleteLastNewLine = lastRow < this.getLength() - 1;
                    var startRow = deleteFirstNewLine ? firstRow - 1 : firstRow;
                    var startCol = deleteFirstNewLine ? this.getLine(startRow).length : 0;
                    var endRow = deleteLastNewLine ? lastRow + 1 : lastRow;
                    var endCol = deleteLastNewLine ? 0 : this.getLine(endRow).length;
                    var range = new Range(startRow, startCol, endRow, endCol);
                    var deletedLines = this.$lines.slice(firstRow, lastRow + 1);

                    this.applyDelta({
                        start: range.start,
                        end: range.end,
                        action: "remove",
                        lines: this.getLinesForRange(range)
                    });
                    return deletedLines;
                };
                this.removeNewLine = function (row) {
                    if (row < this.getLength() - 1 && row >= 0) {
                        this.applyDelta({
                            start: this.pos(row, this.getLine(row).length),
                            end: this.pos(row + 1, 0),
                            action: "remove",
                            lines: ["", ""]
                        });
                    }
                };
                this.replace = function (range, text) {
                    if (!(range instanceof Range)) range = Range.fromPoints(range.start, range.end);
                    if (text.length === 0 && range.isEmpty()) return range.start;
                    if (text == this.getTextRange(range)) return range.end;

                    this.remove(range);
                    var end;
                    if (text) {
                        end = this.insert(range.start, text);
                    } else {
                        end = range.start;
                    }

                    return end;
                };
                this.applyDeltas = function (deltas) {
                    for (var i = 0; i < deltas.length; i++) {
                        this.applyDelta(deltas[i]);
                    }
                };
                this.revertDeltas = function (deltas) {
                    for (var i = deltas.length - 1; i >= 0; i--) {
                        this.revertDelta(deltas[i]);
                    }
                };
                this.applyDelta = function (delta, doNotValidate) {
                    var isInsert = delta.action == "insert";
                    if (isInsert ? delta.lines.length <= 1 && !delta.lines[0] : !Range.comparePoints(delta.start, delta.end)) {
                        return;
                    }

                    if (isInsert && delta.lines.length > 20000) this.$splitAndapplyLargeDelta(delta, 20000);
                    applyDelta(this.$lines, delta, doNotValidate);
                    this._signal("change", delta);
                };

                this.$splitAndapplyLargeDelta = function (delta, MAX) {
                    var lines = delta.lines;
                    var l = lines.length;
                    var row = delta.start.row;
                    var column = delta.start.column;
                    var from = 0,
                        to = 0;
                    do {
                        from = to;
                        to += MAX - 1;
                        var chunk = lines.slice(from, to);
                        if (to > l) {
                            delta.lines = chunk;
                            delta.start.row = row + from;
                            delta.start.column = column;
                            break;
                        }
                        chunk.push("");
                        this.applyDelta({
                            start: this.pos(row + from, column),
                            end: this.pos(row + to, column = 0),
                            action: delta.action,
                            lines: chunk
                        }, true);
                    } while (true);
                };
                this.revertDelta = function (delta) {
                    this.applyDelta({
                        start: this.clonePos(delta.start),
                        end: this.clonePos(delta.end),
                        action: delta.action == "insert" ? "remove" : "insert",
                        lines: delta.lines.slice()
                    });
                };
                this.indexToPosition = function (index, startRow) {
                    var lines = this.$lines || this.getAllLines();
                    var newlineLength = this.getNewLineCharacter().length;
                    for (var i = startRow || 0, l = lines.length; i < l; i++) {
                        index -= lines[i].length + newlineLength;
                        if (index < 0) return { row: i, column: index + lines[i].length + newlineLength };
                    }
                    return { row: l - 1, column: lines[l - 1].length };
                };
                this.positionToIndex = function (pos, startRow) {
                    var lines = this.$lines || this.getAllLines();
                    var newlineLength = this.getNewLineCharacter().length;
                    var index = 0;
                    var row = Math.min(pos.row, lines.length);
                    for (var i = startRow || 0; i < row; ++i) index += lines[i].length + newlineLength;

                    return index + pos.column;
                };
            }).call(Document.prototype);

            exports.Document = Document;
        });

        ace.define("ace/background_tokenizer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var EventEmitter = require("./lib/event_emitter").EventEmitter;

            var BackgroundTokenizer = function (tokenizer, editor) {
                this.running = false;
                this.lines = [];
                this.states = [];
                this.currentLine = 0;
                this.tokenizer = tokenizer;

                var self = this;

                this.$worker = function () {
                    if (!self.running) {
                        return;
                    }

                    var workerStart = new Date();
                    var currentLine = self.currentLine;
                    var endLine = -1;
                    var doc = self.doc;

                    var startLine = currentLine;
                    while (self.lines[currentLine]) currentLine++;

                    var len = doc.getLength();
                    var processedLines = 0;
                    self.running = false;
                    while (currentLine < len) {
                        self.$tokenizeRow(currentLine);
                        endLine = currentLine;
                        do {
                            currentLine++;
                        } while (self.lines[currentLine]);
                        processedLines++;
                        if (processedLines % 5 === 0 && new Date() - workerStart > 20) {
                            self.running = setTimeout(self.$worker, 20);
                            break;
                        }
                    }
                    self.currentLine = currentLine;

                    if (startLine <= endLine) self.fireUpdateEvent(startLine, endLine);
                };
            };

            (function () {

                oop.implement(this, EventEmitter);
                this.setTokenizer = function (tokenizer) {
                    this.tokenizer = tokenizer;
                    this.lines = [];
                    this.states = [];

                    this.start(0);
                };
                this.setDocument = function (doc) {
                    this.doc = doc;
                    this.lines = [];
                    this.states = [];

                    this.stop();
                };
                this.fireUpdateEvent = function (firstRow, lastRow) {
                    var data = {
                        first: firstRow,
                        last: lastRow
                    };
                    this._signal("update", { data: data });
                };
                this.start = function (startRow) {
                    this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
                    this.lines.splice(this.currentLine, this.lines.length);
                    this.states.splice(this.currentLine, this.states.length);

                    this.stop();
                    this.running = setTimeout(this.$worker, 700);
                };

                this.scheduleStart = function () {
                    if (!this.running) this.running = setTimeout(this.$worker, 700);
                };

                this.$updateOnChange = function (delta) {
                    var startRow = delta.start.row;
                    var len = delta.end.row - startRow;

                    if (len === 0) {
                        this.lines[startRow] = null;
                    } else if (delta.action == "remove") {
                        this.lines.splice(startRow, len + 1, null);
                        this.states.splice(startRow, len + 1, null);
                    } else {
                        var args = Array(len + 1);
                        args.unshift(startRow, 1);
                        this.lines.splice.apply(this.lines, args);
                        this.states.splice.apply(this.states, args);
                    }

                    this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());

                    this.stop();
                };
                this.stop = function () {
                    if (this.running) clearTimeout(this.running);
                    this.running = false;
                };
                this.getTokens = function (row) {
                    return this.lines[row] || this.$tokenizeRow(row);
                };
                this.getState = function (row) {
                    if (this.currentLine == row) this.$tokenizeRow(row);
                    return this.states[row] || "start";
                };

                this.$tokenizeRow = function (row) {
                    var line = this.doc.getLine(row);
                    var state = this.states[row - 1];

                    var data = this.tokenizer.getLineTokens(line, state, row);

                    if (this.states[row] + "" !== data.state + "") {
                        this.states[row] = data.state;
                        this.lines[row + 1] = null;
                        if (this.currentLine > row + 1) this.currentLine = row + 1;
                    } else if (this.currentLine == row) {
                        this.currentLine = row + 1;
                    }

                    return this.lines[row] = data.tokens;
                };
            }).call(BackgroundTokenizer.prototype);

            exports.BackgroundTokenizer = BackgroundTokenizer;
        });

        ace.define("ace/search_highlight", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function (require, exports, module) {
            "use strict";

            var lang = require("./lib/lang");
            var oop = require("./lib/oop");
            var Range = require("./range").Range;

            var SearchHighlight = function (regExp, clazz, type) {
                this.setRegexp(regExp);
                this.clazz = clazz;
                this.type = type || "text";
            };

            (function () {
                this.MAX_RANGES = 500;

                this.setRegexp = function (regExp) {
                    if (this.regExp + "" == regExp + "") return;
                    this.regExp = regExp;
                    this.cache = [];
                };

                this.update = function (html, markerLayer, session, config) {
                    if (!this.regExp) return;
                    var start = config.firstRow,
                        end = config.lastRow;

                    for (var i = start; i <= end; i++) {
                        var ranges = this.cache[i];
                        if (ranges == null) {
                            ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
                            if (ranges.length > this.MAX_RANGES) ranges = ranges.slice(0, this.MAX_RANGES);
                            ranges = ranges.map(function (match) {
                                return new Range(i, match.offset, i, match.offset + match.length);
                            });
                            this.cache[i] = ranges.length ? ranges : "";
                        }

                        for (var j = ranges.length; j--;) {
                            markerLayer.drawSingleLineMarker(html, ranges[j].toScreenRange(session), this.clazz, config);
                        }
                    }
                };
            }).call(SearchHighlight.prototype);

            exports.SearchHighlight = SearchHighlight;
        });

        ace.define("ace/edit_session/fold_line", ["require", "exports", "module", "ace/range"], function (require, exports, module) {
            "use strict";

            var Range = require("../range").Range;
            function FoldLine(foldData, folds) {
                this.foldData = foldData;
                if (Array.isArray(folds)) {
                    this.folds = folds;
                } else {
                    folds = this.folds = [folds];
                }

                var last = folds[folds.length - 1];
                this.range = new Range(folds[0].start.row, folds[0].start.column, last.end.row, last.end.column);
                this.start = this.range.start;
                this.end = this.range.end;

                this.folds.forEach(function (fold) {
                    fold.setFoldLine(this);
                }, this);
            }

            (function () {
                this.shiftRow = function (shift) {
                    this.start.row += shift;
                    this.end.row += shift;
                    this.folds.forEach(function (fold) {
                        fold.start.row += shift;
                        fold.end.row += shift;
                    });
                };

                this.addFold = function (fold) {
                    if (fold.sameRow) {
                        if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
                            throw new Error("Can't add a fold to this FoldLine as it has no connection");
                        }
                        this.folds.push(fold);
                        this.folds.sort(function (a, b) {
                            return -a.range.compareEnd(b.start.row, b.start.column);
                        });
                        if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
                            this.end.row = fold.end.row;
                            this.end.column = fold.end.column;
                        } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
                            this.start.row = fold.start.row;
                            this.start.column = fold.start.column;
                        }
                    } else if (fold.start.row == this.end.row) {
                        this.folds.push(fold);
                        this.end.row = fold.end.row;
                        this.end.column = fold.end.column;
                    } else if (fold.end.row == this.start.row) {
                        this.folds.unshift(fold);
                        this.start.row = fold.start.row;
                        this.start.column = fold.start.column;
                    } else {
                        throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
                    }
                    fold.foldLine = this;
                };

                this.containsRow = function (row) {
                    return row >= this.start.row && row <= this.end.row;
                };

                this.walk = function (callback, endRow, endColumn) {
                    var lastEnd = 0,
                        folds = this.folds,
                        fold,
                        cmp,
                        stop,
                        isNewRow = true;

                    if (endRow == null) {
                        endRow = this.end.row;
                        endColumn = this.end.column;
                    }

                    for (var i = 0; i < folds.length; i++) {
                        fold = folds[i];

                        cmp = fold.range.compareStart(endRow, endColumn);
                        if (cmp == -1) {
                            callback(null, endRow, endColumn, lastEnd, isNewRow);
                            return;
                        }

                        stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
                        stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
                        if (stop || cmp === 0) {
                            return;
                        }
                        isNewRow = !fold.sameRow;
                        lastEnd = fold.end.column;
                    }
                    callback(null, endRow, endColumn, lastEnd, isNewRow);
                };

                this.getNextFoldTo = function (row, column) {
                    var fold, cmp;
                    for (var i = 0; i < this.folds.length; i++) {
                        fold = this.folds[i];
                        cmp = fold.range.compareEnd(row, column);
                        if (cmp == -1) {
                            return {
                                fold: fold,
                                kind: "after"
                            };
                        } else if (cmp === 0) {
                            return {
                                fold: fold,
                                kind: "inside"
                            };
                        }
                    }
                    return null;
                };

                this.addRemoveChars = function (row, column, len) {
                    var ret = this.getNextFoldTo(row, column),
                        fold,
                        folds;
                    if (ret) {
                        fold = ret.fold;
                        if (ret.kind == "inside" && fold.start.column != column && fold.start.row != row) {
                            window.console && window.console.log(row, column, fold);
                        } else if (fold.start.row == row) {
                            folds = this.folds;
                            var i = folds.indexOf(fold);
                            if (i === 0) {
                                this.start.column += len;
                            }
                            for (i; i < folds.length; i++) {
                                fold = folds[i];
                                fold.start.column += len;
                                if (!fold.sameRow) {
                                    return;
                                }
                                fold.end.column += len;
                            }
                            this.end.column += len;
                        }
                    }
                };

                this.split = function (row, column) {
                    var pos = this.getNextFoldTo(row, column);

                    if (!pos || pos.kind == "inside") return null;

                    var fold = pos.fold;
                    var folds = this.folds;
                    var foldData = this.foldData;

                    var i = folds.indexOf(fold);
                    var foldBefore = folds[i - 1];
                    this.end.row = foldBefore.end.row;
                    this.end.column = foldBefore.end.column;
                    folds = folds.splice(i, folds.length - i);

                    var newFoldLine = new FoldLine(foldData, folds);
                    foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
                    return newFoldLine;
                };

                this.merge = function (foldLineNext) {
                    var folds = foldLineNext.folds;
                    for (var i = 0; i < folds.length; i++) {
                        this.addFold(folds[i]);
                    }
                    var foldData = this.foldData;
                    foldData.splice(foldData.indexOf(foldLineNext), 1);
                };

                this.toString = function () {
                    var ret = [this.range.toString() + ": ["];

                    this.folds.forEach(function (fold) {
                        ret.push("  " + fold.toString());
                    });
                    ret.push("]");
                    return ret.join("\n");
                };

                this.idxToPosition = function (idx) {
                    var lastFoldEndColumn = 0;

                    for (var i = 0; i < this.folds.length; i++) {
                        var fold = this.folds[i];

                        idx -= fold.start.column - lastFoldEndColumn;
                        if (idx < 0) {
                            return {
                                row: fold.start.row,
                                column: fold.start.column + idx
                            };
                        }

                        idx -= fold.placeholder.length;
                        if (idx < 0) {
                            return fold.start;
                        }

                        lastFoldEndColumn = fold.end.column;
                    }

                    return {
                        row: this.end.row,
                        column: this.end.column + idx
                    };
                };
            }).call(FoldLine.prototype);

            exports.FoldLine = FoldLine;
        });

        ace.define("ace/range_list", ["require", "exports", "module", "ace/range"], function (require, exports, module) {
            "use strict";

            var Range = require("./range").Range;
            var comparePoints = Range.comparePoints;

            var RangeList = function () {
                this.ranges = [];
            };

            (function () {
                this.comparePoints = comparePoints;

                this.pointIndex = function (pos, excludeEdges, startIndex) {
                    var list = this.ranges;

                    for (var i = startIndex || 0; i < list.length; i++) {
                        var range = list[i];
                        var cmpEnd = comparePoints(pos, range.end);
                        if (cmpEnd > 0) continue;
                        var cmpStart = comparePoints(pos, range.start);
                        if (cmpEnd === 0) return excludeEdges && cmpStart !== 0 ? -i - 2 : i;
                        if (cmpStart > 0 || cmpStart === 0 && !excludeEdges) return i;

                        return -i - 1;
                    }
                    return -i - 1;
                };

                this.add = function (range) {
                    var excludeEdges = !range.isEmpty();
                    var startIndex = this.pointIndex(range.start, excludeEdges);
                    if (startIndex < 0) startIndex = -startIndex - 1;

                    var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);

                    if (endIndex < 0) endIndex = -endIndex - 1;else endIndex++;
                    return this.ranges.splice(startIndex, endIndex - startIndex, range);
                };

                this.addList = function (list) {
                    var removed = [];
                    for (var i = list.length; i--;) {
                        removed.push.apply(removed, this.add(list[i]));
                    }
                    return removed;
                };

                this.substractPoint = function (pos) {
                    var i = this.pointIndex(pos);

                    if (i >= 0) return this.ranges.splice(i, 1);
                };
                this.merge = function () {
                    var removed = [];
                    var list = this.ranges;

                    list = list.sort(function (a, b) {
                        return comparePoints(a.start, b.start);
                    });

                    var next = list[0],
                        range;
                    for (var i = 1; i < list.length; i++) {
                        range = next;
                        next = list[i];
                        var cmp = comparePoints(range.end, next.start);
                        if (cmp < 0) continue;

                        if (cmp == 0 && !range.isEmpty() && !next.isEmpty()) continue;

                        if (comparePoints(range.end, next.end) < 0) {
                            range.end.row = next.end.row;
                            range.end.column = next.end.column;
                        }

                        list.splice(i, 1);
                        removed.push(next);
                        next = range;
                        i--;
                    }

                    this.ranges = list;

                    return removed;
                };

                this.contains = function (row, column) {
                    return this.pointIndex({ row: row, column: column }) >= 0;
                };

                this.containsPoint = function (pos) {
                    return this.pointIndex(pos) >= 0;
                };

                this.rangeAtPoint = function (pos) {
                    var i = this.pointIndex(pos);
                    if (i >= 0) return this.ranges[i];
                };

                this.clipRows = function (startRow, endRow) {
                    var list = this.ranges;
                    if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow) return [];

                    var startIndex = this.pointIndex({ row: startRow, column: 0 });
                    if (startIndex < 0) startIndex = -startIndex - 1;
                    var endIndex = this.pointIndex({ row: endRow, column: 0 }, startIndex);
                    if (endIndex < 0) endIndex = -endIndex - 1;

                    var clipped = [];
                    for (var i = startIndex; i < endIndex; i++) {
                        clipped.push(list[i]);
                    }
                    return clipped;
                };

                this.removeAll = function () {
                    return this.ranges.splice(0, this.ranges.length);
                };

                this.attach = function (session) {
                    if (this.session) this.detach();

                    this.session = session;
                    this.onChange = this.$onChange.bind(this);

                    this.session.on('change', this.onChange);
                };

                this.detach = function () {
                    if (!this.session) return;
                    this.session.removeListener('change', this.onChange);
                    this.session = null;
                };

                this.$onChange = function (delta) {
                    if (delta.action == "insert") {
                        var start = delta.start;
                        var end = delta.end;
                    } else {
                        var end = delta.start;
                        var start = delta.end;
                    }
                    var startRow = start.row;
                    var endRow = end.row;
                    var lineDif = endRow - startRow;

                    var colDiff = -start.column + end.column;
                    var ranges = this.ranges;

                    for (var i = 0, n = ranges.length; i < n; i++) {
                        var r = ranges[i];
                        if (r.end.row < startRow) continue;
                        if (r.start.row > startRow) break;

                        if (r.start.row == startRow && r.start.column >= start.column) {
                            if (r.start.column == start.column && this.$insertRight) {} else {
                                r.start.column += colDiff;
                                r.start.row += lineDif;
                            }
                        }
                        if (r.end.row == startRow && r.end.column >= start.column) {
                            if (r.end.column == start.column && this.$insertRight) {
                                continue;
                            }
                            if (r.end.column == start.column && colDiff > 0 && i < n - 1) {
                                if (r.end.column > r.start.column && r.end.column == ranges[i + 1].start.column) r.end.column -= colDiff;
                            }
                            r.end.column += colDiff;
                            r.end.row += lineDif;
                        }
                    }

                    if (lineDif != 0 && i < n) {
                        for (; i < n; i++) {
                            var r = ranges[i];
                            r.start.row += lineDif;
                            r.end.row += lineDif;
                        }
                    }
                };
            }).call(RangeList.prototype);

            exports.RangeList = RangeList;
        });

        ace.define("ace/edit_session/fold", ["require", "exports", "module", "ace/range", "ace/range_list", "ace/lib/oop"], function (require, exports, module) {
            "use strict";

            var Range = require("../range").Range;
            var RangeList = require("../range_list").RangeList;
            var oop = require("../lib/oop");
            var Fold = exports.Fold = function (range, placeholder) {
                this.foldLine = null;
                this.placeholder = placeholder;
                this.range = range;
                this.start = range.start;
                this.end = range.end;

                this.sameRow = range.start.row == range.end.row;
                this.subFolds = this.ranges = [];
            };

            oop.inherits(Fold, RangeList);

            (function () {

                this.toString = function () {
                    return '"' + this.placeholder + '" ' + this.range.toString();
                };

                this.setFoldLine = function (foldLine) {
                    this.foldLine = foldLine;
                    this.subFolds.forEach(function (fold) {
                        fold.setFoldLine(foldLine);
                    });
                };

                this.clone = function () {
                    var range = this.range.clone();
                    var fold = new Fold(range, this.placeholder);
                    this.subFolds.forEach(function (subFold) {
                        fold.subFolds.push(subFold.clone());
                    });
                    fold.collapseChildren = this.collapseChildren;
                    return fold;
                };

                this.addSubFold = function (fold) {
                    if (this.range.isEqual(fold)) return;

                    if (!this.range.containsRange(fold)) throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
                    consumeRange(fold, this.start);

                    var row = fold.start.row,
                        column = fold.start.column;
                    for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
                        cmp = this.subFolds[i].range.compare(row, column);
                        if (cmp != 1) break;
                    }
                    var afterStart = this.subFolds[i];

                    if (cmp == 0) return afterStart.addSubFold(fold);
                    var row = fold.range.end.row,
                        column = fold.range.end.column;
                    for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
                        cmp = this.subFolds[j].range.compare(row, column);
                        if (cmp != 1) break;
                    }
                    var afterEnd = this.subFolds[j];

                    if (cmp == 0) throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);

                    var consumedFolds = this.subFolds.splice(i, j - i, fold);
                    fold.setFoldLine(this.foldLine);

                    return fold;
                };

                this.restoreRange = function (range) {
                    return restoreRange(range, this.start);
                };
            }).call(Fold.prototype);

            function consumePoint(point, anchor) {
                point.row -= anchor.row;
                if (point.row == 0) point.column -= anchor.column;
            }
            function consumeRange(range, anchor) {
                consumePoint(range.start, anchor);
                consumePoint(range.end, anchor);
            }
            function restorePoint(point, anchor) {
                if (point.row == 0) point.column += anchor.column;
                point.row += anchor.row;
            }
            function restoreRange(range, anchor) {
                restorePoint(range.start, anchor);
                restorePoint(range.end, anchor);
            }
        });

        ace.define("ace/edit_session/folding", ["require", "exports", "module", "ace/range", "ace/edit_session/fold_line", "ace/edit_session/fold", "ace/token_iterator"], function (require, exports, module) {
            "use strict";

            var Range = require("../range").Range;
            var FoldLine = require("./fold_line").FoldLine;
            var Fold = require("./fold").Fold;
            var TokenIterator = require("../token_iterator").TokenIterator;

            function Folding() {
                this.getFoldAt = function (row, column, side) {
                    var foldLine = this.getFoldLine(row);
                    if (!foldLine) return null;

                    var folds = foldLine.folds;
                    for (var i = 0; i < folds.length; i++) {
                        var fold = folds[i];
                        if (fold.range.contains(row, column)) {
                            if (side == 1 && fold.range.isEnd(row, column)) {
                                continue;
                            } else if (side == -1 && fold.range.isStart(row, column)) {
                                continue;
                            }
                            return fold;
                        }
                    }
                };
                this.getFoldsInRange = function (range) {
                    var start = range.start;
                    var end = range.end;
                    var foldLines = this.$foldData;
                    var foundFolds = [];

                    start.column += 1;
                    end.column -= 1;

                    for (var i = 0; i < foldLines.length; i++) {
                        var cmp = foldLines[i].range.compareRange(range);
                        if (cmp == 2) {
                            continue;
                        } else if (cmp == -2) {
                            break;
                        }

                        var folds = foldLines[i].folds;
                        for (var j = 0; j < folds.length; j++) {
                            var fold = folds[j];
                            cmp = fold.range.compareRange(range);
                            if (cmp == -2) {
                                break;
                            } else if (cmp == 2) {
                                continue;
                            } else if (cmp == 42) {
                                break;
                            }
                            foundFolds.push(fold);
                        }
                    }
                    start.column -= 1;
                    end.column += 1;

                    return foundFolds;
                };

                this.getFoldsInRangeList = function (ranges) {
                    if (Array.isArray(ranges)) {
                        var folds = [];
                        ranges.forEach(function (range) {
                            folds = folds.concat(this.getFoldsInRange(range));
                        }, this);
                    } else {
                        var folds = this.getFoldsInRange(ranges);
                    }
                    return folds;
                };
                this.getAllFolds = function () {
                    var folds = [];
                    var foldLines = this.$foldData;

                    for (var i = 0; i < foldLines.length; i++) for (var j = 0; j < foldLines[i].folds.length; j++) folds.push(foldLines[i].folds[j]);

                    return folds;
                };
                this.getFoldStringAt = function (row, column, trim, foldLine) {
                    foldLine = foldLine || this.getFoldLine(row);
                    if (!foldLine) return null;

                    var lastFold = {
                        end: { column: 0 }
                    };
                    var str, fold;
                    for (var i = 0; i < foldLine.folds.length; i++) {
                        fold = foldLine.folds[i];
                        var cmp = fold.range.compareEnd(row, column);
                        if (cmp == -1) {
                            str = this.getLine(fold.start.row).substring(lastFold.end.column, fold.start.column);
                            break;
                        } else if (cmp === 0) {
                            return null;
                        }
                        lastFold = fold;
                    }
                    if (!str) str = this.getLine(fold.start.row).substring(lastFold.end.column);

                    if (trim == -1) return str.substring(0, column - lastFold.end.column);else if (trim == 1) return str.substring(column - lastFold.end.column);else return str;
                };

                this.getFoldLine = function (docRow, startFoldLine) {
                    var foldData = this.$foldData;
                    var i = 0;
                    if (startFoldLine) i = foldData.indexOf(startFoldLine);
                    if (i == -1) i = 0;
                    for (i; i < foldData.length; i++) {
                        var foldLine = foldData[i];
                        if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
                            return foldLine;
                        } else if (foldLine.end.row > docRow) {
                            return null;
                        }
                    }
                    return null;
                };
                this.getNextFoldLine = function (docRow, startFoldLine) {
                    var foldData = this.$foldData;
                    var i = 0;
                    if (startFoldLine) i = foldData.indexOf(startFoldLine);
                    if (i == -1) i = 0;
                    for (i; i < foldData.length; i++) {
                        var foldLine = foldData[i];
                        if (foldLine.end.row >= docRow) {
                            return foldLine;
                        }
                    }
                    return null;
                };

                this.getFoldedRowCount = function (first, last) {
                    var foldData = this.$foldData,
                        rowCount = last - first + 1;
                    for (var i = 0; i < foldData.length; i++) {
                        var foldLine = foldData[i],
                            end = foldLine.end.row,
                            start = foldLine.start.row;
                        if (end >= last) {
                            if (start < last) {
                                if (start >= first) rowCount -= last - start;else rowCount = 0; // in one fold
                            }
                            break;
                        } else if (end >= first) {
                            if (start >= first) // fold inside range
                                rowCount -= end - start;else rowCount -= end - first + 1;
                        }
                    }
                    return rowCount;
                };

                this.$addFoldLine = function (foldLine) {
                    this.$foldData.push(foldLine);
                    this.$foldData.sort(function (a, b) {
                        return a.start.row - b.start.row;
                    });
                    return foldLine;
                };
                this.addFold = function (placeholder, range) {
                    var foldData = this.$foldData;
                    var added = false;
                    var fold;

                    if (placeholder instanceof Fold) fold = placeholder;else {
                        fold = new Fold(range, placeholder);
                        fold.collapseChildren = range.collapseChildren;
                    }
                    this.$clipRangeToDocument(fold.range);

                    var startRow = fold.start.row;
                    var startColumn = fold.start.column;
                    var endRow = fold.end.row;
                    var endColumn = fold.end.column;
                    if (!(startRow < endRow || startRow == endRow && startColumn <= endColumn - 2)) throw new Error("The range has to be at least 2 characters width");

                    var startFold = this.getFoldAt(startRow, startColumn, 1);
                    var endFold = this.getFoldAt(endRow, endColumn, -1);
                    if (startFold && endFold == startFold) return startFold.addSubFold(fold);

                    if (startFold && !startFold.range.isStart(startRow, startColumn)) this.removeFold(startFold);

                    if (endFold && !endFold.range.isEnd(endRow, endColumn)) this.removeFold(endFold);
                    var folds = this.getFoldsInRange(fold.range);
                    if (folds.length > 0) {
                        this.removeFolds(folds);
                        folds.forEach(function (subFold) {
                            fold.addSubFold(subFold);
                        });
                    }

                    for (var i = 0; i < foldData.length; i++) {
                        var foldLine = foldData[i];
                        if (endRow == foldLine.start.row) {
                            foldLine.addFold(fold);
                            added = true;
                            break;
                        } else if (startRow == foldLine.end.row) {
                            foldLine.addFold(fold);
                            added = true;
                            if (!fold.sameRow) {
                                var foldLineNext = foldData[i + 1];
                                if (foldLineNext && foldLineNext.start.row == endRow) {
                                    foldLine.merge(foldLineNext);
                                    break;
                                }
                            }
                            break;
                        } else if (endRow <= foldLine.start.row) {
                            break;
                        }
                    }

                    if (!added) foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));

                    if (this.$useWrapMode) this.$updateWrapData(foldLine.start.row, foldLine.start.row);else this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
                    this.$modified = true;
                    this._signal("changeFold", { data: fold, action: "add" });

                    return fold;
                };

                this.addFolds = function (folds) {
                    folds.forEach(function (fold) {
                        this.addFold(fold);
                    }, this);
                };

                this.removeFold = function (fold) {
                    var foldLine = fold.foldLine;
                    var startRow = foldLine.start.row;
                    var endRow = foldLine.end.row;

                    var foldLines = this.$foldData;
                    var folds = foldLine.folds;
                    if (folds.length == 1) {
                        foldLines.splice(foldLines.indexOf(foldLine), 1);
                    } else if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
                        folds.pop();
                        foldLine.end.row = folds[folds.length - 1].end.row;
                        foldLine.end.column = folds[folds.length - 1].end.column;
                    } else if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
                        folds.shift();
                        foldLine.start.row = folds[0].start.row;
                        foldLine.start.column = folds[0].start.column;
                    } else if (fold.sameRow) {
                        folds.splice(folds.indexOf(fold), 1);
                    } else {
                        var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
                        folds = newFoldLine.folds;
                        folds.shift();
                        newFoldLine.start.row = folds[0].start.row;
                        newFoldLine.start.column = folds[0].start.column;
                    }

                    if (!this.$updating) {
                        if (this.$useWrapMode) this.$updateWrapData(startRow, endRow);else this.$updateRowLengthCache(startRow, endRow);
                    }
                    this.$modified = true;
                    this._signal("changeFold", { data: fold, action: "remove" });
                };

                this.removeFolds = function (folds) {
                    var cloneFolds = [];
                    for (var i = 0; i < folds.length; i++) {
                        cloneFolds.push(folds[i]);
                    }

                    cloneFolds.forEach(function (fold) {
                        this.removeFold(fold);
                    }, this);
                    this.$modified = true;
                };

                this.expandFold = function (fold) {
                    this.removeFold(fold);
                    fold.subFolds.forEach(function (subFold) {
                        fold.restoreRange(subFold);
                        this.addFold(subFold);
                    }, this);
                    if (fold.collapseChildren > 0) {
                        this.foldAll(fold.start.row + 1, fold.end.row, fold.collapseChildren - 1);
                    }
                    fold.subFolds = [];
                };

                this.expandFolds = function (folds) {
                    folds.forEach(function (fold) {
                        this.expandFold(fold);
                    }, this);
                };

                this.unfold = function (location, expandInner) {
                    var range, folds;
                    if (location == null) {
                        range = new Range(0, 0, this.getLength(), 0);
                        expandInner = true;
                    } else if (typeof location == "number") range = new Range(location, 0, location, this.getLine(location).length);else if ("row" in location) range = Range.fromPoints(location, location);else range = location;

                    folds = this.getFoldsInRangeList(range);
                    if (expandInner) {
                        this.removeFolds(folds);
                    } else {
                        var subFolds = folds;
                        while (subFolds.length) {
                            this.expandFolds(subFolds);
                            subFolds = this.getFoldsInRangeList(range);
                        }
                    }
                    if (folds.length) return folds;
                };
                this.isRowFolded = function (docRow, startFoldRow) {
                    return !!this.getFoldLine(docRow, startFoldRow);
                };

                this.getRowFoldEnd = function (docRow, startFoldRow) {
                    var foldLine = this.getFoldLine(docRow, startFoldRow);
                    return foldLine ? foldLine.end.row : docRow;
                };

                this.getRowFoldStart = function (docRow, startFoldRow) {
                    var foldLine = this.getFoldLine(docRow, startFoldRow);
                    return foldLine ? foldLine.start.row : docRow;
                };

                this.getFoldDisplayLine = function (foldLine, endRow, endColumn, startRow, startColumn) {
                    if (startRow == null) startRow = foldLine.start.row;
                    if (startColumn == null) startColumn = 0;
                    if (endRow == null) endRow = foldLine.end.row;
                    if (endColumn == null) endColumn = this.getLine(endRow).length;
                    var doc = this.doc;
                    var textLine = "";

                    foldLine.walk(function (placeholder, row, column, lastColumn) {
                        if (row < startRow) return;
                        if (row == startRow) {
                            if (column < startColumn) return;
                            lastColumn = Math.max(startColumn, lastColumn);
                        }

                        if (placeholder != null) {
                            textLine += placeholder;
                        } else {
                            textLine += doc.getLine(row).substring(lastColumn, column);
                        }
                    }, endRow, endColumn);
                    return textLine;
                };

                this.getDisplayLine = function (row, endColumn, startRow, startColumn) {
                    var foldLine = this.getFoldLine(row);

                    if (!foldLine) {
                        var line;
                        line = this.doc.getLine(row);
                        return line.substring(startColumn || 0, endColumn || line.length);
                    } else {
                        return this.getFoldDisplayLine(foldLine, row, endColumn, startRow, startColumn);
                    }
                };

                this.$cloneFoldData = function () {
                    var fd = [];
                    fd = this.$foldData.map(function (foldLine) {
                        var folds = foldLine.folds.map(function (fold) {
                            return fold.clone();
                        });
                        return new FoldLine(fd, folds);
                    });

                    return fd;
                };

                this.toggleFold = function (tryToUnfold) {
                    var selection = this.selection;
                    var range = selection.getRange();
                    var fold;
                    var bracketPos;

                    if (range.isEmpty()) {
                        var cursor = range.start;
                        fold = this.getFoldAt(cursor.row, cursor.column);

                        if (fold) {
                            this.expandFold(fold);
                            return;
                        } else if (bracketPos = this.findMatchingBracket(cursor)) {
                            if (range.comparePoint(bracketPos) == 1) {
                                range.end = bracketPos;
                            } else {
                                range.start = bracketPos;
                                range.start.column++;
                                range.end.column--;
                            }
                        } else if (bracketPos = this.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 })) {
                            if (range.comparePoint(bracketPos) == 1) range.end = bracketPos;else range.start = bracketPos;

                            range.start.column++;
                        } else {
                            range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
                        }
                    } else {
                        var folds = this.getFoldsInRange(range);
                        if (tryToUnfold && folds.length) {
                            this.expandFolds(folds);
                            return;
                        } else if (folds.length == 1) {
                            fold = folds[0];
                        }
                    }

                    if (!fold) fold = this.getFoldAt(range.start.row, range.start.column);

                    if (fold && fold.range.toString() == range.toString()) {
                        this.expandFold(fold);
                        return;
                    }

                    var placeholder = "...";
                    if (!range.isMultiLine()) {
                        placeholder = this.getTextRange(range);
                        if (placeholder.length < 4) return;
                        placeholder = placeholder.trim().substring(0, 2) + "..";
                    }

                    this.addFold(placeholder, range);
                };

                this.getCommentFoldRange = function (row, column, dir) {
                    var iterator = new TokenIterator(this, row, column);
                    var token = iterator.getCurrentToken();
                    if (token && /^comment|string/.test(token.type)) {
                        var range = new Range();
                        var re = new RegExp(token.type.replace(/\..*/, "\\."));
                        if (dir != 1) {
                            do {
                                token = iterator.stepBackward();
                            } while (token && re.test(token.type));
                            iterator.stepForward();
                        }

                        range.start.row = iterator.getCurrentTokenRow();
                        range.start.column = iterator.getCurrentTokenColumn() + 2;

                        iterator = new TokenIterator(this, row, column);

                        if (dir != -1) {
                            do {
                                token = iterator.stepForward();
                            } while (token && re.test(token.type));
                            token = iterator.stepBackward();
                        } else token = iterator.getCurrentToken();

                        range.end.row = iterator.getCurrentTokenRow();
                        range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
                        return range;
                    }
                };

                this.foldAll = function (startRow, endRow, depth) {
                    if (depth == undefined) depth = 100000; // JSON.stringify doesn't hanle Infinity
                    var foldWidgets = this.foldWidgets;
                    if (!foldWidgets) return; // mode doesn't support folding
                    endRow = endRow || this.getLength();
                    startRow = startRow || 0;
                    for (var row = startRow; row < endRow; row++) {
                        if (foldWidgets[row] == null) foldWidgets[row] = this.getFoldWidget(row);
                        if (foldWidgets[row] != "start") continue;

                        var range = this.getFoldWidgetRange(row);
                        if (range && range.isMultiLine() && range.end.row <= endRow && range.start.row >= startRow) {
                            row = range.end.row;
                            try {
                                var fold = this.addFold("...", range);
                                if (fold) fold.collapseChildren = depth;
                            } catch (e) {}
                        }
                    }
                };
                this.$foldStyles = {
                    "manual": 1,
                    "markbegin": 1,
                    "markbeginend": 1
                };
                this.$foldStyle = "markbegin";
                this.setFoldStyle = function (style) {
                    if (!this.$foldStyles[style]) throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");

                    if (this.$foldStyle == style) return;

                    this.$foldStyle = style;

                    if (style == "manual") this.unfold();
                    var mode = this.$foldMode;
                    this.$setFolding(null);
                    this.$setFolding(mode);
                };

                this.$setFolding = function (foldMode) {
                    if (this.$foldMode == foldMode) return;

                    this.$foldMode = foldMode;

                    this.off('change', this.$updateFoldWidgets);
                    this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
                    this._signal("changeAnnotation");

                    if (!foldMode || this.$foldStyle == "manual") {
                        this.foldWidgets = null;
                        return;
                    }

                    this.foldWidgets = [];
                    this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
                    this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);

                    this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
                    this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
                    this.on('change', this.$updateFoldWidgets);
                    this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
                };

                this.getParentFoldRangeData = function (row, ignoreCurrent) {
                    var fw = this.foldWidgets;
                    if (!fw || ignoreCurrent && fw[row]) return {};

                    var i = row - 1,
                        firstRange;
                    while (i >= 0) {
                        var c = fw[i];
                        if (c == null) c = fw[i] = this.getFoldWidget(i);

                        if (c == "start") {
                            var range = this.getFoldWidgetRange(i);
                            if (!firstRange) firstRange = range;
                            if (range && range.end.row >= row) break;
                        }
                        i--;
                    }

                    return {
                        range: i !== -1 && range,
                        firstRange: firstRange
                    };
                };

                this.onFoldWidgetClick = function (row, e) {
                    e = e.domEvent;
                    var options = {
                        children: e.shiftKey,
                        all: e.ctrlKey || e.metaKey,
                        siblings: e.altKey
                    };

                    var range = this.$toggleFoldWidget(row, options);
                    if (!range) {
                        var el = e.target || e.srcElement;
                        if (el && /ace_fold-widget/.test(el.className)) el.className += " ace_invalid";
                    }
                };

                this.$toggleFoldWidget = function (row, options) {
                    if (!this.getFoldWidget) return;
                    var type = this.getFoldWidget(row);
                    var line = this.getLine(row);

                    var dir = type === "end" ? -1 : 1;
                    var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);

                    if (fold) {
                        if (options.children || options.all) this.removeFold(fold);else this.expandFold(fold);
                        return fold;
                    }

                    var range = this.getFoldWidgetRange(row, true);
                    if (range && !range.isMultiLine()) {
                        fold = this.getFoldAt(range.start.row, range.start.column, 1);
                        if (fold && range.isEqual(fold.range)) {
                            this.removeFold(fold);
                            return fold;
                        }
                    }

                    if (options.siblings) {
                        var data = this.getParentFoldRangeData(row);
                        if (data.range) {
                            var startRow = data.range.start.row + 1;
                            var endRow = data.range.end.row;
                        }
                        this.foldAll(startRow, endRow, options.all ? 10000 : 0);
                    } else if (options.children) {
                        endRow = range ? range.end.row : this.getLength();
                        this.foldAll(row + 1, endRow, options.all ? 10000 : 0);
                    } else if (range) {
                        if (options.all) range.collapseChildren = 10000;
                        this.addFold("...", range);
                    }

                    return range;
                };

                this.toggleFoldWidget = function (toggleParent) {
                    var row = this.selection.getCursor().row;
                    row = this.getRowFoldStart(row);
                    var range = this.$toggleFoldWidget(row, {});

                    if (range) return;
                    var data = this.getParentFoldRangeData(row, true);
                    range = data.range || data.firstRange;

                    if (range) {
                        row = range.start.row;
                        var fold = this.getFoldAt(row, this.getLine(row).length, 1);

                        if (fold) {
                            this.removeFold(fold);
                        } else {
                            this.addFold("...", range);
                        }
                    }
                };

                this.updateFoldWidgets = function (delta) {
                    var firstRow = delta.start.row;
                    var len = delta.end.row - firstRow;

                    if (len === 0) {
                        this.foldWidgets[firstRow] = null;
                    } else if (delta.action == 'remove') {
                        this.foldWidgets.splice(firstRow, len + 1, null);
                    } else {
                        var args = Array(len + 1);
                        args.unshift(firstRow, 1);
                        this.foldWidgets.splice.apply(this.foldWidgets, args);
                    }
                };
                this.tokenizerUpdateFoldWidgets = function (e) {
                    var rows = e.data;
                    if (rows.first != rows.last) {
                        if (this.foldWidgets.length > rows.first) this.foldWidgets.splice(rows.first, this.foldWidgets.length);
                    }
                };
            }

            exports.Folding = Folding;
        });

        ace.define("ace/edit_session/bracket_match", ["require", "exports", "module", "ace/token_iterator", "ace/range"], function (require, exports, module) {
            "use strict";

            var TokenIterator = require("../token_iterator").TokenIterator;
            var Range = require("../range").Range;

            function BracketMatch() {

                this.findMatchingBracket = function (position, chr) {
                    if (position.column == 0) return null;

                    var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column - 1);
                    if (charBeforeCursor == "") return null;

                    var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
                    if (!match) return null;

                    if (match[1]) return this.$findClosingBracket(match[1], position);else return this.$findOpeningBracket(match[2], position);
                };

                this.getBracketRange = function (pos) {
                    var line = this.getLine(pos.row);
                    var before = true,
                        range;

                    var chr = line.charAt(pos.column - 1);
                    var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
                    if (!match) {
                        chr = line.charAt(pos.column);
                        pos = { row: pos.row, column: pos.column + 1 };
                        match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
                        before = false;
                    }
                    if (!match) return null;

                    if (match[1]) {
                        var bracketPos = this.$findClosingBracket(match[1], pos);
                        if (!bracketPos) return null;
                        range = Range.fromPoints(pos, bracketPos);
                        if (!before) {
                            range.end.column++;
                            range.start.column--;
                        }
                        range.cursor = range.end;
                    } else {
                        var bracketPos = this.$findOpeningBracket(match[2], pos);
                        if (!bracketPos) return null;
                        range = Range.fromPoints(bracketPos, pos);
                        if (!before) {
                            range.start.column++;
                            range.end.column--;
                        }
                        range.cursor = range.start;
                    }

                    return range;
                };

                this.$brackets = {
                    ")": "(",
                    "(": ")",
                    "]": "[",
                    "[": "]",
                    "{": "}",
                    "}": "{"
                };

                this.$findOpeningBracket = function (bracket, position, typeRe) {
                    var openBracket = this.$brackets[bracket];
                    var depth = 1;

                    var iterator = new TokenIterator(this, position.row, position.column);
                    var token = iterator.getCurrentToken();
                    if (!token) token = iterator.stepForward();
                    if (!token) return;

                    if (!typeRe) {
                        typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("rparen", ".paren").replace(/\b(?:end)\b/, "(?:start|begin|end)") + ")+");
                    }
                    var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
                    var value = token.value;

                    while (true) {

                        while (valueIndex >= 0) {
                            var chr = value.charAt(valueIndex);
                            if (chr == openBracket) {
                                depth -= 1;
                                if (depth == 0) {
                                    return { row: iterator.getCurrentTokenRow(),
                                        column: valueIndex + iterator.getCurrentTokenColumn() };
                                }
                            } else if (chr == bracket) {
                                depth += 1;
                            }
                            valueIndex -= 1;
                        }
                        do {
                            token = iterator.stepBackward();
                        } while (token && !typeRe.test(token.type));

                        if (token == null) break;

                        value = token.value;
                        valueIndex = value.length - 1;
                    }

                    return null;
                };

                this.$findClosingBracket = function (bracket, position, typeRe) {
                    var closingBracket = this.$brackets[bracket];
                    var depth = 1;

                    var iterator = new TokenIterator(this, position.row, position.column);
                    var token = iterator.getCurrentToken();
                    if (!token) token = iterator.stepForward();
                    if (!token) return;

                    if (!typeRe) {
                        typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("lparen", ".paren").replace(/\b(?:start|begin)\b/, "(?:start|begin|end)") + ")+");
                    }
                    var valueIndex = position.column - iterator.getCurrentTokenColumn();

                    while (true) {

                        var value = token.value;
                        var valueLength = value.length;
                        while (valueIndex < valueLength) {
                            var chr = value.charAt(valueIndex);
                            if (chr == closingBracket) {
                                depth -= 1;
                                if (depth == 0) {
                                    return { row: iterator.getCurrentTokenRow(),
                                        column: valueIndex + iterator.getCurrentTokenColumn() };
                                }
                            } else if (chr == bracket) {
                                depth += 1;
                            }
                            valueIndex += 1;
                        }
                        do {
                            token = iterator.stepForward();
                        } while (token && !typeRe.test(token.type));

                        if (token == null) break;

                        valueIndex = 0;
                    }

                    return null;
                };
            }
            exports.BracketMatch = BracketMatch;
        });

        ace.define("ace/edit_session", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/config", "ace/lib/event_emitter", "ace/selection", "ace/mode/text", "ace/range", "ace/document", "ace/background_tokenizer", "ace/search_highlight", "ace/edit_session/folding", "ace/edit_session/bracket_match"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var lang = require("./lib/lang");
            var config = require("./config");
            var EventEmitter = require("./lib/event_emitter").EventEmitter;
            var Selection = require("./selection").Selection;
            var TextMode = require("./mode/text").Mode;
            var Range = require("./range").Range;
            var Document = require("./document").Document;
            var BackgroundTokenizer = require("./background_tokenizer").BackgroundTokenizer;
            var SearchHighlight = require("./search_highlight").SearchHighlight;

            var EditSession = function (text, mode) {
                this.$breakpoints = [];
                this.$decorations = [];
                this.$frontMarkers = {};
                this.$backMarkers = {};
                this.$markerId = 1;
                this.$undoSelect = true;

                this.$foldData = [];
                this.id = "session" + ++EditSession.$uid;
                this.$foldData.toString = function () {
                    return this.join("\n");
                };
                this.on("changeFold", this.onChangeFold.bind(this));
                this.$onChange = this.onChange.bind(this);

                if (typeof text != "object" || !text.getLine) text = new Document(text);

                this.setDocument(text);
                this.selection = new Selection(this);

                config.resetOptions(this);
                this.setMode(mode);
                config._signal("session", this);
            };

            (function () {

                oop.implement(this, EventEmitter);
                this.setDocument = function (doc) {
                    if (this.doc) this.doc.removeListener("change", this.$onChange);

                    this.doc = doc;
                    doc.on("change", this.$onChange);

                    if (this.bgTokenizer) this.bgTokenizer.setDocument(this.getDocument());

                    this.resetCaches();
                };
                this.getDocument = function () {
                    return this.doc;
                };
                this.$resetRowCache = function (docRow) {
                    if (!docRow) {
                        this.$docRowCache = [];
                        this.$screenRowCache = [];
                        return;
                    }
                    var l = this.$docRowCache.length;
                    var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
                    if (l > i) {
                        this.$docRowCache.splice(i, l);
                        this.$screenRowCache.splice(i, l);
                    }
                };

                this.$getRowCacheIndex = function (cacheArray, val) {
                    var low = 0;
                    var hi = cacheArray.length - 1;

                    while (low <= hi) {
                        var mid = low + hi >> 1;
                        var c = cacheArray[mid];

                        if (val > c) low = mid + 1;else if (val < c) hi = mid - 1;else return mid;
                    }

                    return low - 1;
                };

                this.resetCaches = function () {
                    this.$modified = true;
                    this.$wrapData = [];
                    this.$rowLengthCache = [];
                    this.$resetRowCache(0);
                    if (this.bgTokenizer) this.bgTokenizer.start(0);
                };

                this.onChangeFold = function (e) {
                    var fold = e.data;
                    this.$resetRowCache(fold.start.row);
                };

                this.onChange = function (delta) {
                    this.$modified = true;

                    this.$resetRowCache(delta.start.row);

                    var removedFolds = this.$updateInternalDataOnChange(delta);
                    if (!this.$fromUndo && this.$undoManager && !delta.ignore) {
                        this.$deltasDoc.push(delta);
                        if (removedFolds && removedFolds.length != 0) {
                            this.$deltasFold.push({
                                action: "removeFolds",
                                folds: removedFolds
                            });
                        }

                        this.$informUndoManager.schedule();
                    }

                    this.bgTokenizer && this.bgTokenizer.$updateOnChange(delta);
                    this._signal("change", delta);
                };
                this.setValue = function (text) {
                    this.doc.setValue(text);
                    this.selection.moveTo(0, 0);

                    this.$resetRowCache(0);
                    this.$deltas = [];
                    this.$deltasDoc = [];
                    this.$deltasFold = [];
                    this.setUndoManager(this.$undoManager);
                    this.getUndoManager().reset();
                };
                this.getValue = this.toString = function () {
                    return this.doc.getValue();
                };
                this.getSelection = function () {
                    return this.selection;
                };
                this.getState = function (row) {
                    return this.bgTokenizer.getState(row);
                };
                this.getTokens = function (row) {
                    return this.bgTokenizer.getTokens(row);
                };
                this.getTokenAt = function (row, column) {
                    var tokens = this.bgTokenizer.getTokens(row);
                    var token,
                        c = 0;
                    if (column == null) {
                        i = tokens.length - 1;
                        c = this.getLine(row).length;
                    } else {
                        for (var i = 0; i < tokens.length; i++) {
                            c += tokens[i].value.length;
                            if (c >= column) break;
                        }
                    }
                    token = tokens[i];
                    if (!token) return null;
                    token.index = i;
                    token.start = c - token.value.length;
                    return token;
                };
                this.setUndoManager = function (undoManager) {
                    this.$undoManager = undoManager;
                    this.$deltas = [];
                    this.$deltasDoc = [];
                    this.$deltasFold = [];

                    if (this.$informUndoManager) this.$informUndoManager.cancel();

                    if (undoManager) {
                        var self = this;

                        this.$syncInformUndoManager = function () {
                            self.$informUndoManager.cancel();

                            if (self.$deltasFold.length) {
                                self.$deltas.push({
                                    group: "fold",
                                    deltas: self.$deltasFold
                                });
                                self.$deltasFold = [];
                            }

                            if (self.$deltasDoc.length) {
                                self.$deltas.push({
                                    group: "doc",
                                    deltas: self.$deltasDoc
                                });
                                self.$deltasDoc = [];
                            }

                            if (self.$deltas.length > 0) {
                                undoManager.execute({
                                    action: "aceupdate",
                                    args: [self.$deltas, self],
                                    merge: self.mergeUndoDeltas
                                });
                            }
                            self.mergeUndoDeltas = false;
                            self.$deltas = [];
                        };
                        this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
                    }
                };
                this.markUndoGroup = function () {
                    if (this.$syncInformUndoManager) this.$syncInformUndoManager();
                };

                this.$defaultUndoManager = {
                    undo: function () {},
                    redo: function () {},
                    reset: function () {}
                };
                this.getUndoManager = function () {
                    return this.$undoManager || this.$defaultUndoManager;
                };
                this.getTabString = function () {
                    if (this.getUseSoftTabs()) {
                        return lang.stringRepeat(" ", this.getTabSize());
                    } else {
                        return "\t";
                    }
                };
                this.setUseSoftTabs = function (val) {
                    this.setOption("useSoftTabs", val);
                };
                this.getUseSoftTabs = function () {
                    return this.$useSoftTabs && !this.$mode.$indentWithTabs;
                };
                this.setTabSize = function (tabSize) {
                    this.setOption("tabSize", tabSize);
                };
                this.getTabSize = function () {
                    return this.$tabSize;
                };
                this.isTabStop = function (position) {
                    return this.$useSoftTabs && position.column % this.$tabSize === 0;
                };

                this.$overwrite = false;
                this.setOverwrite = function (overwrite) {
                    this.setOption("overwrite", overwrite);
                };
                this.getOverwrite = function () {
                    return this.$overwrite;
                };
                this.toggleOverwrite = function () {
                    this.setOverwrite(!this.$overwrite);
                };
                this.addGutterDecoration = function (row, className) {
                    if (!this.$decorations[row]) this.$decorations[row] = "";
                    this.$decorations[row] += " " + className;
                    this._signal("changeBreakpoint", {});
                };
                this.removeGutterDecoration = function (row, className) {
                    this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
                    this._signal("changeBreakpoint", {});
                };
                this.getBreakpoints = function () {
                    return this.$breakpoints;
                };
                this.setBreakpoints = function (rows) {
                    this.$breakpoints = [];
                    for (var i = 0; i < rows.length; i++) {
                        this.$breakpoints[rows[i]] = "ace_breakpoint";
                    }
                    this._signal("changeBreakpoint", {});
                };
                this.clearBreakpoints = function () {
                    this.$breakpoints = [];
                    this._signal("changeBreakpoint", {});
                };
                this.setBreakpoint = function (row, className) {
                    if (className === undefined) className = "ace_breakpoint";
                    if (className) this.$breakpoints[row] = className;else delete this.$breakpoints[row];
                    this._signal("changeBreakpoint", {});
                };
                this.clearBreakpoint = function (row) {
                    delete this.$breakpoints[row];
                    this._signal("changeBreakpoint", {});
                };
                this.addMarker = function (range, clazz, type, inFront) {
                    var id = this.$markerId++;

                    var marker = {
                        range: range,
                        type: type || "line",
                        renderer: typeof type == "function" ? type : null,
                        clazz: clazz,
                        inFront: !!inFront,
                        id: id
                    };

                    if (inFront) {
                        this.$frontMarkers[id] = marker;
                        this._signal("changeFrontMarker");
                    } else {
                        this.$backMarkers[id] = marker;
                        this._signal("changeBackMarker");
                    }

                    return id;
                };
                this.addDynamicMarker = function (marker, inFront) {
                    if (!marker.update) return;
                    var id = this.$markerId++;
                    marker.id = id;
                    marker.inFront = !!inFront;

                    if (inFront) {
                        this.$frontMarkers[id] = marker;
                        this._signal("changeFrontMarker");
                    } else {
                        this.$backMarkers[id] = marker;
                        this._signal("changeBackMarker");
                    }

                    return marker;
                };
                this.removeMarker = function (markerId) {
                    var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
                    if (!marker) return;

                    var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
                    if (marker) {
                        delete markers[markerId];
                        this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
                    }
                };
                this.getMarkers = function (inFront) {
                    return inFront ? this.$frontMarkers : this.$backMarkers;
                };

                this.highlight = function (re) {
                    if (!this.$searchHighlight) {
                        var highlight = new SearchHighlight(null, "ace_selected-word", "text");
                        this.$searchHighlight = this.addDynamicMarker(highlight);
                    }
                    this.$searchHighlight.setRegexp(re);
                };
                this.highlightLines = function (startRow, endRow, clazz, inFront) {
                    if (typeof endRow != "number") {
                        clazz = endRow;
                        endRow = startRow;
                    }
                    if (!clazz) clazz = "ace_step";

                    var range = new Range(startRow, 0, endRow, Infinity);
                    range.id = this.addMarker(range, clazz, "fullLine", inFront);
                    return range;
                };
                this.setAnnotations = function (annotations) {
                    this.$annotations = annotations;
                    this._signal("changeAnnotation", {});
                };
                this.getAnnotations = function () {
                    return this.$annotations || [];
                };
                this.clearAnnotations = function () {
                    this.setAnnotations([]);
                };
                this.$detectNewLine = function (text) {
                    var match = text.match(/^.*?(\r?\n)/m);
                    if (match) {
                        this.$autoNewLine = match[1];
                    } else {
                        this.$autoNewLine = "\n";
                    }
                };
                this.getWordRange = function (row, column) {
                    var line = this.getLine(row);

                    var inToken = false;
                    if (column > 0) inToken = !!line.charAt(column - 1).match(this.tokenRe);

                    if (!inToken) inToken = !!line.charAt(column).match(this.tokenRe);

                    if (inToken) var re = this.tokenRe;else if (/^\s+$/.test(line.slice(column - 1, column + 1))) var re = /\s/;else var re = this.nonTokenRe;

                    var start = column;
                    if (start > 0) {
                        do {
                            start--;
                        } while (start >= 0 && line.charAt(start).match(re));
                        start++;
                    }

                    var end = column;
                    while (end < line.length && line.charAt(end).match(re)) {
                        end++;
                    }

                    return new Range(row, start, row, end);
                };
                this.getAWordRange = function (row, column) {
                    var wordRange = this.getWordRange(row, column);
                    var line = this.getLine(wordRange.end.row);

                    while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
                        wordRange.end.column += 1;
                    }
                    return wordRange;
                };
                this.setNewLineMode = function (newLineMode) {
                    this.doc.setNewLineMode(newLineMode);
                };
                this.getNewLineMode = function () {
                    return this.doc.getNewLineMode();
                };
                this.setUseWorker = function (useWorker) {
                    this.setOption("useWorker", useWorker);
                };
                this.getUseWorker = function () {
                    return this.$useWorker;
                };
                this.onReloadTokenizer = function (e) {
                    var rows = e.data;
                    this.bgTokenizer.start(rows.first);
                    this._signal("tokenizerUpdate", e);
                };

                this.$modes = {};
                this.$mode = null;
                this.$modeId = null;
                this.setMode = function (mode, cb) {
                    if (mode && typeof mode === "object") {
                        if (mode.getTokenizer) return this.$onChangeMode(mode);
                        var options = mode;
                        var path = options.path;
                    } else {
                        path = mode || "ace/mode/text";
                    }
                    if (!this.$modes["ace/mode/text"]) this.$modes["ace/mode/text"] = new TextMode();

                    if (this.$modes[path] && !options) {
                        this.$onChangeMode(this.$modes[path]);
                        cb && cb();
                        return;
                    }
                    this.$modeId = path;
                    config.loadModule(["mode", path], function (m) {
                        if (this.$modeId !== path) return cb && cb();
                        if (this.$modes[path] && !options) {
                            this.$onChangeMode(this.$modes[path]);
                        } else if (m && m.Mode) {
                            m = new m.Mode(options);
                            if (!options) {
                                this.$modes[path] = m;
                                m.$id = path;
                            }
                            this.$onChangeMode(m);
                        }
                        cb && cb();
                    }.bind(this));
                    if (!this.$mode) this.$onChangeMode(this.$modes["ace/mode/text"], true);
                };

                this.$onChangeMode = function (mode, $isPlaceholder) {
                    if (!$isPlaceholder) this.$modeId = mode.$id;
                    if (this.$mode === mode) return;

                    this.$mode = mode;

                    this.$stopWorker();

                    if (this.$useWorker) this.$startWorker();

                    var tokenizer = mode.getTokenizer();

                    if (tokenizer.addEventListener !== undefined) {
                        var onReloadTokenizer = this.onReloadTokenizer.bind(this);
                        tokenizer.addEventListener("update", onReloadTokenizer);
                    }

                    if (!this.bgTokenizer) {
                        this.bgTokenizer = new BackgroundTokenizer(tokenizer);
                        var _self = this;
                        this.bgTokenizer.addEventListener("update", function (e) {
                            _self._signal("tokenizerUpdate", e);
                        });
                    } else {
                        this.bgTokenizer.setTokenizer(tokenizer);
                    }

                    this.bgTokenizer.setDocument(this.getDocument());

                    this.tokenRe = mode.tokenRe;
                    this.nonTokenRe = mode.nonTokenRe;

                    if (!$isPlaceholder) {
                        if (mode.attachToSession) mode.attachToSession(this);
                        this.$options.wrapMethod.set.call(this, this.$wrapMethod);
                        this.$setFolding(mode.foldingRules);
                        this.bgTokenizer.start(0);
                        this._emit("changeMode");
                    }
                };

                this.$stopWorker = function () {
                    if (this.$worker) {
                        this.$worker.terminate();
                        this.$worker = null;
                    }
                };

                this.$startWorker = function () {
                    try {
                        this.$worker = this.$mode.createWorker(this);
                    } catch (e) {
                        config.warn("Could not load worker", e);
                        this.$worker = null;
                    }
                };
                this.getMode = function () {
                    return this.$mode;
                };

                this.$scrollTop = 0;
                this.setScrollTop = function (scrollTop) {
                    if (this.$scrollTop === scrollTop || isNaN(scrollTop)) return;

                    this.$scrollTop = scrollTop;
                    this._signal("changeScrollTop", scrollTop);
                };
                this.getScrollTop = function () {
                    return this.$scrollTop;
                };

                this.$scrollLeft = 0;
                this.setScrollLeft = function (scrollLeft) {
                    if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft)) return;

                    this.$scrollLeft = scrollLeft;
                    this._signal("changeScrollLeft", scrollLeft);
                };
                this.getScrollLeft = function () {
                    return this.$scrollLeft;
                };
                this.getScreenWidth = function () {
                    this.$computeWidth();
                    if (this.lineWidgets) return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
                    return this.screenWidth;
                };

                this.getLineWidgetMaxWidth = function () {
                    if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;
                    var width = 0;
                    this.lineWidgets.forEach(function (w) {
                        if (w && w.screenWidth > width) width = w.screenWidth;
                    });
                    return this.lineWidgetWidth = width;
                };

                this.$computeWidth = function (force) {
                    if (this.$modified || force) {
                        this.$modified = false;

                        if (this.$useWrapMode) return this.screenWidth = this.$wrapLimit;

                        var lines = this.doc.getAllLines();
                        var cache = this.$rowLengthCache;
                        var longestScreenLine = 0;
                        var foldIndex = 0;
                        var foldLine = this.$foldData[foldIndex];
                        var foldStart = foldLine ? foldLine.start.row : Infinity;
                        var len = lines.length;

                        for (var i = 0; i < len; i++) {
                            if (i > foldStart) {
                                i = foldLine.end.row + 1;
                                if (i >= len) break;
                                foldLine = this.$foldData[foldIndex++];
                                foldStart = foldLine ? foldLine.start.row : Infinity;
                            }

                            if (cache[i] == null) cache[i] = this.$getStringScreenWidth(lines[i])[0];

                            if (cache[i] > longestScreenLine) longestScreenLine = cache[i];
                        }
                        this.screenWidth = longestScreenLine;
                    }
                };
                this.getLine = function (row) {
                    return this.doc.getLine(row);
                };
                this.getLines = function (firstRow, lastRow) {
                    return this.doc.getLines(firstRow, lastRow);
                };
                this.getLength = function () {
                    return this.doc.getLength();
                };
                this.getTextRange = function (range) {
                    return this.doc.getTextRange(range || this.selection.getRange());
                };
                this.insert = function (position, text) {
                    return this.doc.insert(position, text);
                };
                this.remove = function (range) {
                    return this.doc.remove(range);
                };
                this.removeFullLines = function (firstRow, lastRow) {
                    return this.doc.removeFullLines(firstRow, lastRow);
                };
                this.undoChanges = function (deltas, dontSelect) {
                    if (!deltas.length) return;

                    this.$fromUndo = true;
                    var lastUndoRange = null;
                    for (var i = deltas.length - 1; i != -1; i--) {
                        var delta = deltas[i];
                        if (delta.group == "doc") {
                            this.doc.revertDeltas(delta.deltas);
                            lastUndoRange = this.$getUndoSelection(delta.deltas, true, lastUndoRange);
                        } else {
                            delta.deltas.forEach(function (foldDelta) {
                                this.addFolds(foldDelta.folds);
                            }, this);
                        }
                    }
                    this.$fromUndo = false;
                    lastUndoRange && this.$undoSelect && !dontSelect && this.selection.setSelectionRange(lastUndoRange);
                    return lastUndoRange;
                };
                this.redoChanges = function (deltas, dontSelect) {
                    if (!deltas.length) return;

                    this.$fromUndo = true;
                    var lastUndoRange = null;
                    for (var i = 0; i < deltas.length; i++) {
                        var delta = deltas[i];
                        if (delta.group == "doc") {
                            this.doc.applyDeltas(delta.deltas);
                            lastUndoRange = this.$getUndoSelection(delta.deltas, false, lastUndoRange);
                        }
                    }
                    this.$fromUndo = false;
                    lastUndoRange && this.$undoSelect && !dontSelect && this.selection.setSelectionRange(lastUndoRange);
                    return lastUndoRange;
                };
                this.setUndoSelect = function (enable) {
                    this.$undoSelect = enable;
                };

                this.$getUndoSelection = function (deltas, isUndo, lastUndoRange) {
                    function isInsert(delta) {
                        return isUndo ? delta.action !== "insert" : delta.action === "insert";
                    }

                    var delta = deltas[0];
                    var range, point;
                    var lastDeltaIsInsert = false;
                    if (isInsert(delta)) {
                        range = Range.fromPoints(delta.start, delta.end);
                        lastDeltaIsInsert = true;
                    } else {
                        range = Range.fromPoints(delta.start, delta.start);
                        lastDeltaIsInsert = false;
                    }

                    for (var i = 1; i < deltas.length; i++) {
                        delta = deltas[i];
                        if (isInsert(delta)) {
                            point = delta.start;
                            if (range.compare(point.row, point.column) == -1) {
                                range.setStart(point);
                            }
                            point = delta.end;
                            if (range.compare(point.row, point.column) == 1) {
                                range.setEnd(point);
                            }
                            lastDeltaIsInsert = true;
                        } else {
                            point = delta.start;
                            if (range.compare(point.row, point.column) == -1) {
                                range = Range.fromPoints(delta.start, delta.start);
                            }
                            lastDeltaIsInsert = false;
                        }
                    }
                    if (lastUndoRange != null) {
                        if (Range.comparePoints(lastUndoRange.start, range.start) === 0) {
                            lastUndoRange.start.column += range.end.column - range.start.column;
                            lastUndoRange.end.column += range.end.column - range.start.column;
                        }

                        var cmp = lastUndoRange.compareRange(range);
                        if (cmp == 1) {
                            range.setStart(lastUndoRange.start);
                        } else if (cmp == -1) {
                            range.setEnd(lastUndoRange.end);
                        }
                    }

                    return range;
                };
                this.replace = function (range, text) {
                    return this.doc.replace(range, text);
                };
                this.moveText = function (fromRange, toPosition, copy) {
                    var text = this.getTextRange(fromRange);
                    var folds = this.getFoldsInRange(fromRange);

                    var toRange = Range.fromPoints(toPosition, toPosition);
                    if (!copy) {
                        this.remove(fromRange);
                        var rowDiff = fromRange.start.row - fromRange.end.row;
                        var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
                        if (collDiff) {
                            if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column) toRange.start.column += collDiff;
                            if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column) toRange.end.column += collDiff;
                        }
                        if (rowDiff && toRange.start.row >= fromRange.end.row) {
                            toRange.start.row += rowDiff;
                            toRange.end.row += rowDiff;
                        }
                    }

                    toRange.end = this.insert(toRange.start, text);
                    if (folds.length) {
                        var oldStart = fromRange.start;
                        var newStart = toRange.start;
                        var rowDiff = newStart.row - oldStart.row;
                        var collDiff = newStart.column - oldStart.column;
                        this.addFolds(folds.map(function (x) {
                            x = x.clone();
                            if (x.start.row == oldStart.row) x.start.column += collDiff;
                            if (x.end.row == oldStart.row) x.end.column += collDiff;
                            x.start.row += rowDiff;
                            x.end.row += rowDiff;
                            return x;
                        }));
                    }

                    return toRange;
                };
                this.indentRows = function (startRow, endRow, indentString) {
                    indentString = indentString.replace(/\t/g, this.getTabString());
                    for (var row = startRow; row <= endRow; row++) this.doc.insertInLine({ row: row, column: 0 }, indentString);
                };
                this.outdentRows = function (range) {
                    var rowRange = range.collapseRows();
                    var deleteRange = new Range(0, 0, 0, 0);
                    var size = this.getTabSize();

                    for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
                        var line = this.getLine(i);

                        deleteRange.start.row = i;
                        deleteRange.end.row = i;
                        for (var j = 0; j < size; ++j) if (line.charAt(j) != ' ') break;
                        if (j < size && line.charAt(j) == '\t') {
                            deleteRange.start.column = j;
                            deleteRange.end.column = j + 1;
                        } else {
                            deleteRange.start.column = 0;
                            deleteRange.end.column = j;
                        }
                        this.remove(deleteRange);
                    }
                };

                this.$moveLines = function (firstRow, lastRow, dir) {
                    firstRow = this.getRowFoldStart(firstRow);
                    lastRow = this.getRowFoldEnd(lastRow);
                    if (dir < 0) {
                        var row = this.getRowFoldStart(firstRow + dir);
                        if (row < 0) return 0;
                        var diff = row - firstRow;
                    } else if (dir > 0) {
                        var row = this.getRowFoldEnd(lastRow + dir);
                        if (row > this.doc.getLength() - 1) return 0;
                        var diff = row - lastRow;
                    } else {
                        firstRow = this.$clipRowToDocument(firstRow);
                        lastRow = this.$clipRowToDocument(lastRow);
                        var diff = lastRow - firstRow + 1;
                    }

                    var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
                    var folds = this.getFoldsInRange(range).map(function (x) {
                        x = x.clone();
                        x.start.row += diff;
                        x.end.row += diff;
                        return x;
                    });

                    var lines = dir == 0 ? this.doc.getLines(firstRow, lastRow) : this.doc.removeFullLines(firstRow, lastRow);
                    this.doc.insertFullLines(firstRow + diff, lines);
                    folds.length && this.addFolds(folds);
                    return diff;
                };
                this.moveLinesUp = function (firstRow, lastRow) {
                    return this.$moveLines(firstRow, lastRow, -1);
                };
                this.moveLinesDown = function (firstRow, lastRow) {
                    return this.$moveLines(firstRow, lastRow, 1);
                };
                this.duplicateLines = function (firstRow, lastRow) {
                    return this.$moveLines(firstRow, lastRow, 0);
                };

                this.$clipRowToDocument = function (row) {
                    return Math.max(0, Math.min(row, this.doc.getLength() - 1));
                };

                this.$clipColumnToRow = function (row, column) {
                    if (column < 0) return 0;
                    return Math.min(this.doc.getLine(row).length, column);
                };

                this.$clipPositionToDocument = function (row, column) {
                    column = Math.max(0, column);

                    if (row < 0) {
                        row = 0;
                        column = 0;
                    } else {
                        var len = this.doc.getLength();
                        if (row >= len) {
                            row = len - 1;
                            column = this.doc.getLine(len - 1).length;
                        } else {
                            column = Math.min(this.doc.getLine(row).length, column);
                        }
                    }

                    return {
                        row: row,
                        column: column
                    };
                };

                this.$clipRangeToDocument = function (range) {
                    if (range.start.row < 0) {
                        range.start.row = 0;
                        range.start.column = 0;
                    } else {
                        range.start.column = this.$clipColumnToRow(range.start.row, range.start.column);
                    }

                    var len = this.doc.getLength() - 1;
                    if (range.end.row > len) {
                        range.end.row = len;
                        range.end.column = this.doc.getLine(len).length;
                    } else {
                        range.end.column = this.$clipColumnToRow(range.end.row, range.end.column);
                    }
                    return range;
                };
                this.$wrapLimit = 80;
                this.$useWrapMode = false;
                this.$wrapLimitRange = {
                    min: null,
                    max: null
                };
                this.setUseWrapMode = function (useWrapMode) {
                    if (useWrapMode != this.$useWrapMode) {
                        this.$useWrapMode = useWrapMode;
                        this.$modified = true;
                        this.$resetRowCache(0);
                        if (useWrapMode) {
                            var len = this.getLength();
                            this.$wrapData = Array(len);
                            this.$updateWrapData(0, len - 1);
                        }

                        this._signal("changeWrapMode");
                    }
                };
                this.getUseWrapMode = function () {
                    return this.$useWrapMode;
                };
                this.setWrapLimitRange = function (min, max) {
                    if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
                        this.$wrapLimitRange = { min: min, max: max };
                        this.$modified = true;
                        if (this.$useWrapMode) this._signal("changeWrapMode");
                    }
                };
                this.adjustWrapLimit = function (desiredLimit, $printMargin) {
                    var limits = this.$wrapLimitRange;
                    if (limits.max < 0) limits = { min: $printMargin, max: $printMargin };
                    var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
                    if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
                        this.$wrapLimit = wrapLimit;
                        this.$modified = true;
                        if (this.$useWrapMode) {
                            this.$updateWrapData(0, this.getLength() - 1);
                            this.$resetRowCache(0);
                            this._signal("changeWrapLimit");
                        }
                        return true;
                    }
                    return false;
                };

                this.$constrainWrapLimit = function (wrapLimit, min, max) {
                    if (min) wrapLimit = Math.max(min, wrapLimit);

                    if (max) wrapLimit = Math.min(max, wrapLimit);

                    return wrapLimit;
                };
                this.getWrapLimit = function () {
                    return this.$wrapLimit;
                };
                this.setWrapLimit = function (limit) {
                    this.setWrapLimitRange(limit, limit);
                };
                this.getWrapLimitRange = function () {
                    return {
                        min: this.$wrapLimitRange.min,
                        max: this.$wrapLimitRange.max
                    };
                };

                this.$updateInternalDataOnChange = function (delta) {
                    var useWrapMode = this.$useWrapMode;
                    var action = delta.action;
                    var start = delta.start;
                    var end = delta.end;
                    var firstRow = start.row;
                    var lastRow = end.row;
                    var len = lastRow - firstRow;
                    var removedFolds = null;

                    this.$updating = true;
                    if (len != 0) {
                        if (action === "remove") {
                            this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);

                            var foldLines = this.$foldData;
                            removedFolds = this.getFoldsInRange(delta);
                            this.removeFolds(removedFolds);

                            var foldLine = this.getFoldLine(end.row);
                            var idx = 0;
                            if (foldLine) {
                                foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                                foldLine.shiftRow(-len);

                                var foldLineBefore = this.getFoldLine(firstRow);
                                if (foldLineBefore && foldLineBefore !== foldLine) {
                                    foldLineBefore.merge(foldLine);
                                    foldLine = foldLineBefore;
                                }
                                idx = foldLines.indexOf(foldLine) + 1;
                            }

                            for (idx; idx < foldLines.length; idx++) {
                                var foldLine = foldLines[idx];
                                if (foldLine.start.row >= end.row) {
                                    foldLine.shiftRow(-len);
                                }
                            }

                            lastRow = firstRow;
                        } else {
                            var args = Array(len);
                            args.unshift(firstRow, 0);
                            var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
                            arr.splice.apply(arr, args);
                            var foldLines = this.$foldData;
                            var foldLine = this.getFoldLine(firstRow);
                            var idx = 0;
                            if (foldLine) {
                                var cmp = foldLine.range.compareInside(start.row, start.column);
                                if (cmp == 0) {
                                    foldLine = foldLine.split(start.row, start.column);
                                    if (foldLine) {
                                        foldLine.shiftRow(len);
                                        foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                                    }
                                } else if (cmp == -1) {
                                    foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                                    foldLine.shiftRow(len);
                                }
                                idx = foldLines.indexOf(foldLine) + 1;
                            }

                            for (idx; idx < foldLines.length; idx++) {
                                var foldLine = foldLines[idx];
                                if (foldLine.start.row >= firstRow) {
                                    foldLine.shiftRow(len);
                                }
                            }
                        }
                    } else {
                        len = Math.abs(delta.start.column - delta.end.column);
                        if (action === "remove") {
                            removedFolds = this.getFoldsInRange(delta);
                            this.removeFolds(removedFolds);

                            len = -len;
                        }
                        var foldLine = this.getFoldLine(firstRow);
                        if (foldLine) {
                            foldLine.addRemoveChars(firstRow, start.column, len);
                        }
                    }

                    if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
                        console.error("doc.getLength() and $wrapData.length have to be the same!");
                    }
                    this.$updating = false;

                    if (useWrapMode) this.$updateWrapData(firstRow, lastRow);else this.$updateRowLengthCache(firstRow, lastRow);

                    return removedFolds;
                };

                this.$updateRowLengthCache = function (firstRow, lastRow, b) {
                    this.$rowLengthCache[firstRow] = null;
                    this.$rowLengthCache[lastRow] = null;
                };

                this.$updateWrapData = function (firstRow, lastRow) {
                    var lines = this.doc.getAllLines();
                    var tabSize = this.getTabSize();
                    var wrapData = this.$wrapData;
                    var wrapLimit = this.$wrapLimit;
                    var tokens;
                    var foldLine;

                    var row = firstRow;
                    lastRow = Math.min(lastRow, lines.length - 1);
                    while (row <= lastRow) {
                        foldLine = this.getFoldLine(row, foldLine);
                        if (!foldLine) {
                            tokens = this.$getDisplayTokens(lines[row]);
                            wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                            row++;
                        } else {
                            tokens = [];
                            foldLine.walk(function (placeholder, row, column, lastColumn) {
                                var walkTokens;
                                if (placeholder != null) {
                                    walkTokens = this.$getDisplayTokens(placeholder, tokens.length);
                                    walkTokens[0] = PLACEHOLDER_START;
                                    for (var i = 1; i < walkTokens.length; i++) {
                                        walkTokens[i] = PLACEHOLDER_BODY;
                                    }
                                } else {
                                    walkTokens = this.$getDisplayTokens(lines[row].substring(lastColumn, column), tokens.length);
                                }
                                tokens = tokens.concat(walkTokens);
                            }.bind(this), foldLine.end.row, lines[foldLine.end.row].length + 1);

                            wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                            row = foldLine.end.row + 1;
                        }
                    }
                };
                var CHAR = 1,
                    CHAR_EXT = 2,
                    PLACEHOLDER_START = 3,
                    PLACEHOLDER_BODY = 4,
                    PUNCTUATION = 9,
                    SPACE = 10,
                    TAB = 11,
                    TAB_SPACE = 12;

                this.$computeWrapSplits = function (tokens, wrapLimit, tabSize) {
                    if (tokens.length == 0) {
                        return [];
                    }

                    var splits = [];
                    var displayLength = tokens.length;
                    var lastSplit = 0,
                        lastDocSplit = 0;

                    var isCode = this.$wrapAsCode;

                    var indentedSoftWrap = this.$indentedSoftWrap;
                    var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8) || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);

                    function getWrapIndent() {
                        var indentation = 0;
                        if (maxIndent === 0) return indentation;
                        if (indentedSoftWrap) {
                            for (var i = 0; i < tokens.length; i++) {
                                var token = tokens[i];
                                if (token == SPACE) indentation += 1;else if (token == TAB) indentation += tabSize;else if (token == TAB_SPACE) continue;else break;
                            }
                        }
                        if (isCode && indentedSoftWrap !== false) indentation += tabSize;
                        return Math.min(indentation, maxIndent);
                    }
                    function addSplit(screenPos) {
                        var displayed = tokens.slice(lastSplit, screenPos);
                        var len = displayed.length;
                        displayed.join("").replace(/12/g, function () {
                            len -= 1;
                        }).replace(/2/g, function () {
                            len -= 1;
                        });

                        if (!splits.length) {
                            indent = getWrapIndent();
                            splits.indent = indent;
                        }
                        lastDocSplit += len;
                        splits.push(lastDocSplit);
                        lastSplit = screenPos;
                    }
                    var indent = 0;
                    while (displayLength - lastSplit > wrapLimit - indent) {
                        var split = lastSplit + wrapLimit - indent;
                        if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
                            addSplit(split);
                            continue;
                        }
                        if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
                            for (split; split != lastSplit - 1; split--) {
                                if (tokens[split] == PLACEHOLDER_START) {
                                    break;
                                }
                            }
                            if (split > lastSplit) {
                                addSplit(split);
                                continue;
                            }
                            split = lastSplit + wrapLimit;
                            for (split; split < tokens.length; split++) {
                                if (tokens[split] != PLACEHOLDER_BODY) {
                                    break;
                                }
                            }
                            if (split == tokens.length) {
                                break; // Breaks the while-loop.
                            }
                            addSplit(split);
                            continue;
                        }
                        var minSplit = Math.max(split - (wrapLimit - (wrapLimit >> 2)), lastSplit - 1);
                        while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                            split--;
                        }
                        if (isCode) {
                            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                                split--;
                            }
                            while (split > minSplit && tokens[split] == PUNCTUATION) {
                                split--;
                            }
                        } else {
                            while (split > minSplit && tokens[split] < SPACE) {
                                split--;
                            }
                        }
                        if (split > minSplit) {
                            addSplit(++split);
                            continue;
                        }
                        split = lastSplit + wrapLimit;
                        if (tokens[split] == CHAR_EXT) split--;
                        addSplit(split - indent);
                    }
                    return splits;
                };
                this.$getDisplayTokens = function (str, offset) {
                    var arr = [];
                    var tabSize;
                    offset = offset || 0;

                    for (var i = 0; i < str.length; i++) {
                        var c = str.charCodeAt(i);
                        if (c == 9) {
                            tabSize = this.getScreenTabSize(arr.length + offset);
                            arr.push(TAB);
                            for (var n = 1; n < tabSize; n++) {
                                arr.push(TAB_SPACE);
                            }
                        } else if (c == 32) {
                            arr.push(SPACE);
                        } else if (c > 39 && c < 48 || c > 57 && c < 64) {
                            arr.push(PUNCTUATION);
                        } else if (c >= 0x1100 && isFullWidth(c)) {
                            arr.push(CHAR, CHAR_EXT);
                        } else {
                            arr.push(CHAR);
                        }
                    }
                    return arr;
                };
                this.$getStringScreenWidth = function (str, maxScreenColumn, screenColumn) {
                    if (maxScreenColumn == 0) return [0, 0];
                    if (maxScreenColumn == null) maxScreenColumn = Infinity;
                    screenColumn = screenColumn || 0;

                    var c, column;
                    for (column = 0; column < str.length; column++) {
                        c = str.charCodeAt(column);
                        if (c == 9) {
                            screenColumn += this.getScreenTabSize(screenColumn);
                        } else if (c >= 0x1100 && isFullWidth(c)) {
                            screenColumn += 2;
                        } else {
                            screenColumn += 1;
                        }
                        if (screenColumn > maxScreenColumn) {
                            break;
                        }
                    }

                    return [screenColumn, column];
                };

                this.lineWidgets = null;
                this.getRowLength = function (row) {
                    if (this.lineWidgets) var h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;else h = 0;
                    if (!this.$useWrapMode || !this.$wrapData[row]) {
                        return 1 + h;
                    } else {
                        return this.$wrapData[row].length + 1 + h;
                    }
                };
                this.getRowLineCount = function (row) {
                    if (!this.$useWrapMode || !this.$wrapData[row]) {
                        return 1;
                    } else {
                        return this.$wrapData[row].length + 1;
                    }
                };

                this.getRowWrapIndent = function (screenRow) {
                    if (this.$useWrapMode) {
                        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
                        var splits = this.$wrapData[pos.row];
                        return splits.length && splits[0] < pos.column ? splits.indent : 0;
                    } else {
                        return 0;
                    }
                };
                this.getScreenLastRowColumn = function (screenRow) {
                    var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
                    return this.documentToScreenColumn(pos.row, pos.column);
                };
                this.getDocumentLastRowColumn = function (docRow, docColumn) {
                    var screenRow = this.documentToScreenRow(docRow, docColumn);
                    return this.getScreenLastRowColumn(screenRow);
                };
                this.getDocumentLastRowColumnPosition = function (docRow, docColumn) {
                    var screenRow = this.documentToScreenRow(docRow, docColumn);
                    return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
                };
                this.getRowSplitData = function (row) {
                    if (!this.$useWrapMode) {
                        return undefined;
                    } else {
                        return this.$wrapData[row];
                    }
                };
                this.getScreenTabSize = function (screenColumn) {
                    return this.$tabSize - screenColumn % this.$tabSize;
                };

                this.screenToDocumentRow = function (screenRow, screenColumn) {
                    return this.screenToDocumentPosition(screenRow, screenColumn).row;
                };

                this.screenToDocumentColumn = function (screenRow, screenColumn) {
                    return this.screenToDocumentPosition(screenRow, screenColumn).column;
                };
                this.screenToDocumentPosition = function (screenRow, screenColumn) {
                    if (screenRow < 0) return { row: 0, column: 0 };

                    var line;
                    var docRow = 0;
                    var docColumn = 0;
                    var column;
                    var row = 0;
                    var rowLength = 0;

                    var rowCache = this.$screenRowCache;
                    var i = this.$getRowCacheIndex(rowCache, screenRow);
                    var l = rowCache.length;
                    if (l && i >= 0) {
                        var row = rowCache[i];
                        var docRow = this.$docRowCache[i];
                        var doCache = screenRow > rowCache[l - 1];
                    } else {
                        var doCache = !l;
                    }

                    var maxRow = this.getLength() - 1;
                    var foldLine = this.getNextFoldLine(docRow);
                    var foldStart = foldLine ? foldLine.start.row : Infinity;

                    while (row <= screenRow) {
                        rowLength = this.getRowLength(docRow);
                        if (row + rowLength > screenRow || docRow >= maxRow) {
                            break;
                        } else {
                            row += rowLength;
                            docRow++;
                            if (docRow > foldStart) {
                                docRow = foldLine.end.row + 1;
                                foldLine = this.getNextFoldLine(docRow, foldLine);
                                foldStart = foldLine ? foldLine.start.row : Infinity;
                            }
                        }

                        if (doCache) {
                            this.$docRowCache.push(docRow);
                            this.$screenRowCache.push(row);
                        }
                    }

                    if (foldLine && foldLine.start.row <= docRow) {
                        line = this.getFoldDisplayLine(foldLine);
                        docRow = foldLine.start.row;
                    } else if (row + rowLength <= screenRow || docRow > maxRow) {
                        return {
                            row: maxRow,
                            column: this.getLine(maxRow).length
                        };
                    } else {
                        line = this.getLine(docRow);
                        foldLine = null;
                    }
                    var wrapIndent = 0;
                    if (this.$useWrapMode) {
                        var splits = this.$wrapData[docRow];
                        if (splits) {
                            var splitIndex = Math.floor(screenRow - row);
                            column = splits[splitIndex];
                            if (splitIndex > 0 && splits.length) {
                                wrapIndent = splits.indent;
                                docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                                line = line.substring(docColumn);
                            }
                        }
                    }

                    docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
                    if (this.$useWrapMode && docColumn >= column) docColumn = column - 1;

                    if (foldLine) return foldLine.idxToPosition(docColumn);

                    return { row: docRow, column: docColumn };
                };
                this.documentToScreenPosition = function (docRow, docColumn) {
                    if (typeof docColumn === "undefined") var pos = this.$clipPositionToDocument(docRow.row, docRow.column);else pos = this.$clipPositionToDocument(docRow, docColumn);

                    docRow = pos.row;
                    docColumn = pos.column;

                    var screenRow = 0;
                    var foldStartRow = null;
                    var fold = null;
                    fold = this.getFoldAt(docRow, docColumn, 1);
                    if (fold) {
                        docRow = fold.start.row;
                        docColumn = fold.start.column;
                    }

                    var rowEnd,
                        row = 0;

                    var rowCache = this.$docRowCache;
                    var i = this.$getRowCacheIndex(rowCache, docRow);
                    var l = rowCache.length;
                    if (l && i >= 0) {
                        var row = rowCache[i];
                        var screenRow = this.$screenRowCache[i];
                        var doCache = docRow > rowCache[l - 1];
                    } else {
                        var doCache = !l;
                    }

                    var foldLine = this.getNextFoldLine(row);
                    var foldStart = foldLine ? foldLine.start.row : Infinity;

                    while (row < docRow) {
                        if (row >= foldStart) {
                            rowEnd = foldLine.end.row + 1;
                            if (rowEnd > docRow) break;
                            foldLine = this.getNextFoldLine(rowEnd, foldLine);
                            foldStart = foldLine ? foldLine.start.row : Infinity;
                        } else {
                            rowEnd = row + 1;
                        }

                        screenRow += this.getRowLength(row);
                        row = rowEnd;

                        if (doCache) {
                            this.$docRowCache.push(row);
                            this.$screenRowCache.push(screenRow);
                        }
                    }
                    var textLine = "";
                    if (foldLine && row >= foldStart) {
                        textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
                        foldStartRow = foldLine.start.row;
                    } else {
                        textLine = this.getLine(docRow).substring(0, docColumn);
                        foldStartRow = docRow;
                    }
                    var wrapIndent = 0;
                    if (this.$useWrapMode) {
                        var wrapRow = this.$wrapData[foldStartRow];
                        if (wrapRow) {
                            var screenRowOffset = 0;
                            while (textLine.length >= wrapRow[screenRowOffset]) {
                                screenRow++;
                                screenRowOffset++;
                            }
                            textLine = textLine.substring(wrapRow[screenRowOffset - 1] || 0, textLine.length);
                            wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
                        }
                    }

                    return {
                        row: screenRow,
                        column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
                    };
                };
                this.documentToScreenColumn = function (row, docColumn) {
                    return this.documentToScreenPosition(row, docColumn).column;
                };
                this.documentToScreenRow = function (docRow, docColumn) {
                    return this.documentToScreenPosition(docRow, docColumn).row;
                };
                this.getScreenLength = function () {
                    var screenRows = 0;
                    var fold = null;
                    if (!this.$useWrapMode) {
                        screenRows = this.getLength();
                        var foldData = this.$foldData;
                        for (var i = 0; i < foldData.length; i++) {
                            fold = foldData[i];
                            screenRows -= fold.end.row - fold.start.row;
                        }
                    } else {
                        var lastRow = this.$wrapData.length;
                        var row = 0,
                            i = 0;
                        var fold = this.$foldData[i++];
                        var foldStart = fold ? fold.start.row : Infinity;

                        while (row < lastRow) {
                            var splits = this.$wrapData[row];
                            screenRows += splits ? splits.length + 1 : 1;
                            row++;
                            if (row > foldStart) {
                                row = fold.end.row + 1;
                                fold = this.$foldData[i++];
                                foldStart = fold ? fold.start.row : Infinity;
                            }
                        }
                    }
                    if (this.lineWidgets) screenRows += this.$getWidgetScreenLength();

                    return screenRows;
                };
                this.$setFontMetrics = function (fm) {
                    if (!this.$enableVarChar) return;
                    this.$getStringScreenWidth = function (str, maxScreenColumn, screenColumn) {
                        if (maxScreenColumn === 0) return [0, 0];
                        if (!maxScreenColumn) maxScreenColumn = Infinity;
                        screenColumn = screenColumn || 0;

                        var c, column;
                        for (column = 0; column < str.length; column++) {
                            c = str.charAt(column);
                            if (c === "\t") {
                                screenColumn += this.getScreenTabSize(screenColumn);
                            } else {
                                screenColumn += fm.getCharacterWidth(c);
                            }
                            if (screenColumn > maxScreenColumn) {
                                break;
                            }
                        }

                        return [screenColumn, column];
                    };
                };

                this.destroy = function () {
                    if (this.bgTokenizer) {
                        this.bgTokenizer.setDocument(null);
                        this.bgTokenizer = null;
                    }
                    this.$stopWorker();
                };
                function isFullWidth(c) {
                    if (c < 0x1100) return false;
                    return c >= 0x1100 && c <= 0x115F || c >= 0x11A3 && c <= 0x11A7 || c >= 0x11FA && c <= 0x11FF || c >= 0x2329 && c <= 0x232A || c >= 0x2E80 && c <= 0x2E99 || c >= 0x2E9B && c <= 0x2EF3 || c >= 0x2F00 && c <= 0x2FD5 || c >= 0x2FF0 && c <= 0x2FFB || c >= 0x3000 && c <= 0x303E || c >= 0x3041 && c <= 0x3096 || c >= 0x3099 && c <= 0x30FF || c >= 0x3105 && c <= 0x312D || c >= 0x3131 && c <= 0x318E || c >= 0x3190 && c <= 0x31BA || c >= 0x31C0 && c <= 0x31E3 || c >= 0x31F0 && c <= 0x321E || c >= 0x3220 && c <= 0x3247 || c >= 0x3250 && c <= 0x32FE || c >= 0x3300 && c <= 0x4DBF || c >= 0x4E00 && c <= 0xA48C || c >= 0xA490 && c <= 0xA4C6 || c >= 0xA960 && c <= 0xA97C || c >= 0xAC00 && c <= 0xD7A3 || c >= 0xD7B0 && c <= 0xD7C6 || c >= 0xD7CB && c <= 0xD7FB || c >= 0xF900 && c <= 0xFAFF || c >= 0xFE10 && c <= 0xFE19 || c >= 0xFE30 && c <= 0xFE52 || c >= 0xFE54 && c <= 0xFE66 || c >= 0xFE68 && c <= 0xFE6B || c >= 0xFF01 && c <= 0xFF60 || c >= 0xFFE0 && c <= 0xFFE6;
                }
            }).call(EditSession.prototype);

            require("./edit_session/folding").Folding.call(EditSession.prototype);
            require("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);

            config.defineOptions(EditSession.prototype, "session", {
                wrap: {
                    set: function (value) {
                        if (!value || value == "off") value = false;else if (value == "free") value = true;else if (value == "printMargin") value = -1;else if (typeof value == "string") value = parseInt(value, 10) || false;

                        if (this.$wrap == value) return;
                        this.$wrap = value;
                        if (!value) {
                            this.setUseWrapMode(false);
                        } else {
                            var col = typeof value == "number" ? value : null;
                            this.setWrapLimitRange(col, col);
                            this.setUseWrapMode(true);
                        }
                    },
                    get: function () {
                        if (this.getUseWrapMode()) {
                            if (this.$wrap == -1) return "printMargin";
                            if (!this.getWrapLimitRange().min) return "free";
                            return this.$wrap;
                        }
                        return "off";
                    },
                    handlesSet: true
                },
                wrapMethod: {
                    set: function (val) {
                        val = val == "auto" ? this.$mode.type != "text" : val != "text";
                        if (val != this.$wrapAsCode) {
                            this.$wrapAsCode = val;
                            if (this.$useWrapMode) {
                                this.$modified = true;
                                this.$resetRowCache(0);
                                this.$updateWrapData(0, this.getLength() - 1);
                            }
                        }
                    },
                    initialValue: "auto"
                },
                indentedSoftWrap: { initialValue: true },
                firstLineNumber: {
                    set: function () {
                        this._signal("changeBreakpoint");
                    },
                    initialValue: 1
                },
                useWorker: {
                    set: function (useWorker) {
                        this.$useWorker = useWorker;

                        this.$stopWorker();
                        if (useWorker) this.$startWorker();
                    },
                    initialValue: true
                },
                useSoftTabs: { initialValue: true },
                tabSize: {
                    set: function (tabSize) {
                        if (isNaN(tabSize) || this.$tabSize === tabSize) return;

                        this.$modified = true;
                        this.$rowLengthCache = [];
                        this.$tabSize = tabSize;
                        this._signal("changeTabSize");
                    },
                    initialValue: 4,
                    handlesSet: true
                },
                overwrite: {
                    set: function (val) {
                        this._signal("changeOverwrite");
                    },
                    initialValue: false
                },
                newLineMode: {
                    set: function (val) {
                        this.doc.setNewLineMode(val);
                    },
                    get: function () {
                        return this.doc.getNewLineMode();
                    },
                    handlesSet: true
                },
                mode: {
                    set: function (val) {
                        this.setMode(val);
                    },
                    get: function () {
                        return this.$modeId;
                    }
                }
            });

            exports.EditSession = EditSession;
        });

        ace.define("ace/search", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function (require, exports, module) {
            "use strict";

            var lang = require("./lib/lang");
            var oop = require("./lib/oop");
            var Range = require("./range").Range;

            var Search = function () {
                this.$options = {};
            };

            (function () {
                this.set = function (options) {
                    oop.mixin(this.$options, options);
                    return this;
                };
                this.getOptions = function () {
                    return lang.copyObject(this.$options);
                };
                this.setOptions = function (options) {
                    this.$options = options;
                };
                this.find = function (session) {
                    var options = this.$options;
                    var iterator = this.$matchIterator(session, options);
                    if (!iterator) return false;

                    var firstRange = null;
                    iterator.forEach(function (range, row, offset) {
                        if (!range.start) {
                            var column = range.offset + (offset || 0);
                            firstRange = new Range(row, column, row, column + range.length);
                            if (!range.length && options.start && options.start.start && options.skipCurrent != false && firstRange.isEqual(options.start)) {
                                firstRange = null;
                                return false;
                            }
                        } else firstRange = range;
                        return true;
                    });

                    return firstRange;
                };
                this.findAll = function (session) {
                    var options = this.$options;
                    if (!options.needle) return [];
                    this.$assembleRegExp(options);

                    var range = options.range;
                    var lines = range ? session.getLines(range.start.row, range.end.row) : session.doc.getAllLines();

                    var ranges = [];
                    var re = options.re;
                    if (options.$isMultiLine) {
                        var len = re.length;
                        var maxRow = lines.length - len;
                        var prevRange;
                        outer: for (var row = re.offset || 0; row <= maxRow; row++) {
                            for (var j = 0; j < len; j++) if (lines[row + j].search(re[j]) == -1) continue outer;

                            var startLine = lines[row];
                            var line = lines[row + len - 1];
                            var startIndex = startLine.length - startLine.match(re[0])[0].length;
                            var endIndex = line.match(re[len - 1])[0].length;

                            if (prevRange && prevRange.end.row === row && prevRange.end.column > startIndex) {
                                continue;
                            }
                            ranges.push(prevRange = new Range(row, startIndex, row + len - 1, endIndex));
                            if (len > 2) row = row + len - 2;
                        }
                    } else {
                        for (var i = 0; i < lines.length; i++) {
                            var matches = lang.getMatchOffsets(lines[i], re);
                            for (var j = 0; j < matches.length; j++) {
                                var match = matches[j];
                                ranges.push(new Range(i, match.offset, i, match.offset + match.length));
                            }
                        }
                    }

                    if (range) {
                        var startColumn = range.start.column;
                        var endColumn = range.start.column;
                        var i = 0,
                            j = ranges.length - 1;
                        while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row) i++;

                        while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row) j--;

                        ranges = ranges.slice(i, j + 1);
                        for (i = 0, j = ranges.length; i < j; i++) {
                            ranges[i].start.row += range.start.row;
                            ranges[i].end.row += range.start.row;
                        }
                    }

                    return ranges;
                };
                this.replace = function (input, replacement) {
                    var options = this.$options;

                    var re = this.$assembleRegExp(options);
                    if (options.$isMultiLine) return replacement;

                    if (!re) return;

                    var match = re.exec(input);
                    if (!match || match[0].length != input.length) return null;

                    replacement = input.replace(re, replacement);
                    if (options.preserveCase) {
                        replacement = replacement.split("");
                        for (var i = Math.min(input.length, input.length); i--;) {
                            var ch = input[i];
                            if (ch && ch.toLowerCase() != ch) replacement[i] = replacement[i].toUpperCase();else replacement[i] = replacement[i].toLowerCase();
                        }
                        replacement = replacement.join("");
                    }

                    return replacement;
                };

                this.$matchIterator = function (session, options) {
                    var re = this.$assembleRegExp(options);
                    if (!re) return false;

                    var callback;
                    if (options.$isMultiLine) {
                        var len = re.length;
                        var matchIterator = function (line, row, offset) {
                            var startIndex = line.search(re[0]);
                            if (startIndex == -1) return;
                            for (var i = 1; i < len; i++) {
                                line = session.getLine(row + i);
                                if (line.search(re[i]) == -1) return;
                            }

                            var endIndex = line.match(re[len - 1])[0].length;

                            var range = new Range(row, startIndex, row + len - 1, endIndex);
                            if (re.offset == 1) {
                                range.start.row--;
                                range.start.column = Number.MAX_VALUE;
                            } else if (offset) range.start.column += offset;

                            if (callback(range)) return true;
                        };
                    } else if (options.backwards) {
                        var matchIterator = function (line, row, startIndex) {
                            var matches = lang.getMatchOffsets(line, re);
                            for (var i = matches.length - 1; i >= 0; i--) if (callback(matches[i], row, startIndex)) return true;
                        };
                    } else {
                        var matchIterator = function (line, row, startIndex) {
                            var matches = lang.getMatchOffsets(line, re);
                            for (var i = 0; i < matches.length; i++) if (callback(matches[i], row, startIndex)) return true;
                        };
                    }

                    var lineIterator = this.$lineIterator(session, options);

                    return {
                        forEach: function (_callback) {
                            callback = _callback;
                            lineIterator.forEach(matchIterator);
                        }
                    };
                };

                this.$assembleRegExp = function (options, $disableFakeMultiline) {
                    if (options.needle instanceof RegExp) return options.re = options.needle;

                    var needle = options.needle;

                    if (!options.needle) return options.re = false;

                    if (!options.regExp) needle = lang.escapeRegExp(needle);

                    if (options.wholeWord) needle = addWordBoundary(needle, options);

                    var modifier = options.caseSensitive ? "gm" : "gmi";

                    options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
                    if (options.$isMultiLine) return options.re = this.$assembleMultilineRegExp(needle, modifier);

                    try {
                        var re = new RegExp(needle, modifier);
                    } catch (e) {
                        re = false;
                    }
                    return options.re = re;
                };

                this.$assembleMultilineRegExp = function (needle, modifier) {
                    var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
                    var re = [];
                    for (var i = 0; i < parts.length; i++) try {
                        re.push(new RegExp(parts[i], modifier));
                    } catch (e) {
                        return false;
                    }
                    if (parts[0] == "") {
                        re.shift();
                        re.offset = 1;
                    } else {
                        re.offset = 0;
                    }
                    return re;
                };

                this.$lineIterator = function (session, options) {
                    var backwards = options.backwards == true;
                    var skipCurrent = options.skipCurrent != false;

                    var range = options.range;
                    var start = options.start;
                    if (!start) start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();

                    if (start.start) start = start[skipCurrent != backwards ? "end" : "start"];

                    var firstRow = range ? range.start.row : 0;
                    var lastRow = range ? range.end.row : session.getLength() - 1;

                    var forEach = backwards ? function (callback) {
                        var row = start.row;

                        var line = session.getLine(row).substring(0, start.column);
                        if (callback(line, row)) return;

                        for (row--; row >= firstRow; row--) if (callback(session.getLine(row), row)) return;

                        if (options.wrap == false) return;

                        for (row = lastRow, firstRow = start.row; row >= firstRow; row--) if (callback(session.getLine(row), row)) return;
                    } : function (callback) {
                        var row = start.row;

                        var line = session.getLine(row).substr(start.column);
                        if (callback(line, row, start.column)) return;

                        for (row = row + 1; row <= lastRow; row++) if (callback(session.getLine(row), row)) return;

                        if (options.wrap == false) return;

                        for (row = firstRow, lastRow = start.row; row <= lastRow; row++) if (callback(session.getLine(row), row)) return;
                    };

                    return { forEach: forEach };
                };
            }).call(Search.prototype);

            function addWordBoundary(needle, options) {
                function wordBoundary(c) {
                    if (/\w/.test(c) || options.regExp) return "\\b";
                    return "";
                }
                return wordBoundary(needle[0]) + needle + wordBoundary(needle[needle.length - 1]);
            }

            exports.Search = Search;
        });

        ace.define("ace/keyboard/hash_handler", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function (require, exports, module) {
            "use strict";

            var keyUtil = require("../lib/keys");
            var useragent = require("../lib/useragent");
            var KEY_MODS = keyUtil.KEY_MODS;

            function HashHandler(config, platform) {
                this.platform = platform || (useragent.isMac ? "mac" : "win");
                this.commands = {};
                this.commandKeyBinding = {};
                this.addCommands(config);
                this.$singleCommand = true;
            }

            function MultiHashHandler(config, platform) {
                HashHandler.call(this, config, platform);
                this.$singleCommand = false;
            }

            MultiHashHandler.prototype = HashHandler.prototype;

            (function () {

                this.addCommand = function (command) {
                    if (this.commands[command.name]) this.removeCommand(command);

                    this.commands[command.name] = command;

                    if (command.bindKey) this._buildKeyHash(command);
                };

                this.removeCommand = function (command, keepCommand) {
                    var name = command && (typeof command === 'string' ? command : command.name);
                    command = this.commands[name];
                    if (!keepCommand) delete this.commands[name];
                    var ckb = this.commandKeyBinding;
                    for (var keyId in ckb) {
                        var cmdGroup = ckb[keyId];
                        if (cmdGroup == command) {
                            delete ckb[keyId];
                        } else if (Array.isArray(cmdGroup)) {
                            var i = cmdGroup.indexOf(command);
                            if (i != -1) {
                                cmdGroup.splice(i, 1);
                                if (cmdGroup.length == 1) ckb[keyId] = cmdGroup[0];
                            }
                        }
                    }
                };

                this.bindKey = function (key, command, position) {
                    if (typeof key == "object" && key) {
                        if (position == undefined) position = key.position;
                        key = key[this.platform];
                    }
                    if (!key) return;
                    if (typeof command == "function") return this.addCommand({ exec: command, bindKey: key, name: command.name || key });

                    key.split("|").forEach(function (keyPart) {
                        var chain = "";
                        if (keyPart.indexOf(" ") != -1) {
                            var parts = keyPart.split(/\s+/);
                            keyPart = parts.pop();
                            parts.forEach(function (keyPart) {
                                var binding = this.parseKeys(keyPart);
                                var id = KEY_MODS[binding.hashId] + binding.key;
                                chain += (chain ? " " : "") + id;
                                this._addCommandToBinding(chain, "chainKeys");
                            }, this);
                            chain += " ";
                        }
                        var binding = this.parseKeys(keyPart);
                        var id = KEY_MODS[binding.hashId] + binding.key;
                        this._addCommandToBinding(chain + id, command, position);
                    }, this);
                };

                function getPosition(command) {
                    return typeof command == "object" && command.bindKey && command.bindKey.position || 0;
                }
                this._addCommandToBinding = function (keyId, command, position) {
                    var ckb = this.commandKeyBinding,
                        i;
                    if (!command) {
                        delete ckb[keyId];
                    } else if (!ckb[keyId] || this.$singleCommand) {
                        ckb[keyId] = command;
                    } else {
                        if (!Array.isArray(ckb[keyId])) {
                            ckb[keyId] = [ckb[keyId]];
                        } else if ((i = ckb[keyId].indexOf(command)) != -1) {
                            ckb[keyId].splice(i, 1);
                        }

                        if (typeof position != "number") {
                            if (position || command.isDefault) position = -100;else position = getPosition(command);
                        }
                        var commands = ckb[keyId];
                        for (i = 0; i < commands.length; i++) {
                            var other = commands[i];
                            var otherPos = getPosition(other);
                            if (otherPos > position) break;
                        }
                        commands.splice(i, 0, command);
                    }
                };

                this.addCommands = function (commands) {
                    commands && Object.keys(commands).forEach(function (name) {
                        var command = commands[name];
                        if (!command) return;

                        if (typeof command === "string") return this.bindKey(command, name);

                        if (typeof command === "function") command = { exec: command };

                        if (typeof command !== "object") return;

                        if (!command.name) command.name = name;

                        this.addCommand(command);
                    }, this);
                };

                this.removeCommands = function (commands) {
                    Object.keys(commands).forEach(function (name) {
                        this.removeCommand(commands[name]);
                    }, this);
                };

                this.bindKeys = function (keyList) {
                    Object.keys(keyList).forEach(function (key) {
                        this.bindKey(key, keyList[key]);
                    }, this);
                };

                this._buildKeyHash = function (command) {
                    this.bindKey(command.bindKey, command);
                };
                this.parseKeys = function (keys) {
                    var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function (x) {
                        return x;
                    });
                    var key = parts.pop();

                    var keyCode = keyUtil[key];
                    if (keyUtil.FUNCTION_KEYS[keyCode]) key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();else if (!parts.length) return { key: key, hashId: -1 };else if (parts.length == 1 && parts[0] == "shift") return { key: key.toUpperCase(), hashId: -1 };

                    var hashId = 0;
                    for (var i = parts.length; i--;) {
                        var modifier = keyUtil.KEY_MODS[parts[i]];
                        if (modifier == null) {
                            if (typeof console != "undefined") console.error("invalid modifier " + parts[i] + " in " + keys);
                            return false;
                        }
                        hashId |= modifier;
                    }
                    return { key: key, hashId: hashId };
                };

                this.findKeyCommand = function findKeyCommand(hashId, keyString) {
                    var key = KEY_MODS[hashId] + keyString;
                    return this.commandKeyBinding[key];
                };

                this.handleKeyboard = function (data, hashId, keyString, keyCode) {
                    if (keyCode < 0) return;
                    var key = KEY_MODS[hashId] + keyString;
                    var command = this.commandKeyBinding[key];
                    if (data.$keyChain) {
                        data.$keyChain += " " + key;
                        command = this.commandKeyBinding[data.$keyChain] || command;
                    }

                    if (command) {
                        if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
                            data.$keyChain = data.$keyChain || key;
                            return { command: "null" };
                        }
                    }

                    if (data.$keyChain) {
                        if ((!hashId || hashId == 4) && keyString.length == 1) data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input
                        else if (hashId == -1 || keyCode > 0) data.$keyChain = ""; // reset keyChain
                    }
                    return { command: command };
                };

                this.getStatusText = function (editor, data) {
                    return data.$keyChain || "";
                };
            }).call(HashHandler.prototype);

            exports.HashHandler = HashHandler;
            exports.MultiHashHandler = MultiHashHandler;
        });

        ace.define("ace/commands/command_manager", ["require", "exports", "module", "ace/lib/oop", "ace/keyboard/hash_handler", "ace/lib/event_emitter"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var MultiHashHandler = require("../keyboard/hash_handler").MultiHashHandler;
            var EventEmitter = require("../lib/event_emitter").EventEmitter;

            var CommandManager = function (platform, commands) {
                MultiHashHandler.call(this, commands, platform);
                this.byName = this.commands;
                this.setDefaultHandler("exec", function (e) {
                    return e.command.exec(e.editor, e.args || {});
                });
            };

            oop.inherits(CommandManager, MultiHashHandler);

            (function () {

                oop.implement(this, EventEmitter);

                this.exec = function (command, editor, args) {
                    if (Array.isArray(command)) {
                        for (var i = command.length; i--;) {
                            if (this.exec(command[i], editor, args)) return true;
                        }
                        return false;
                    }

                    if (typeof command === "string") command = this.commands[command];

                    if (!command) return false;

                    if (editor && editor.$readOnly && !command.readOnly) return false;

                    var e = { editor: editor, command: command, args: args };
                    e.returnValue = this._emit("exec", e);
                    this._signal("afterExec", e);

                    return e.returnValue === false ? false : true;
                };

                this.toggleRecording = function (editor) {
                    if (this.$inReplay) return;

                    editor && editor._emit("changeStatus");
                    if (this.recording) {
                        this.macro.pop();
                        this.removeEventListener("exec", this.$addCommandToMacro);

                        if (!this.macro.length) this.macro = this.oldMacro;

                        return this.recording = false;
                    }
                    if (!this.$addCommandToMacro) {
                        this.$addCommandToMacro = function (e) {
                            this.macro.push([e.command, e.args]);
                        }.bind(this);
                    }

                    this.oldMacro = this.macro;
                    this.macro = [];
                    this.on("exec", this.$addCommandToMacro);
                    return this.recording = true;
                };

                this.replay = function (editor) {
                    if (this.$inReplay || !this.macro) return;

                    if (this.recording) return this.toggleRecording(editor);

                    try {
                        this.$inReplay = true;
                        this.macro.forEach(function (x) {
                            if (typeof x == "string") this.exec(x, editor);else this.exec(x[0], editor, x[1]);
                        }, this);
                    } finally {
                        this.$inReplay = false;
                    }
                };

                this.trimMacro = function (m) {
                    return m.map(function (x) {
                        if (typeof x[0] != "string") x[0] = x[0].name;
                        if (!x[1]) x = x[0];
                        return x;
                    });
                };
            }).call(CommandManager.prototype);

            exports.CommandManager = CommandManager;
        });

        ace.define("ace/commands/default_commands", ["require", "exports", "module", "ace/lib/lang", "ace/config", "ace/range"], function (require, exports, module) {
            "use strict";

            var lang = require("../lib/lang");
            var config = require("../config");
            var Range = require("../range").Range;

            function bindKey(win, mac) {
                return { win: win, mac: mac };
            }
            exports.commands = [{
                name: "showSettingsMenu",
                bindKey: bindKey("Ctrl-,", "Command-,"),
                exec: function (editor) {
                    config.loadModule("ace/ext/settings_menu", function (module) {
                        module.init(editor);
                        editor.showSettingsMenu();
                    });
                },
                readOnly: true
            }, {
                name: "goToNextError",
                bindKey: bindKey("Alt-E", "F4"),
                exec: function (editor) {
                    config.loadModule("ace/ext/error_marker", function (module) {
                        module.showErrorMarker(editor, 1);
                    });
                },
                scrollIntoView: "animate",
                readOnly: true
            }, {
                name: "goToPreviousError",
                bindKey: bindKey("Alt-Shift-E", "Shift-F4"),
                exec: function (editor) {
                    config.loadModule("ace/ext/error_marker", function (module) {
                        module.showErrorMarker(editor, -1);
                    });
                },
                scrollIntoView: "animate",
                readOnly: true
            }, {
                name: "selectall",
                bindKey: bindKey("Ctrl-A", "Command-A"),
                exec: function (editor) {
                    editor.selectAll();
                },
                readOnly: true
            }, {
                name: "centerselection",
                bindKey: bindKey(null, "Ctrl-L"),
                exec: function (editor) {
                    editor.centerSelection();
                },
                readOnly: true
            }, {
                name: "gotoline",
                bindKey: bindKey("Ctrl-L", "Command-L"),
                exec: function (editor) {
                    var line = parseInt(prompt("Enter line number:"), 10);
                    if (!isNaN(line)) {
                        editor.gotoLine(line);
                    }
                },
                readOnly: true
            }, {
                name: "fold",
                bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
                exec: function (editor) {
                    editor.session.toggleFold(false);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "unfold",
                bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
                exec: function (editor) {
                    editor.session.toggleFold(true);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "toggleFoldWidget",
                bindKey: bindKey("F2", "F2"),
                exec: function (editor) {
                    editor.session.toggleFoldWidget();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "toggleParentFoldWidget",
                bindKey: bindKey("Alt-F2", "Alt-F2"),
                exec: function (editor) {
                    editor.session.toggleFoldWidget(true);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "foldall",
                bindKey: bindKey(null, "Ctrl-Command-Option-0"),
                exec: function (editor) {
                    editor.session.foldAll();
                },
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "foldOther",
                bindKey: bindKey("Alt-0", "Command-Option-0"),
                exec: function (editor) {
                    editor.session.foldAll();
                    editor.session.unfold(editor.selection.getAllRanges());
                },
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "unfoldall",
                bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
                exec: function (editor) {
                    editor.session.unfold();
                },
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "findnext",
                bindKey: bindKey("Ctrl-K", "Command-G"),
                exec: function (editor) {
                    editor.findNext();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "findprevious",
                bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
                exec: function (editor) {
                    editor.findPrevious();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "selectOrFindNext",
                bindKey: bindKey("Alt-K", "Ctrl-G"),
                exec: function (editor) {
                    if (editor.selection.isEmpty()) editor.selection.selectWord();else editor.findNext();
                },
                readOnly: true
            }, {
                name: "selectOrFindPrevious",
                bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
                exec: function (editor) {
                    if (editor.selection.isEmpty()) editor.selection.selectWord();else editor.findPrevious();
                },
                readOnly: true
            }, {
                name: "find",
                bindKey: bindKey("Ctrl-F", "Command-F"),
                exec: function (editor) {
                    config.loadModule("ace/ext/searchbox", function (e) {
                        e.Search(editor);
                    });
                },
                readOnly: true
            }, {
                name: "overwrite",
                bindKey: "Insert",
                exec: function (editor) {
                    editor.toggleOverwrite();
                },
                readOnly: true
            }, {
                name: "selecttostart",
                bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Home|Command-Shift-Up"),
                exec: function (editor) {
                    editor.getSelection().selectFileStart();
                },
                multiSelectAction: "forEach",
                readOnly: true,
                scrollIntoView: "animate",
                aceCommandGroup: "fileJump"
            }, {
                name: "gotostart",
                bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
                exec: function (editor) {
                    editor.navigateFileStart();
                },
                multiSelectAction: "forEach",
                readOnly: true,
                scrollIntoView: "animate",
                aceCommandGroup: "fileJump"
            }, {
                name: "selectup",
                bindKey: bindKey("Shift-Up", "Shift-Up|Ctrl-Shift-P"),
                exec: function (editor) {
                    editor.getSelection().selectUp();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "golineup",
                bindKey: bindKey("Up", "Up|Ctrl-P"),
                exec: function (editor, args) {
                    editor.navigateUp(args.times);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selecttoend",
                bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-End|Command-Shift-Down"),
                exec: function (editor) {
                    editor.getSelection().selectFileEnd();
                },
                multiSelectAction: "forEach",
                readOnly: true,
                scrollIntoView: "animate",
                aceCommandGroup: "fileJump"
            }, {
                name: "gotoend",
                bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
                exec: function (editor) {
                    editor.navigateFileEnd();
                },
                multiSelectAction: "forEach",
                readOnly: true,
                scrollIntoView: "animate",
                aceCommandGroup: "fileJump"
            }, {
                name: "selectdown",
                bindKey: bindKey("Shift-Down", "Shift-Down|Ctrl-Shift-N"),
                exec: function (editor) {
                    editor.getSelection().selectDown();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "golinedown",
                bindKey: bindKey("Down", "Down|Ctrl-N"),
                exec: function (editor, args) {
                    editor.navigateDown(args.times);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectwordleft",
                bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
                exec: function (editor) {
                    editor.getSelection().selectWordLeft();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "gotowordleft",
                bindKey: bindKey("Ctrl-Left", "Option-Left"),
                exec: function (editor) {
                    editor.navigateWordLeft();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selecttolinestart",
                bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left|Ctrl-Shift-A"),
                exec: function (editor) {
                    editor.getSelection().selectLineStart();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "gotolinestart",
                bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
                exec: function (editor) {
                    editor.navigateLineStart();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectleft",
                bindKey: bindKey("Shift-Left", "Shift-Left|Ctrl-Shift-B"),
                exec: function (editor) {
                    editor.getSelection().selectLeft();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "gotoleft",
                bindKey: bindKey("Left", "Left|Ctrl-B"),
                exec: function (editor, args) {
                    editor.navigateLeft(args.times);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectwordright",
                bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
                exec: function (editor) {
                    editor.getSelection().selectWordRight();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "gotowordright",
                bindKey: bindKey("Ctrl-Right", "Option-Right"),
                exec: function (editor) {
                    editor.navigateWordRight();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selecttolineend",
                bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right|Shift-End|Ctrl-Shift-E"),
                exec: function (editor) {
                    editor.getSelection().selectLineEnd();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "gotolineend",
                bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
                exec: function (editor) {
                    editor.navigateLineEnd();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectright",
                bindKey: bindKey("Shift-Right", "Shift-Right"),
                exec: function (editor) {
                    editor.getSelection().selectRight();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "gotoright",
                bindKey: bindKey("Right", "Right|Ctrl-F"),
                exec: function (editor, args) {
                    editor.navigateRight(args.times);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectpagedown",
                bindKey: "Shift-PageDown",
                exec: function (editor) {
                    editor.selectPageDown();
                },
                readOnly: true
            }, {
                name: "pagedown",
                bindKey: bindKey(null, "Option-PageDown"),
                exec: function (editor) {
                    editor.scrollPageDown();
                },
                readOnly: true
            }, {
                name: "gotopagedown",
                bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
                exec: function (editor) {
                    editor.gotoPageDown();
                },
                readOnly: true
            }, {
                name: "selectpageup",
                bindKey: "Shift-PageUp",
                exec: function (editor) {
                    editor.selectPageUp();
                },
                readOnly: true
            }, {
                name: "pageup",
                bindKey: bindKey(null, "Option-PageUp"),
                exec: function (editor) {
                    editor.scrollPageUp();
                },
                readOnly: true
            }, {
                name: "gotopageup",
                bindKey: "PageUp",
                exec: function (editor) {
                    editor.gotoPageUp();
                },
                readOnly: true
            }, {
                name: "scrollup",
                bindKey: bindKey("Ctrl-Up", null),
                exec: function (e) {
                    e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight);
                },
                readOnly: true
            }, {
                name: "scrolldown",
                bindKey: bindKey("Ctrl-Down", null),
                exec: function (e) {
                    e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight);
                },
                readOnly: true
            }, {
                name: "selectlinestart",
                bindKey: "Shift-Home",
                exec: function (editor) {
                    editor.getSelection().selectLineStart();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectlineend",
                bindKey: "Shift-End",
                exec: function (editor) {
                    editor.getSelection().selectLineEnd();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "togglerecording",
                bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
                exec: function (editor) {
                    editor.commands.toggleRecording(editor);
                },
                readOnly: true
            }, {
                name: "replaymacro",
                bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
                exec: function (editor) {
                    editor.commands.replay(editor);
                },
                readOnly: true
            }, {
                name: "jumptomatching",
                bindKey: bindKey("Ctrl-P", "Ctrl-P"),
                exec: function (editor) {
                    editor.jumpToMatching();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "animate",
                readOnly: true
            }, {
                name: "selecttomatching",
                bindKey: bindKey("Ctrl-Shift-P", "Ctrl-Shift-P"),
                exec: function (editor) {
                    editor.jumpToMatching(true);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "animate",
                readOnly: true
            }, {
                name: "expandToMatching",
                bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
                exec: function (editor) {
                    editor.jumpToMatching(true, true);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "animate",
                readOnly: true
            }, {
                name: "passKeysToBrowser",
                bindKey: bindKey(null, null),
                exec: function () {},
                passEvent: true,
                readOnly: true
            }, {
                name: "copy",
                exec: function (editor) {},
                readOnly: true
            }, {
                name: "cut",
                exec: function (editor) {
                    var range = editor.getSelectionRange();
                    editor._emit("cut", range);

                    if (!editor.selection.isEmpty()) {
                        editor.session.remove(range);
                        editor.clearSelection();
                    }
                },
                scrollIntoView: "cursor",
                multiSelectAction: "forEach"
            }, {
                name: "paste",
                exec: function (editor, args) {
                    editor.$handlePaste(args);
                },
                scrollIntoView: "cursor"
            }, {
                name: "removeline",
                bindKey: bindKey("Ctrl-D", "Command-D"),
                exec: function (editor) {
                    editor.removeLines();
                },
                scrollIntoView: "cursor",
                multiSelectAction: "forEachLine"
            }, {
                name: "duplicateSelection",
                bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
                exec: function (editor) {
                    editor.duplicateSelection();
                },
                scrollIntoView: "cursor",
                multiSelectAction: "forEach"
            }, {
                name: "sortlines",
                bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
                exec: function (editor) {
                    editor.sortLines();
                },
                scrollIntoView: "selection",
                multiSelectAction: "forEachLine"
            }, {
                name: "togglecomment",
                bindKey: bindKey("Ctrl-/", "Command-/"),
                exec: function (editor) {
                    editor.toggleCommentLines();
                },
                multiSelectAction: "forEachLine",
                scrollIntoView: "selectionPart"
            }, {
                name: "toggleBlockComment",
                bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
                exec: function (editor) {
                    editor.toggleBlockComment();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "selectionPart"
            }, {
                name: "modifyNumberUp",
                bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
                exec: function (editor) {
                    editor.modifyNumber(1);
                },
                scrollIntoView: "cursor",
                multiSelectAction: "forEach"
            }, {
                name: "modifyNumberDown",
                bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
                exec: function (editor) {
                    editor.modifyNumber(-1);
                },
                scrollIntoView: "cursor",
                multiSelectAction: "forEach"
            }, {
                name: "replace",
                bindKey: bindKey("Ctrl-H", "Command-Option-F"),
                exec: function (editor) {
                    config.loadModule("ace/ext/searchbox", function (e) {
                        e.Search(editor, true);
                    });
                }
            }, {
                name: "undo",
                bindKey: bindKey("Ctrl-Z", "Command-Z"),
                exec: function (editor) {
                    editor.undo();
                }
            }, {
                name: "redo",
                bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
                exec: function (editor) {
                    editor.redo();
                }
            }, {
                name: "copylinesup",
                bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
                exec: function (editor) {
                    editor.copyLinesUp();
                },
                scrollIntoView: "cursor"
            }, {
                name: "movelinesup",
                bindKey: bindKey("Alt-Up", "Option-Up"),
                exec: function (editor) {
                    editor.moveLinesUp();
                },
                scrollIntoView: "cursor"
            }, {
                name: "copylinesdown",
                bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
                exec: function (editor) {
                    editor.copyLinesDown();
                },
                scrollIntoView: "cursor"
            }, {
                name: "movelinesdown",
                bindKey: bindKey("Alt-Down", "Option-Down"),
                exec: function (editor) {
                    editor.moveLinesDown();
                },
                scrollIntoView: "cursor"
            }, {
                name: "del",
                bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
                exec: function (editor) {
                    editor.remove("right");
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "backspace",
                bindKey: bindKey("Shift-Backspace|Backspace", "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"),
                exec: function (editor) {
                    editor.remove("left");
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "cut_or_delete",
                bindKey: bindKey("Shift-Delete", null),
                exec: function (editor) {
                    if (editor.selection.isEmpty()) {
                        editor.remove("left");
                    } else {
                        return false;
                    }
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "removetolinestart",
                bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
                exec: function (editor) {
                    editor.removeToLineStart();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "removetolineend",
                bindKey: bindKey("Alt-Delete", "Ctrl-K"),
                exec: function (editor) {
                    editor.removeToLineEnd();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "removewordleft",
                bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
                exec: function (editor) {
                    editor.removeWordLeft();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "removewordright",
                bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
                exec: function (editor) {
                    editor.removeWordRight();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "outdent",
                bindKey: bindKey("Shift-Tab", "Shift-Tab"),
                exec: function (editor) {
                    editor.blockOutdent();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "selectionPart"
            }, {
                name: "indent",
                bindKey: bindKey("Tab", "Tab"),
                exec: function (editor) {
                    editor.indent();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "selectionPart"
            }, {
                name: "blockoutdent",
                bindKey: bindKey("Ctrl-[", "Ctrl-["),
                exec: function (editor) {
                    editor.blockOutdent();
                },
                multiSelectAction: "forEachLine",
                scrollIntoView: "selectionPart"
            }, {
                name: "blockindent",
                bindKey: bindKey("Ctrl-]", "Ctrl-]"),
                exec: function (editor) {
                    editor.blockIndent();
                },
                multiSelectAction: "forEachLine",
                scrollIntoView: "selectionPart"
            }, {
                name: "insertstring",
                exec: function (editor, str) {
                    editor.insert(str);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "inserttext",
                exec: function (editor, args) {
                    editor.insert(lang.stringRepeat(args.text || "", args.times || 1));
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "splitline",
                bindKey: bindKey(null, "Ctrl-O"),
                exec: function (editor) {
                    editor.splitLine();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "transposeletters",
                bindKey: bindKey("Ctrl-T", "Ctrl-T"),
                exec: function (editor) {
                    editor.transposeLetters();
                },
                multiSelectAction: function (editor) {
                    editor.transposeSelections(1);
                },
                scrollIntoView: "cursor"
            }, {
                name: "touppercase",
                bindKey: bindKey("Ctrl-U", "Ctrl-U"),
                exec: function (editor) {
                    editor.toUpperCase();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "tolowercase",
                bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
                exec: function (editor) {
                    editor.toLowerCase();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "expandtoline",
                bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
                exec: function (editor) {
                    var range = editor.selection.getRange();

                    range.start.column = range.end.column = 0;
                    range.end.row++;
                    editor.selection.setRange(range, false);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "joinlines",
                bindKey: bindKey(null, null),
                exec: function (editor) {
                    var isBackwards = editor.selection.isBackwards();
                    var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
                    var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
                    var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
                    var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
                    var selectedCount = selectedText.replace(/\n\s*/, " ").length;
                    var insertLine = editor.session.doc.getLine(selectionStart.row);

                    for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {
                        var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
                        if (curLine.length !== 0) {
                            curLine = " " + curLine;
                        }
                        insertLine += curLine;
                    }

                    if (selectionEnd.row + 1 < editor.session.doc.getLength() - 1) {
                        insertLine += editor.session.doc.getNewLineCharacter();
                    }

                    editor.clearSelection();
                    editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);

                    if (selectedCount > 0) {
                        editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
                        editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
                    } else {
                        firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? firstLineEndCol + 1 : firstLineEndCol;
                        editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
                    }
                },
                multiSelectAction: "forEach",
                readOnly: true
            }, {
                name: "invertSelection",
                bindKey: bindKey(null, null),
                exec: function (editor) {
                    var endRow = editor.session.doc.getLength() - 1;
                    var endCol = editor.session.doc.getLine(endRow).length;
                    var ranges = editor.selection.rangeList.ranges;
                    var newRanges = [];
                    if (ranges.length < 1) {
                        ranges = [editor.selection.getRange()];
                    }

                    for (var i = 0; i < ranges.length; i++) {
                        if (i == ranges.length - 1) {
                            if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
                                newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
                            }
                        }

                        if (i === 0) {
                            if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
                                newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
                            }
                        } else {
                            newRanges.push(new Range(ranges[i - 1].end.row, ranges[i - 1].end.column, ranges[i].start.row, ranges[i].start.column));
                        }
                    }

                    editor.exitMultiSelectMode();
                    editor.clearSelection();

                    for (var i = 0; i < newRanges.length; i++) {
                        editor.selection.addRange(newRanges[i], false);
                    }
                },
                readOnly: true,
                scrollIntoView: "none"
            }];
        });

        ace.define("ace/editor", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/keyboard/textinput", "ace/mouse/mouse_handler", "ace/mouse/fold_handler", "ace/keyboard/keybinding", "ace/edit_session", "ace/search", "ace/range", "ace/lib/event_emitter", "ace/commands/command_manager", "ace/commands/default_commands", "ace/config", "ace/token_iterator"], function (require, exports, module) {
            "use strict";

            require("./lib/fixoldbrowsers");

            var oop = require("./lib/oop");
            var dom = require("./lib/dom");
            var lang = require("./lib/lang");
            var useragent = require("./lib/useragent");
            var TextInput = require("./keyboard/textinput").TextInput;
            var MouseHandler = require("./mouse/mouse_handler").MouseHandler;
            var FoldHandler = require("./mouse/fold_handler").FoldHandler;
            var KeyBinding = require("./keyboard/keybinding").KeyBinding;
            var EditSession = require("./edit_session").EditSession;
            var Search = require("./search").Search;
            var Range = require("./range").Range;
            var EventEmitter = require("./lib/event_emitter").EventEmitter;
            var CommandManager = require("./commands/command_manager").CommandManager;
            var defaultCommands = require("./commands/default_commands").commands;
            var config = require("./config");
            var TokenIterator = require("./token_iterator").TokenIterator;
            var Editor = function (renderer, session) {
                var container = renderer.getContainerElement();
                this.container = container;
                this.renderer = renderer;

                this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
                this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
                this.renderer.textarea = this.textInput.getElement();
                this.keyBinding = new KeyBinding(this);
                this.$mouseHandler = new MouseHandler(this);
                new FoldHandler(this);

                this.$blockScrolling = 0;
                this.$search = new Search().set({
                    wrap: true
                });

                this.$historyTracker = this.$historyTracker.bind(this);
                this.commands.on("exec", this.$historyTracker);

                this.$initOperationListeners();

                this._$emitInputEvent = lang.delayedCall(function () {
                    this._signal("input", {});
                    if (this.session && this.session.bgTokenizer) this.session.bgTokenizer.scheduleStart();
                }.bind(this));

                this.on("change", function (_, _self) {
                    _self._$emitInputEvent.schedule(31);
                });

                this.setSession(session || new EditSession(""));
                config.resetOptions(this);
                config._signal("editor", this);
            };

            (function () {

                oop.implement(this, EventEmitter);

                this.$initOperationListeners = function () {
                    function last(a) {
                        return a[a.length - 1];
                    }

                    this.selections = [];
                    this.commands.on("exec", this.startOperation.bind(this), true);
                    this.commands.on("afterExec", this.endOperation.bind(this), true);

                    this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this));

                    this.on("change", function () {
                        this.curOp || this.startOperation();
                        this.curOp.docChanged = true;
                    }.bind(this), true);

                    this.on("changeSelection", function () {
                        this.curOp || this.startOperation();
                        this.curOp.selectionChanged = true;
                    }.bind(this), true);
                };

                this.curOp = null;
                this.prevOp = {};
                this.startOperation = function (commadEvent) {
                    if (this.curOp) {
                        if (!commadEvent || this.curOp.command) return;
                        this.prevOp = this.curOp;
                    }
                    if (!commadEvent) {
                        this.previousCommand = null;
                        commadEvent = {};
                    }

                    this.$opResetTimer.schedule();
                    this.curOp = {
                        command: commadEvent.command || {},
                        args: commadEvent.args,
                        scrollTop: this.renderer.scrollTop
                    };
                    if (this.curOp.command.name && this.curOp.command.scrollIntoView !== undefined) this.$blockScrolling++;
                };

                this.endOperation = function (e) {
                    if (this.curOp) {
                        if (e && e.returnValue === false) return this.curOp = null;
                        this._signal("beforeEndOperation");
                        var command = this.curOp.command;
                        if (command.name && this.$blockScrolling > 0) this.$blockScrolling--;
                        var scrollIntoView = command && command.scrollIntoView;
                        if (scrollIntoView) {
                            switch (scrollIntoView) {
                                case "center-animate":
                                    scrollIntoView = "animate";
                                case "center":
                                    this.renderer.scrollCursorIntoView(null, 0.5);
                                    break;
                                case "animate":
                                case "cursor":
                                    this.renderer.scrollCursorIntoView();
                                    break;
                                case "selectionPart":
                                    var range = this.selection.getRange();
                                    var config = this.renderer.layerConfig;
                                    if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
                                        this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                                    }
                                    break;
                                default:
                                    break;
                            }
                            if (scrollIntoView == "animate") this.renderer.animateScrolling(this.curOp.scrollTop);
                        }

                        this.prevOp = this.curOp;
                        this.curOp = null;
                    }
                };
                this.$mergeableCommands = ["backspace", "del", "insertstring"];
                this.$historyTracker = function (e) {
                    if (!this.$mergeUndoDeltas) return;

                    var prev = this.prevOp;
                    var mergeableCommands = this.$mergeableCommands;
                    var shouldMerge = prev.command && e.command.name == prev.command.name;
                    if (e.command.name == "insertstring") {
                        var text = e.args;
                        if (this.mergeNextCommand === undefined) this.mergeNextCommand = true;

                        shouldMerge = shouldMerge && this.mergeNextCommand // previous command allows to coalesce with
                        && (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type

                        this.mergeNextCommand = true;
                    } else {
                        shouldMerge = shouldMerge && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
                    }

                    if (this.$mergeUndoDeltas != "always" && Date.now() - this.sequenceStartTime > 2000) {
                        shouldMerge = false; // the sequence is too long
                    }

                    if (shouldMerge) this.session.mergeUndoDeltas = true;else if (mergeableCommands.indexOf(e.command.name) !== -1) this.sequenceStartTime = Date.now();
                };
                this.setKeyboardHandler = function (keyboardHandler, cb) {
                    if (keyboardHandler && typeof keyboardHandler === "string") {
                        this.$keybindingId = keyboardHandler;
                        var _self = this;
                        config.loadModule(["keybinding", keyboardHandler], function (module) {
                            if (_self.$keybindingId == keyboardHandler) _self.keyBinding.setKeyboardHandler(module && module.handler);
                            cb && cb();
                        });
                    } else {
                        this.$keybindingId = null;
                        this.keyBinding.setKeyboardHandler(keyboardHandler);
                        cb && cb();
                    }
                };
                this.getKeyboardHandler = function () {
                    return this.keyBinding.getKeyboardHandler();
                };
                this.setSession = function (session) {
                    if (this.session == session) return;
                    if (this.curOp) this.endOperation();
                    this.curOp = {};

                    var oldSession = this.session;
                    if (oldSession) {
                        this.session.off("change", this.$onDocumentChange);
                        this.session.off("changeMode", this.$onChangeMode);
                        this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
                        this.session.off("changeTabSize", this.$onChangeTabSize);
                        this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
                        this.session.off("changeWrapMode", this.$onChangeWrapMode);
                        this.session.off("changeFold", this.$onChangeFold);
                        this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
                        this.session.off("changeBackMarker", this.$onChangeBackMarker);
                        this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
                        this.session.off("changeAnnotation", this.$onChangeAnnotation);
                        this.session.off("changeOverwrite", this.$onCursorChange);
                        this.session.off("changeScrollTop", this.$onScrollTopChange);
                        this.session.off("changeScrollLeft", this.$onScrollLeftChange);

                        var selection = this.session.getSelection();
                        selection.off("changeCursor", this.$onCursorChange);
                        selection.off("changeSelection", this.$onSelectionChange);
                    }

                    this.session = session;
                    if (session) {
                        this.$onDocumentChange = this.onDocumentChange.bind(this);
                        session.on("change", this.$onDocumentChange);
                        this.renderer.setSession(session);

                        this.$onChangeMode = this.onChangeMode.bind(this);
                        session.on("changeMode", this.$onChangeMode);

                        this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
                        session.on("tokenizerUpdate", this.$onTokenizerUpdate);

                        this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
                        session.on("changeTabSize", this.$onChangeTabSize);

                        this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
                        session.on("changeWrapLimit", this.$onChangeWrapLimit);

                        this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
                        session.on("changeWrapMode", this.$onChangeWrapMode);

                        this.$onChangeFold = this.onChangeFold.bind(this);
                        session.on("changeFold", this.$onChangeFold);

                        this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
                        this.session.on("changeFrontMarker", this.$onChangeFrontMarker);

                        this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
                        this.session.on("changeBackMarker", this.$onChangeBackMarker);

                        this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
                        this.session.on("changeBreakpoint", this.$onChangeBreakpoint);

                        this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
                        this.session.on("changeAnnotation", this.$onChangeAnnotation);

                        this.$onCursorChange = this.onCursorChange.bind(this);
                        this.session.on("changeOverwrite", this.$onCursorChange);

                        this.$onScrollTopChange = this.onScrollTopChange.bind(this);
                        this.session.on("changeScrollTop", this.$onScrollTopChange);

                        this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
                        this.session.on("changeScrollLeft", this.$onScrollLeftChange);

                        this.selection = session.getSelection();
                        this.selection.on("changeCursor", this.$onCursorChange);

                        this.$onSelectionChange = this.onSelectionChange.bind(this);
                        this.selection.on("changeSelection", this.$onSelectionChange);

                        this.onChangeMode();

                        this.$blockScrolling += 1;
                        this.onCursorChange();
                        this.$blockScrolling -= 1;

                        this.onScrollTopChange();
                        this.onScrollLeftChange();
                        this.onSelectionChange();
                        this.onChangeFrontMarker();
                        this.onChangeBackMarker();
                        this.onChangeBreakpoint();
                        this.onChangeAnnotation();
                        this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
                        this.renderer.updateFull();
                    } else {
                        this.selection = null;
                        this.renderer.setSession(session);
                    }

                    this._signal("changeSession", {
                        session: session,
                        oldSession: oldSession
                    });

                    this.curOp = null;

                    oldSession && oldSession._signal("changeEditor", { oldEditor: this });
                    session && session._signal("changeEditor", { editor: this });
                };
                this.getSession = function () {
                    return this.session;
                };
                this.setValue = function (val, cursorPos) {
                    this.session.doc.setValue(val);

                    if (!cursorPos) this.selectAll();else if (cursorPos == 1) this.navigateFileEnd();else if (cursorPos == -1) this.navigateFileStart();

                    return val;
                };
                this.getValue = function () {
                    return this.session.getValue();
                };
                this.getSelection = function () {
                    return this.selection;
                };
                this.resize = function (force) {
                    this.renderer.onResize(force);
                };
                this.setTheme = function (theme, cb) {
                    this.renderer.setTheme(theme, cb);
                };
                this.getTheme = function () {
                    return this.renderer.getTheme();
                };
                this.setStyle = function (style) {
                    this.renderer.setStyle(style);
                };
                this.unsetStyle = function (style) {
                    this.renderer.unsetStyle(style);
                };
                this.getFontSize = function () {
                    return this.getOption("fontSize") || dom.computedStyle(this.container, "fontSize");
                };
                this.setFontSize = function (size) {
                    this.setOption("fontSize", size);
                };

                this.$highlightBrackets = function () {
                    if (this.session.$bracketHighlight) {
                        this.session.removeMarker(this.session.$bracketHighlight);
                        this.session.$bracketHighlight = null;
                    }

                    if (this.$highlightPending) {
                        return;
                    }
                    var self = this;
                    this.$highlightPending = true;
                    setTimeout(function () {
                        self.$highlightPending = false;
                        var session = self.session;
                        if (!session || !session.bgTokenizer) return;
                        var pos = session.findMatchingBracket(self.getCursorPosition());
                        if (pos) {
                            var range = new Range(pos.row, pos.column, pos.row, pos.column + 1);
                        } else if (session.$mode.getMatching) {
                            var range = session.$mode.getMatching(self.session);
                        }
                        if (range) session.$bracketHighlight = session.addMarker(range, "ace_bracket", "text");
                    }, 50);
                };
                this.$highlightTags = function () {
                    if (this.$highlightTagPending) return;
                    var self = this;
                    this.$highlightTagPending = true;
                    setTimeout(function () {
                        self.$highlightTagPending = false;

                        var session = self.session;
                        if (!session || !session.bgTokenizer) return;

                        var pos = self.getCursorPosition();
                        var iterator = new TokenIterator(self.session, pos.row, pos.column);
                        var token = iterator.getCurrentToken();

                        if (!token || !/\b(?:tag-open|tag-name)/.test(token.type)) {
                            session.removeMarker(session.$tagHighlight);
                            session.$tagHighlight = null;
                            return;
                        }

                        if (token.type.indexOf("tag-open") != -1) {
                            token = iterator.stepForward();
                            if (!token) return;
                        }

                        var tag = token.value;
                        var depth = 0;
                        var prevToken = iterator.stepBackward();

                        if (prevToken.value == '<') {
                            do {
                                prevToken = token;
                                token = iterator.stepForward();

                                if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                                    if (prevToken.value === '<') {
                                        depth++;
                                    } else if (prevToken.value === '</') {
                                        depth--;
                                    }
                                }
                            } while (token && depth >= 0);
                        } else {
                            do {
                                token = prevToken;
                                prevToken = iterator.stepBackward();

                                if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                                    if (prevToken.value === '<') {
                                        depth++;
                                    } else if (prevToken.value === '</') {
                                        depth--;
                                    }
                                }
                            } while (prevToken && depth <= 0);
                            iterator.stepForward();
                        }

                        if (!token) {
                            session.removeMarker(session.$tagHighlight);
                            session.$tagHighlight = null;
                            return;
                        }

                        var row = iterator.getCurrentTokenRow();
                        var column = iterator.getCurrentTokenColumn();
                        var range = new Range(row, column, row, column + token.value.length);
                        var sbm = session.$backMarkers[session.$tagHighlight];
                        if (session.$tagHighlight && sbm != undefined && range.compareRange(sbm.range) !== 0) {
                            session.removeMarker(session.$tagHighlight);
                            session.$tagHighlight = null;
                        }

                        if (range && !session.$tagHighlight) session.$tagHighlight = session.addMarker(range, "ace_bracket", "text");
                    }, 50);
                };
                this.focus = function () {
                    var _self = this;
                    setTimeout(function () {
                        _self.textInput.focus();
                    });
                    this.textInput.focus();
                };
                this.isFocused = function () {
                    return this.textInput.isFocused();
                };
                this.blur = function () {
                    this.textInput.blur();
                };
                this.onFocus = function (e) {
                    if (this.$isFocused) return;
                    this.$isFocused = true;
                    this.renderer.showCursor();
                    this.renderer.visualizeFocus();
                    this._emit("focus", e);
                };
                this.onBlur = function (e) {
                    if (!this.$isFocused) return;
                    this.$isFocused = false;
                    this.renderer.hideCursor();
                    this.renderer.visualizeBlur();
                    this._emit("blur", e);
                };

                this.$cursorChange = function () {
                    this.renderer.updateCursor();
                };
                this.onDocumentChange = function (delta) {
                    var wrap = this.session.$useWrapMode;
                    var lastRow = delta.start.row == delta.end.row ? delta.end.row : Infinity;
                    this.renderer.updateLines(delta.start.row, lastRow, wrap);

                    this._signal("change", delta);
                    this.$cursorChange();
                    this.$updateHighlightActiveLine();
                };

                this.onTokenizerUpdate = function (e) {
                    var rows = e.data;
                    this.renderer.updateLines(rows.first, rows.last);
                };

                this.onScrollTopChange = function () {
                    this.renderer.scrollToY(this.session.getScrollTop());
                };

                this.onScrollLeftChange = function () {
                    this.renderer.scrollToX(this.session.getScrollLeft());
                };
                this.onCursorChange = function () {
                    this.$cursorChange();

                    if (!this.$blockScrolling) {
                        config.warn("Automatically scrolling cursor into view after selection change", "this will be disabled in the next version", "set editor.$blockScrolling = Infinity to disable this message");
                        this.renderer.scrollCursorIntoView();
                    }

                    this.$highlightBrackets();
                    this.$highlightTags();
                    this.$updateHighlightActiveLine();
                    this._signal("changeSelection");
                };

                this.$updateHighlightActiveLine = function () {
                    var session = this.getSession();

                    var highlight;
                    if (this.$highlightActiveLine) {
                        if (this.$selectionStyle != "line" || !this.selection.isMultiLine()) highlight = this.getCursorPosition();
                        if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1)) highlight = false;
                    }

                    if (session.$highlightLineMarker && !highlight) {
                        session.removeMarker(session.$highlightLineMarker.id);
                        session.$highlightLineMarker = null;
                    } else if (!session.$highlightLineMarker && highlight) {
                        var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
                        range.id = session.addMarker(range, "ace_active-line", "screenLine");
                        session.$highlightLineMarker = range;
                    } else if (highlight) {
                        session.$highlightLineMarker.start.row = highlight.row;
                        session.$highlightLineMarker.end.row = highlight.row;
                        session.$highlightLineMarker.start.column = highlight.column;
                        session._signal("changeBackMarker");
                    }
                };

                this.onSelectionChange = function (e) {
                    var session = this.session;

                    if (session.$selectionMarker) {
                        session.removeMarker(session.$selectionMarker);
                    }
                    session.$selectionMarker = null;

                    if (!this.selection.isEmpty()) {
                        var range = this.selection.getRange();
                        var style = this.getSelectionStyle();
                        session.$selectionMarker = session.addMarker(range, "ace_selection", style);
                    } else {
                        this.$updateHighlightActiveLine();
                    }

                    var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
                    this.session.highlight(re);

                    this._signal("changeSelection");
                };

                this.$getSelectionHighLightRegexp = function () {
                    var session = this.session;

                    var selection = this.getSelectionRange();
                    if (selection.isEmpty() || selection.isMultiLine()) return;

                    var startOuter = selection.start.column - 1;
                    var endOuter = selection.end.column + 1;
                    var line = session.getLine(selection.start.row);
                    var lineCols = line.length;
                    var needle = line.substring(Math.max(startOuter, 0), Math.min(endOuter, lineCols));
                    if (startOuter >= 0 && /^[\w\d]/.test(needle) || endOuter <= lineCols && /[\w\d]$/.test(needle)) return;

                    needle = line.substring(selection.start.column, selection.end.column);
                    if (!/^[\w\d]+$/.test(needle)) return;

                    var re = this.$search.$assembleRegExp({
                        wholeWord: true,
                        caseSensitive: true,
                        needle: needle
                    });

                    return re;
                };

                this.onChangeFrontMarker = function () {
                    this.renderer.updateFrontMarkers();
                };

                this.onChangeBackMarker = function () {
                    this.renderer.updateBackMarkers();
                };

                this.onChangeBreakpoint = function () {
                    this.renderer.updateBreakpoints();
                };

                this.onChangeAnnotation = function () {
                    this.renderer.setAnnotations(this.session.getAnnotations());
                };

                this.onChangeMode = function (e) {
                    this.renderer.updateText();
                    this._emit("changeMode", e);
                };

                this.onChangeWrapLimit = function () {
                    this.renderer.updateFull();
                };

                this.onChangeWrapMode = function () {
                    this.renderer.onResize(true);
                };

                this.onChangeFold = function () {
                    this.$updateHighlightActiveLine();
                    this.renderer.updateFull();
                };
                this.getSelectedText = function () {
                    return this.session.getTextRange(this.getSelectionRange());
                };
                this.getCopyText = function () {
                    var text = this.getSelectedText();
                    this._signal("copy", text);
                    return text;
                };
                this.onCopy = function () {
                    this.commands.exec("copy", this);
                };
                this.onCut = function () {
                    this.commands.exec("cut", this);
                };
                this.onPaste = function (text, event) {
                    var e = { text: text, event: event };
                    this.commands.exec("paste", this, e);
                };

                this.$handlePaste = function (e) {
                    if (typeof e == "string") e = { text: e };
                    this._signal("paste", e);
                    var text = e.text;
                    if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
                        this.insert(text);
                    } else {
                        var lines = text.split(/\r\n|\r|\n/);
                        var ranges = this.selection.rangeList.ranges;

                        if (lines.length > ranges.length || lines.length < 2 || !lines[1]) return this.commands.exec("insertstring", this, text);

                        for (var i = ranges.length; i--;) {
                            var range = ranges[i];
                            if (!range.isEmpty()) this.session.remove(range);

                            this.session.insert(range.start, lines[i]);
                        }
                    }
                };

                this.execCommand = function (command, args) {
                    return this.commands.exec(command, this, args);
                };
                this.insert = function (text, pasted) {
                    var session = this.session;
                    var mode = session.getMode();
                    var cursor = this.getCursorPosition();

                    if (this.getBehavioursEnabled() && !pasted) {
                        var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
                        if (transform) {
                            if (text !== transform.text) {
                                this.session.mergeUndoDeltas = false;
                                this.$mergeNextCommand = false;
                            }
                            text = transform.text;
                        }
                    }

                    if (text == "\t") text = this.session.getTabString();
                    if (!this.selection.isEmpty()) {
                        var range = this.getSelectionRange();
                        cursor = this.session.remove(range);
                        this.clearSelection();
                    } else if (this.session.getOverwrite()) {
                        var range = new Range.fromPoints(cursor, cursor);
                        range.end.column += text.length;
                        this.session.remove(range);
                    }

                    if (text == "\n" || text == "\r\n") {
                        var line = session.getLine(cursor.row);
                        if (cursor.column > line.search(/\S|$/)) {
                            var d = line.substr(cursor.column).search(/\S|$/);
                            session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
                        }
                    }
                    this.clearSelection();

                    var start = cursor.column;
                    var lineState = session.getState(cursor.row);
                    var line = session.getLine(cursor.row);
                    var shouldOutdent = mode.checkOutdent(lineState, line, text);
                    var end = session.insert(cursor, text);

                    if (transform && transform.selection) {
                        if (transform.selection.length == 2) {
                            // Transform relative to the current column
                            this.selection.setSelectionRange(new Range(cursor.row, start + transform.selection[0], cursor.row, start + transform.selection[1]));
                        } else {
                            // Transform relative to the current row.
                            this.selection.setSelectionRange(new Range(cursor.row + transform.selection[0], transform.selection[1], cursor.row + transform.selection[2], transform.selection[3]));
                        }
                    }

                    if (session.getDocument().isNewLine(text)) {
                        var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());

                        session.insert({ row: cursor.row + 1, column: 0 }, lineIndent);
                    }
                    if (shouldOutdent) mode.autoOutdent(lineState, session, cursor.row);
                };

                this.onTextInput = function (text) {
                    this.keyBinding.onTextInput(text);
                };

                this.onCommandKey = function (e, hashId, keyCode) {
                    this.keyBinding.onCommandKey(e, hashId, keyCode);
                };
                this.setOverwrite = function (overwrite) {
                    this.session.setOverwrite(overwrite);
                };
                this.getOverwrite = function () {
                    return this.session.getOverwrite();
                };
                this.toggleOverwrite = function () {
                    this.session.toggleOverwrite();
                };
                this.setScrollSpeed = function (speed) {
                    this.setOption("scrollSpeed", speed);
                };
                this.getScrollSpeed = function () {
                    return this.getOption("scrollSpeed");
                };
                this.setDragDelay = function (dragDelay) {
                    this.setOption("dragDelay", dragDelay);
                };
                this.getDragDelay = function () {
                    return this.getOption("dragDelay");
                };
                this.setSelectionStyle = function (val) {
                    this.setOption("selectionStyle", val);
                };
                this.getSelectionStyle = function () {
                    return this.getOption("selectionStyle");
                };
                this.setHighlightActiveLine = function (shouldHighlight) {
                    this.setOption("highlightActiveLine", shouldHighlight);
                };
                this.getHighlightActiveLine = function () {
                    return this.getOption("highlightActiveLine");
                };
                this.setHighlightGutterLine = function (shouldHighlight) {
                    this.setOption("highlightGutterLine", shouldHighlight);
                };

                this.getHighlightGutterLine = function () {
                    return this.getOption("highlightGutterLine");
                };
                this.setHighlightSelectedWord = function (shouldHighlight) {
                    this.setOption("highlightSelectedWord", shouldHighlight);
                };
                this.getHighlightSelectedWord = function () {
                    return this.$highlightSelectedWord;
                };

                this.setAnimatedScroll = function (shouldAnimate) {
                    this.renderer.setAnimatedScroll(shouldAnimate);
                };

                this.getAnimatedScroll = function () {
                    return this.renderer.getAnimatedScroll();
                };
                this.setShowInvisibles = function (showInvisibles) {
                    this.renderer.setShowInvisibles(showInvisibles);
                };
                this.getShowInvisibles = function () {
                    return this.renderer.getShowInvisibles();
                };

                this.setDisplayIndentGuides = function (display) {
                    this.renderer.setDisplayIndentGuides(display);
                };

                this.getDisplayIndentGuides = function () {
                    return this.renderer.getDisplayIndentGuides();
                };
                this.setShowPrintMargin = function (showPrintMargin) {
                    this.renderer.setShowPrintMargin(showPrintMargin);
                };
                this.getShowPrintMargin = function () {
                    return this.renderer.getShowPrintMargin();
                };
                this.setPrintMarginColumn = function (showPrintMargin) {
                    this.renderer.setPrintMarginColumn(showPrintMargin);
                };
                this.getPrintMarginColumn = function () {
                    return this.renderer.getPrintMarginColumn();
                };
                this.setReadOnly = function (readOnly) {
                    this.setOption("readOnly", readOnly);
                };
                this.getReadOnly = function () {
                    return this.getOption("readOnly");
                };
                this.setBehavioursEnabled = function (enabled) {
                    this.setOption("behavioursEnabled", enabled);
                };
                this.getBehavioursEnabled = function () {
                    return this.getOption("behavioursEnabled");
                };
                this.setWrapBehavioursEnabled = function (enabled) {
                    this.setOption("wrapBehavioursEnabled", enabled);
                };
                this.getWrapBehavioursEnabled = function () {
                    return this.getOption("wrapBehavioursEnabled");
                };
                this.setShowFoldWidgets = function (show) {
                    this.setOption("showFoldWidgets", show);
                };
                this.getShowFoldWidgets = function () {
                    return this.getOption("showFoldWidgets");
                };

                this.setFadeFoldWidgets = function (fade) {
                    this.setOption("fadeFoldWidgets", fade);
                };

                this.getFadeFoldWidgets = function () {
                    return this.getOption("fadeFoldWidgets");
                };
                this.remove = function (dir) {
                    if (this.selection.isEmpty()) {
                        if (dir == "left") this.selection.selectLeft();else this.selection.selectRight();
                    }

                    var range = this.getSelectionRange();
                    if (this.getBehavioursEnabled()) {
                        var session = this.session;
                        var state = session.getState(range.start.row);
                        var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);

                        if (range.end.column === 0) {
                            var text = session.getTextRange(range);
                            if (text[text.length - 1] == "\n") {
                                var line = session.getLine(range.end.row);
                                if (/^\s+$/.test(line)) {
                                    range.end.column = line.length;
                                }
                            }
                        }
                        if (new_range) range = new_range;
                    }

                    this.session.remove(range);
                    this.clearSelection();
                };
                this.removeWordRight = function () {
                    if (this.selection.isEmpty()) this.selection.selectWordRight();

                    this.session.remove(this.getSelectionRange());
                    this.clearSelection();
                };
                this.removeWordLeft = function () {
                    if (this.selection.isEmpty()) this.selection.selectWordLeft();

                    this.session.remove(this.getSelectionRange());
                    this.clearSelection();
                };
                this.removeToLineStart = function () {
                    if (this.selection.isEmpty()) this.selection.selectLineStart();

                    this.session.remove(this.getSelectionRange());
                    this.clearSelection();
                };
                this.removeToLineEnd = function () {
                    if (this.selection.isEmpty()) this.selection.selectLineEnd();

                    var range = this.getSelectionRange();
                    if (range.start.column == range.end.column && range.start.row == range.end.row) {
                        range.end.column = 0;
                        range.end.row++;
                    }

                    this.session.remove(range);
                    this.clearSelection();
                };
                this.splitLine = function () {
                    if (!this.selection.isEmpty()) {
                        this.session.remove(this.getSelectionRange());
                        this.clearSelection();
                    }

                    var cursor = this.getCursorPosition();
                    this.insert("\n");
                    this.moveCursorToPosition(cursor);
                };
                this.transposeLetters = function () {
                    if (!this.selection.isEmpty()) {
                        return;
                    }

                    var cursor = this.getCursorPosition();
                    var column = cursor.column;
                    if (column === 0) return;

                    var line = this.session.getLine(cursor.row);
                    var swap, range;
                    if (column < line.length) {
                        swap = line.charAt(column) + line.charAt(column - 1);
                        range = new Range(cursor.row, column - 1, cursor.row, column + 1);
                    } else {
                        swap = line.charAt(column - 1) + line.charAt(column - 2);
                        range = new Range(cursor.row, column - 2, cursor.row, column);
                    }
                    this.session.replace(range, swap);
                };
                this.toLowerCase = function () {
                    var originalRange = this.getSelectionRange();
                    if (this.selection.isEmpty()) {
                        this.selection.selectWord();
                    }

                    var range = this.getSelectionRange();
                    var text = this.session.getTextRange(range);
                    this.session.replace(range, text.toLowerCase());
                    this.selection.setSelectionRange(originalRange);
                };
                this.toUpperCase = function () {
                    var originalRange = this.getSelectionRange();
                    if (this.selection.isEmpty()) {
                        this.selection.selectWord();
                    }

                    var range = this.getSelectionRange();
                    var text = this.session.getTextRange(range);
                    this.session.replace(range, text.toUpperCase());
                    this.selection.setSelectionRange(originalRange);
                };
                this.indent = function () {
                    var session = this.session;
                    var range = this.getSelectionRange();

                    if (range.start.row < range.end.row) {
                        var rows = this.$getSelectedRows();
                        session.indentRows(rows.first, rows.last, "\t");
                        return;
                    } else if (range.start.column < range.end.column) {
                        var text = session.getTextRange(range);
                        if (!/^\s+$/.test(text)) {
                            var rows = this.$getSelectedRows();
                            session.indentRows(rows.first, rows.last, "\t");
                            return;
                        }
                    }

                    var line = session.getLine(range.start.row);
                    var position = range.start;
                    var size = session.getTabSize();
                    var column = session.documentToScreenColumn(position.row, position.column);

                    if (this.session.getUseSoftTabs()) {
                        var count = size - column % size;
                        var indentString = lang.stringRepeat(" ", count);
                    } else {
                        var count = column % size;
                        while (line[range.start.column - 1] == " " && count) {
                            range.start.column--;
                            count--;
                        }
                        this.selection.setSelectionRange(range);
                        indentString = "\t";
                    }
                    return this.insert(indentString);
                };
                this.blockIndent = function () {
                    var rows = this.$getSelectedRows();
                    this.session.indentRows(rows.first, rows.last, "\t");
                };
                this.blockOutdent = function () {
                    var selection = this.session.getSelection();
                    this.session.outdentRows(selection.getRange());
                };
                this.sortLines = function () {
                    var rows = this.$getSelectedRows();
                    var session = this.session;

                    var lines = [];
                    for (i = rows.first; i <= rows.last; i++) lines.push(session.getLine(i));

                    lines.sort(function (a, b) {
                        if (a.toLowerCase() < b.toLowerCase()) return -1;
                        if (a.toLowerCase() > b.toLowerCase()) return 1;
                        return 0;
                    });

                    var deleteRange = new Range(0, 0, 0, 0);
                    for (var i = rows.first; i <= rows.last; i++) {
                        var line = session.getLine(i);
                        deleteRange.start.row = i;
                        deleteRange.end.row = i;
                        deleteRange.end.column = line.length;
                        session.replace(deleteRange, lines[i - rows.first]);
                    }
                };
                this.toggleCommentLines = function () {
                    var state = this.session.getState(this.getCursorPosition().row);
                    var rows = this.$getSelectedRows();
                    this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
                };

                this.toggleBlockComment = function () {
                    var cursor = this.getCursorPosition();
                    var state = this.session.getState(cursor.row);
                    var range = this.getSelectionRange();
                    this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
                };
                this.getNumberAt = function (row, column) {
                    var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
                    _numberRx.lastIndex = 0;

                    var s = this.session.getLine(row);
                    while (_numberRx.lastIndex < column) {
                        var m = _numberRx.exec(s);
                        if (m.index <= column && m.index + m[0].length >= column) {
                            var number = {
                                value: m[0],
                                start: m.index,
                                end: m.index + m[0].length
                            };
                            return number;
                        }
                    }
                    return null;
                };
                this.modifyNumber = function (amount) {
                    var row = this.selection.getCursor().row;
                    var column = this.selection.getCursor().column;
                    var charRange = new Range(row, column - 1, row, column);

                    var c = this.session.getTextRange(charRange);
                    if (!isNaN(parseFloat(c)) && isFinite(c)) {
                        var nr = this.getNumberAt(row, column);
                        if (nr) {
                            var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
                            var decimals = nr.start + nr.value.length - fp;

                            var t = parseFloat(nr.value);
                            t *= Math.pow(10, decimals);

                            if (fp !== nr.end && column < fp) {
                                amount *= Math.pow(10, nr.end - column - 1);
                            } else {
                                amount *= Math.pow(10, nr.end - column);
                            }

                            t += amount;
                            t /= Math.pow(10, decimals);
                            var nnr = t.toFixed(decimals);
                            var replaceRange = new Range(row, nr.start, row, nr.end);
                            this.session.replace(replaceRange, nnr);
                            this.moveCursorTo(row, Math.max(nr.start + 1, column + nnr.length - nr.value.length));
                        }
                    }
                };
                this.removeLines = function () {
                    var rows = this.$getSelectedRows();
                    this.session.removeFullLines(rows.first, rows.last);
                    this.clearSelection();
                };

                this.duplicateSelection = function () {
                    var sel = this.selection;
                    var doc = this.session;
                    var range = sel.getRange();
                    var reverse = sel.isBackwards();
                    if (range.isEmpty()) {
                        var row = range.start.row;
                        doc.duplicateLines(row, row);
                    } else {
                        var point = reverse ? range.start : range.end;
                        var endPoint = doc.insert(point, doc.getTextRange(range), false);
                        range.start = point;
                        range.end = endPoint;

                        sel.setSelectionRange(range, reverse);
                    }
                };
                this.moveLinesDown = function () {
                    this.$moveLines(1, false);
                };
                this.moveLinesUp = function () {
                    this.$moveLines(-1, false);
                };
                this.moveText = function (range, toPosition, copy) {
                    return this.session.moveText(range, toPosition, copy);
                };
                this.copyLinesUp = function () {
                    this.$moveLines(-1, true);
                };
                this.copyLinesDown = function () {
                    this.$moveLines(1, true);
                };
                this.$moveLines = function (dir, copy) {
                    var rows, moved;
                    var selection = this.selection;
                    if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
                        var range = selection.toOrientedRange();
                        rows = this.$getSelectedRows(range);
                        moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
                        if (copy && dir == -1) moved = 0;
                        range.moveBy(moved, 0);
                        selection.fromOrientedRange(range);
                    } else {
                        var ranges = selection.rangeList.ranges;
                        selection.rangeList.detach(this.session);
                        this.inVirtualSelectionMode = true;

                        var diff = 0;
                        var totalDiff = 0;
                        var l = ranges.length;
                        for (var i = 0; i < l; i++) {
                            var rangeIndex = i;
                            ranges[i].moveBy(diff, 0);
                            rows = this.$getSelectedRows(ranges[i]);
                            var first = rows.first;
                            var last = rows.last;
                            while (++i < l) {
                                if (totalDiff) ranges[i].moveBy(totalDiff, 0);
                                var subRows = this.$getSelectedRows(ranges[i]);
                                if (copy && subRows.first != last) break;else if (!copy && subRows.first > last + 1) break;
                                last = subRows.last;
                            }
                            i--;
                            diff = this.session.$moveLines(first, last, copy ? 0 : dir);
                            if (copy && dir == -1) rangeIndex = i + 1;
                            while (rangeIndex <= i) {
                                ranges[rangeIndex].moveBy(diff, 0);
                                rangeIndex++;
                            }
                            if (!copy) diff = 0;
                            totalDiff += diff;
                        }

                        selection.fromOrientedRange(selection.ranges[0]);
                        selection.rangeList.attach(this.session);
                        this.inVirtualSelectionMode = false;
                    }
                };
                this.$getSelectedRows = function (range) {
                    range = (range || this.getSelectionRange()).collapseRows();

                    return {
                        first: this.session.getRowFoldStart(range.start.row),
                        last: this.session.getRowFoldEnd(range.end.row)
                    };
                };

                this.onCompositionStart = function (text) {
                    this.renderer.showComposition(this.getCursorPosition());
                };

                this.onCompositionUpdate = function (text) {
                    this.renderer.setCompositionText(text);
                };

                this.onCompositionEnd = function () {
                    this.renderer.hideComposition();
                };
                this.getFirstVisibleRow = function () {
                    return this.renderer.getFirstVisibleRow();
                };
                this.getLastVisibleRow = function () {
                    return this.renderer.getLastVisibleRow();
                };
                this.isRowVisible = function (row) {
                    return row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow();
                };
                this.isRowFullyVisible = function (row) {
                    return row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow();
                };
                this.$getVisibleRowCount = function () {
                    return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
                };

                this.$moveByPage = function (dir, select) {
                    var renderer = this.renderer;
                    var config = this.renderer.layerConfig;
                    var rows = dir * Math.floor(config.height / config.lineHeight);

                    this.$blockScrolling++;
                    if (select === true) {
                        this.selection.$moveSelection(function () {
                            this.moveCursorBy(rows, 0);
                        });
                    } else if (select === false) {
                        this.selection.moveCursorBy(rows, 0);
                        this.selection.clearSelection();
                    }
                    this.$blockScrolling--;

                    var scrollTop = renderer.scrollTop;

                    renderer.scrollBy(0, rows * config.lineHeight);
                    if (select != null) renderer.scrollCursorIntoView(null, 0.5);

                    renderer.animateScrolling(scrollTop);
                };
                this.selectPageDown = function () {
                    this.$moveByPage(1, true);
                };
                this.selectPageUp = function () {
                    this.$moveByPage(-1, true);
                };
                this.gotoPageDown = function () {
                    this.$moveByPage(1, false);
                };
                this.gotoPageUp = function () {
                    this.$moveByPage(-1, false);
                };
                this.scrollPageDown = function () {
                    this.$moveByPage(1);
                };
                this.scrollPageUp = function () {
                    this.$moveByPage(-1);
                };
                this.scrollToRow = function (row) {
                    this.renderer.scrollToRow(row);
                };
                this.scrollToLine = function (line, center, animate, callback) {
                    this.renderer.scrollToLine(line, center, animate, callback);
                };
                this.centerSelection = function () {
                    var range = this.getSelectionRange();
                    var pos = {
                        row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
                        column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
                    };
                    this.renderer.alignCursor(pos, 0.5);
                };
                this.getCursorPosition = function () {
                    return this.selection.getCursor();
                };
                this.getCursorPositionScreen = function () {
                    return this.session.documentToScreenPosition(this.getCursorPosition());
                };
                this.getSelectionRange = function () {
                    return this.selection.getRange();
                };
                this.selectAll = function () {
                    this.$blockScrolling += 1;
                    this.selection.selectAll();
                    this.$blockScrolling -= 1;
                };
                this.clearSelection = function () {
                    this.selection.clearSelection();
                };
                this.moveCursorTo = function (row, column) {
                    this.selection.moveCursorTo(row, column);
                };
                this.moveCursorToPosition = function (pos) {
                    this.selection.moveCursorToPosition(pos);
                };
                this.jumpToMatching = function (select, expand) {
                    var cursor = this.getCursorPosition();
                    var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
                    var prevToken = iterator.getCurrentToken();
                    var token = prevToken || iterator.stepForward();

                    if (!token) return;
                    var matchType;
                    var found = false;
                    var depth = {};
                    var i = cursor.column - token.start;
                    var bracketType;
                    var brackets = {
                        ")": "(",
                        "(": "(",
                        "]": "[",
                        "[": "[",
                        "{": "{",
                        "}": "{"
                    };

                    do {
                        if (token.value.match(/[{}()\[\]]/g)) {
                            for (; i < token.value.length && !found; i++) {
                                if (!brackets[token.value[i]]) {
                                    continue;
                                }

                                bracketType = brackets[token.value[i]] + '.' + token.type.replace("rparen", "lparen");

                                if (isNaN(depth[bracketType])) {
                                    depth[bracketType] = 0;
                                }

                                switch (token.value[i]) {
                                    case '(':
                                    case '[':
                                    case '{':
                                        depth[bracketType]++;
                                        break;
                                    case ')':
                                    case ']':
                                    case '}':
                                        depth[bracketType]--;

                                        if (depth[bracketType] === -1) {
                                            matchType = 'bracket';
                                            found = true;
                                        }
                                        break;
                                }
                            }
                        } else if (token && token.type.indexOf('tag-name') !== -1) {
                            if (isNaN(depth[token.value])) {
                                depth[token.value] = 0;
                            }

                            if (prevToken.value === '<') {
                                depth[token.value]++;
                            } else if (prevToken.value === '</') {
                                depth[token.value]--;
                            }

                            if (depth[token.value] === -1) {
                                matchType = 'tag';
                                found = true;
                            }
                        }

                        if (!found) {
                            prevToken = token;
                            token = iterator.stepForward();
                            i = 0;
                        }
                    } while (token && !found);
                    if (!matchType) return;

                    var range, pos;
                    if (matchType === 'bracket') {
                        range = this.session.getBracketRange(cursor);
                        if (!range) {
                            range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1);
                            pos = range.start;
                            if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2) range = this.session.getBracketRange(pos);
                        }
                    } else if (matchType === 'tag') {
                        if (token && token.type.indexOf('tag-name') !== -1) var tag = token.value;else return;

                        range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2);
                        if (range.compare(cursor.row, cursor.column) === 0) {
                            found = false;
                            do {
                                token = prevToken;
                                prevToken = iterator.stepBackward();

                                if (prevToken) {
                                    if (prevToken.type.indexOf('tag-close') !== -1) {
                                        range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                                    }

                                    if (token.value === tag && token.type.indexOf('tag-name') !== -1) {
                                        if (prevToken.value === '<') {
                                            depth[tag]++;
                                        } else if (prevToken.value === '</') {
                                            depth[tag]--;
                                        }

                                        if (depth[tag] === 0) found = true;
                                    }
                                }
                            } while (prevToken && !found);
                        }
                        if (token && token.type.indexOf('tag-name')) {
                            pos = range.start;
                            if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2) pos = range.end;
                        }
                    }

                    pos = range && range.cursor || pos;
                    if (pos) {
                        if (select) {
                            if (range && expand) {
                                this.selection.setRange(range);
                            } else if (range && range.isEqual(this.getSelectionRange())) {
                                this.clearSelection();
                            } else {
                                this.selection.selectTo(pos.row, pos.column);
                            }
                        } else {
                            this.selection.moveTo(pos.row, pos.column);
                        }
                    }
                };
                this.gotoLine = function (lineNumber, column, animate) {
                    this.selection.clearSelection();
                    this.session.unfold({ row: lineNumber - 1, column: column || 0 });

                    this.$blockScrolling += 1;
                    this.exitMultiSelectMode && this.exitMultiSelectMode();
                    this.moveCursorTo(lineNumber - 1, column || 0);
                    this.$blockScrolling -= 1;

                    if (!this.isRowFullyVisible(lineNumber - 1)) this.scrollToLine(lineNumber - 1, true, animate);
                };
                this.navigateTo = function (row, column) {
                    this.selection.moveTo(row, column);
                };
                this.navigateUp = function (times) {
                    if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
                        var selectionStart = this.selection.anchor.getPosition();
                        return this.moveCursorToPosition(selectionStart);
                    }
                    this.selection.clearSelection();
                    this.selection.moveCursorBy(-times || -1, 0);
                };
                this.navigateDown = function (times) {
                    if (this.selection.isMultiLine() && this.selection.isBackwards()) {
                        var selectionEnd = this.selection.anchor.getPosition();
                        return this.moveCursorToPosition(selectionEnd);
                    }
                    this.selection.clearSelection();
                    this.selection.moveCursorBy(times || 1, 0);
                };
                this.navigateLeft = function (times) {
                    if (!this.selection.isEmpty()) {
                        var selectionStart = this.getSelectionRange().start;
                        this.moveCursorToPosition(selectionStart);
                    } else {
                        times = times || 1;
                        while (times--) {
                            this.selection.moveCursorLeft();
                        }
                    }
                    this.clearSelection();
                };
                this.navigateRight = function (times) {
                    if (!this.selection.isEmpty()) {
                        var selectionEnd = this.getSelectionRange().end;
                        this.moveCursorToPosition(selectionEnd);
                    } else {
                        times = times || 1;
                        while (times--) {
                            this.selection.moveCursorRight();
                        }
                    }
                    this.clearSelection();
                };
                this.navigateLineStart = function () {
                    this.selection.moveCursorLineStart();
                    this.clearSelection();
                };
                this.navigateLineEnd = function () {
                    this.selection.moveCursorLineEnd();
                    this.clearSelection();
                };
                this.navigateFileEnd = function () {
                    this.selection.moveCursorFileEnd();
                    this.clearSelection();
                };
                this.navigateFileStart = function () {
                    this.selection.moveCursorFileStart();
                    this.clearSelection();
                };
                this.navigateWordRight = function () {
                    this.selection.moveCursorWordRight();
                    this.clearSelection();
                };
                this.navigateWordLeft = function () {
                    this.selection.moveCursorWordLeft();
                    this.clearSelection();
                };
                this.replace = function (replacement, options) {
                    if (options) this.$search.set(options);

                    var range = this.$search.find(this.session);
                    var replaced = 0;
                    if (!range) return replaced;

                    if (this.$tryReplace(range, replacement)) {
                        replaced = 1;
                    }
                    if (range !== null) {
                        this.selection.setSelectionRange(range);
                        this.renderer.scrollSelectionIntoView(range.start, range.end);
                    }

                    return replaced;
                };
                this.replaceAll = function (replacement, options) {
                    if (options) {
                        this.$search.set(options);
                    }

                    var ranges = this.$search.findAll(this.session);
                    var replaced = 0;
                    if (!ranges.length) return replaced;

                    this.$blockScrolling += 1;

                    var selection = this.getSelectionRange();
                    this.selection.moveTo(0, 0);

                    for (var i = ranges.length - 1; i >= 0; --i) {
                        if (this.$tryReplace(ranges[i], replacement)) {
                            replaced++;
                        }
                    }

                    this.selection.setSelectionRange(selection);
                    this.$blockScrolling -= 1;

                    return replaced;
                };

                this.$tryReplace = function (range, replacement) {
                    var input = this.session.getTextRange(range);
                    replacement = this.$search.replace(input, replacement);
                    if (replacement !== null) {
                        range.end = this.session.replace(range, replacement);
                        return range;
                    } else {
                        return null;
                    }
                };
                this.getLastSearchOptions = function () {
                    return this.$search.getOptions();
                };
                this.find = function (needle, options, animate) {
                    if (!options) options = {};

                    if (typeof needle == "string" || needle instanceof RegExp) options.needle = needle;else if (typeof needle == "object") oop.mixin(options, needle);

                    var range = this.selection.getRange();
                    if (options.needle == null) {
                        needle = this.session.getTextRange(range) || this.$search.$options.needle;
                        if (!needle) {
                            range = this.session.getWordRange(range.start.row, range.start.column);
                            needle = this.session.getTextRange(range);
                        }
                        this.$search.set({ needle: needle });
                    }

                    this.$search.set(options);
                    if (!options.start) this.$search.set({ start: range });

                    var newRange = this.$search.find(this.session);
                    if (options.preventScroll) return newRange;
                    if (newRange) {
                        this.revealRange(newRange, animate);
                        return newRange;
                    }
                    if (options.backwards) range.start = range.end;else range.end = range.start;
                    this.selection.setRange(range);
                };
                this.findNext = function (options, animate) {
                    this.find({ skipCurrent: true, backwards: false }, options, animate);
                };
                this.findPrevious = function (options, animate) {
                    this.find(options, { skipCurrent: true, backwards: true }, animate);
                };

                this.revealRange = function (range, animate) {
                    this.$blockScrolling += 1;
                    this.session.unfold(range);
                    this.selection.setSelectionRange(range);
                    this.$blockScrolling -= 1;

                    var scrollTop = this.renderer.scrollTop;
                    this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
                    if (animate !== false) this.renderer.animateScrolling(scrollTop);
                };
                this.undo = function () {
                    this.$blockScrolling++;
                    this.session.getUndoManager().undo();
                    this.$blockScrolling--;
                    this.renderer.scrollCursorIntoView(null, 0.5);
                };
                this.redo = function () {
                    this.$blockScrolling++;
                    this.session.getUndoManager().redo();
                    this.$blockScrolling--;
                    this.renderer.scrollCursorIntoView(null, 0.5);
                };
                this.destroy = function () {
                    this.renderer.destroy();
                    this._signal("destroy", this);
                    if (this.session) {
                        this.session.destroy();
                    }
                };
                this.setAutoScrollEditorIntoView = function (enable) {
                    if (!enable) return;
                    var rect;
                    var self = this;
                    var shouldScroll = false;
                    if (!this.$scrollAnchor) this.$scrollAnchor = document.createElement("div");
                    var scrollAnchor = this.$scrollAnchor;
                    scrollAnchor.style.cssText = "position:absolute";
                    this.container.insertBefore(scrollAnchor, this.container.firstChild);
                    var onChangeSelection = this.on("changeSelection", function () {
                        shouldScroll = true;
                    });
                    var onBeforeRender = this.renderer.on("beforeRender", function () {
                        if (shouldScroll) rect = self.renderer.container.getBoundingClientRect();
                    });
                    var onAfterRender = this.renderer.on("afterRender", function () {
                        if (shouldScroll && rect && (self.isFocused() || self.searchBox && self.searchBox.isFocused())) {
                            var renderer = self.renderer;
                            var pos = renderer.$cursorLayer.$pixelPos;
                            var config = renderer.layerConfig;
                            var top = pos.top - config.offset;
                            if (pos.top >= 0 && top + rect.top < 0) {
                                shouldScroll = true;
                            } else if (pos.top < config.height && pos.top + rect.top + config.lineHeight > window.innerHeight) {
                                shouldScroll = false;
                            } else {
                                shouldScroll = null;
                            }
                            if (shouldScroll != null) {
                                scrollAnchor.style.top = top + "px";
                                scrollAnchor.style.left = pos.left + "px";
                                scrollAnchor.style.height = config.lineHeight + "px";
                                scrollAnchor.scrollIntoView(shouldScroll);
                            }
                            shouldScroll = rect = null;
                        }
                    });
                    this.setAutoScrollEditorIntoView = function (enable) {
                        if (enable) return;
                        delete this.setAutoScrollEditorIntoView;
                        this.off("changeSelection", onChangeSelection);
                        this.renderer.off("afterRender", onAfterRender);
                        this.renderer.off("beforeRender", onBeforeRender);
                    };
                };

                this.$resetCursorStyle = function () {
                    var style = this.$cursorStyle || "ace";
                    var cursorLayer = this.renderer.$cursorLayer;
                    if (!cursorLayer) return;
                    cursorLayer.setSmoothBlinking(/smooth/.test(style));
                    cursorLayer.isBlinking = !this.$readOnly && style != "wide";
                    dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
                };
            }).call(Editor.prototype);

            config.defineOptions(Editor.prototype, "editor", {
                selectionStyle: {
                    set: function (style) {
                        this.onSelectionChange();
                        this._signal("changeSelectionStyle", { data: style });
                    },
                    initialValue: "line"
                },
                highlightActiveLine: {
                    set: function () {
                        this.$updateHighlightActiveLine();
                    },
                    initialValue: true
                },
                highlightSelectedWord: {
                    set: function (shouldHighlight) {
                        this.$onSelectionChange();
                    },
                    initialValue: true
                },
                readOnly: {
                    set: function (readOnly) {
                        this.$resetCursorStyle();
                    },
                    initialValue: false
                },
                cursorStyle: {
                    set: function (val) {
                        this.$resetCursorStyle();
                    },
                    values: ["ace", "slim", "smooth", "wide"],
                    initialValue: "ace"
                },
                mergeUndoDeltas: {
                    values: [false, true, "always"],
                    initialValue: true
                },
                behavioursEnabled: { initialValue: true },
                wrapBehavioursEnabled: { initialValue: true },
                autoScrollEditorIntoView: {
                    set: function (val) {
                        this.setAutoScrollEditorIntoView(val);
                    }
                },
                keyboardHandler: {
                    set: function (val) {
                        this.setKeyboardHandler(val);
                    },
                    get: function () {
                        return this.keybindingId;
                    },
                    handlesSet: true
                },

                hScrollBarAlwaysVisible: "renderer",
                vScrollBarAlwaysVisible: "renderer",
                highlightGutterLine: "renderer",
                animatedScroll: "renderer",
                showInvisibles: "renderer",
                showPrintMargin: "renderer",
                printMarginColumn: "renderer",
                printMargin: "renderer",
                fadeFoldWidgets: "renderer",
                showFoldWidgets: "renderer",
                showLineNumbers: "renderer",
                showGutter: "renderer",
                displayIndentGuides: "renderer",
                fontSize: "renderer",
                fontFamily: "renderer",
                maxLines: "renderer",
                minLines: "renderer",
                scrollPastEnd: "renderer",
                fixedWidthGutter: "renderer",
                theme: "renderer",

                scrollSpeed: "$mouseHandler",
                dragDelay: "$mouseHandler",
                dragEnabled: "$mouseHandler",
                focusTimout: "$mouseHandler",
                tooltipFollowsMouse: "$mouseHandler",

                firstLineNumber: "session",
                overwrite: "session",
                newLineMode: "session",
                useWorker: "session",
                useSoftTabs: "session",
                tabSize: "session",
                wrap: "session",
                indentedSoftWrap: "session",
                foldStyle: "session",
                mode: "session"
            });

            exports.Editor = Editor;
        });

        ace.define("ace/undomanager", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            var UndoManager = function () {
                this.reset();
            };

            (function () {
                this.execute = function (options) {
                    var deltaSets = options.args[0];
                    this.$doc = options.args[1];
                    if (options.merge && this.hasUndo()) {
                        this.dirtyCounter--;
                        deltaSets = this.$undoStack.pop().concat(deltaSets);
                    }
                    this.$undoStack.push(deltaSets);
                    this.$redoStack = [];
                    if (this.dirtyCounter < 0) {
                        this.dirtyCounter = NaN;
                    }
                    this.dirtyCounter++;
                };
                this.undo = function (dontSelect) {
                    var deltaSets = this.$undoStack.pop();
                    var undoSelectionRange = null;
                    if (deltaSets) {
                        undoSelectionRange = this.$doc.undoChanges(deltaSets, dontSelect);
                        this.$redoStack.push(deltaSets);
                        this.dirtyCounter--;
                    }

                    return undoSelectionRange;
                };
                this.redo = function (dontSelect) {
                    var deltaSets = this.$redoStack.pop();
                    var redoSelectionRange = null;
                    if (deltaSets) {
                        redoSelectionRange = this.$doc.redoChanges(this.$deserializeDeltas(deltaSets), dontSelect);
                        this.$undoStack.push(deltaSets);
                        this.dirtyCounter++;
                    }
                    return redoSelectionRange;
                };
                this.reset = function () {
                    this.$undoStack = [];
                    this.$redoStack = [];
                    this.dirtyCounter = 0;
                };
                this.hasUndo = function () {
                    return this.$undoStack.length > 0;
                };
                this.hasRedo = function () {
                    return this.$redoStack.length > 0;
                };
                this.markClean = function () {
                    this.dirtyCounter = 0;
                };
                this.isClean = function () {
                    return this.dirtyCounter === 0;
                };
                this.$serializeDeltas = function (deltaSets) {
                    return cloneDeltaSetsObj(deltaSets, $serializeDelta);
                };
                this.$deserializeDeltas = function (deltaSets) {
                    return cloneDeltaSetsObj(deltaSets, $deserializeDelta);
                };

                function $serializeDelta(delta) {
                    return {
                        action: delta.action,
                        start: delta.start,
                        end: delta.end,
                        lines: delta.lines.length == 1 ? null : delta.lines,
                        text: delta.lines.length == 1 ? delta.lines[0] : null
                    };
                }

                function $deserializeDelta(delta) {
                    return {
                        action: delta.action,
                        start: delta.start,
                        end: delta.end,
                        lines: delta.lines || [delta.text]
                    };
                }

                function cloneDeltaSetsObj(deltaSets_old, fnGetModifiedDelta) {
                    var deltaSets_new = new Array(deltaSets_old.length);
                    for (var i = 0; i < deltaSets_old.length; i++) {
                        var deltaSet_old = deltaSets_old[i];
                        var deltaSet_new = { group: deltaSet_old.group, deltas: new Array(deltaSet_old.length) };

                        for (var j = 0; j < deltaSet_old.deltas.length; j++) {
                            var delta_old = deltaSet_old.deltas[j];
                            deltaSet_new.deltas[j] = fnGetModifiedDelta(delta_old);
                        }

                        deltaSets_new[i] = deltaSet_new;
                    }
                    return deltaSets_new;
                }
            }).call(UndoManager.prototype);

            exports.UndoManager = UndoManager;
        });

        ace.define("ace/layer/gutter", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter"], function (require, exports, module) {
            "use strict";

            var dom = require("../lib/dom");
            var oop = require("../lib/oop");
            var lang = require("../lib/lang");
            var EventEmitter = require("../lib/event_emitter").EventEmitter;

            var Gutter = function (parentEl) {
                this.element = dom.createElement("div");
                this.element.className = "ace_layer ace_gutter-layer";
                parentEl.appendChild(this.element);
                this.setShowFoldWidgets(this.$showFoldWidgets);

                this.gutterWidth = 0;

                this.$annotations = [];
                this.$updateAnnotations = this.$updateAnnotations.bind(this);

                this.$cells = [];
            };

            (function () {

                oop.implement(this, EventEmitter);

                this.setSession = function (session) {
                    if (this.session) this.session.removeEventListener("change", this.$updateAnnotations);
                    this.session = session;
                    if (session) session.on("change", this.$updateAnnotations);
                };

                this.addGutterDecoration = function (row, className) {
                    if (window.console) console.warn && console.warn("deprecated use session.addGutterDecoration");
                    this.session.addGutterDecoration(row, className);
                };

                this.removeGutterDecoration = function (row, className) {
                    if (window.console) console.warn && console.warn("deprecated use session.removeGutterDecoration");
                    this.session.removeGutterDecoration(row, className);
                };

                this.setAnnotations = function (annotations) {
                    this.$annotations = [];
                    for (var i = 0; i < annotations.length; i++) {
                        var annotation = annotations[i];
                        var row = annotation.row;
                        var rowInfo = this.$annotations[row];
                        if (!rowInfo) rowInfo = this.$annotations[row] = { text: [] };

                        var annoText = annotation.text;
                        annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";

                        if (rowInfo.text.indexOf(annoText) === -1) rowInfo.text.push(annoText);

                        var type = annotation.type;
                        if (type == "error") rowInfo.className = " ace_error";else if (type == "warning" && rowInfo.className != " ace_error") rowInfo.className = " ace_warning";else if (type == "info" && !rowInfo.className) rowInfo.className = " ace_info";
                    }
                };

                this.$updateAnnotations = function (delta) {
                    if (!this.$annotations.length) return;
                    var firstRow = delta.start.row;
                    var len = delta.end.row - firstRow;
                    if (len === 0) {} else if (delta.action == 'remove') {
                        this.$annotations.splice(firstRow, len + 1, null);
                    } else {
                        var args = new Array(len + 1);
                        args.unshift(firstRow, 1);
                        this.$annotations.splice.apply(this.$annotations, args);
                    }
                };

                this.update = function (config) {
                    var session = this.session;
                    var firstRow = config.firstRow;
                    var lastRow = Math.min(config.lastRow + config.gutterOffset, // needed to compensate for hor scollbar
                    session.getLength() - 1);
                    var fold = session.getNextFoldLine(firstRow);
                    var foldStart = fold ? fold.start.row : Infinity;
                    var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
                    var breakpoints = session.$breakpoints;
                    var decorations = session.$decorations;
                    var firstLineNumber = session.$firstLineNumber;
                    var lastLineNumber = 0;

                    var gutterRenderer = session.gutterRenderer || this.$renderer;

                    var cell = null;
                    var index = -1;
                    var row = firstRow;
                    while (true) {
                        if (row > foldStart) {
                            row = fold.end.row + 1;
                            fold = session.getNextFoldLine(row, fold);
                            foldStart = fold ? fold.start.row : Infinity;
                        }
                        if (row > lastRow) {
                            while (this.$cells.length > index + 1) {
                                cell = this.$cells.pop();
                                this.element.removeChild(cell.element);
                            }
                            break;
                        }

                        cell = this.$cells[++index];
                        if (!cell) {
                            cell = { element: null, textNode: null, foldWidget: null };
                            cell.element = dom.createElement("div");
                            cell.textNode = document.createTextNode('');
                            cell.element.appendChild(cell.textNode);
                            this.element.appendChild(cell.element);
                            this.$cells[index] = cell;
                        }

                        var className = "ace_gutter-cell ";
                        if (breakpoints[row]) className += breakpoints[row];
                        if (decorations[row]) className += decorations[row];
                        if (this.$annotations[row]) className += this.$annotations[row].className;
                        if (cell.element.className != className) cell.element.className = className;

                        var height = session.getRowLength(row) * config.lineHeight + "px";
                        if (height != cell.element.style.height) cell.element.style.height = height;

                        if (foldWidgets) {
                            var c = foldWidgets[row];
                            if (c == null) c = foldWidgets[row] = session.getFoldWidget(row);
                        }

                        if (c) {
                            if (!cell.foldWidget) {
                                cell.foldWidget = dom.createElement("span");
                                cell.element.appendChild(cell.foldWidget);
                            }
                            var className = "ace_fold-widget ace_" + c;
                            if (c == "start" && row == foldStart && row < fold.end.row) className += " ace_closed";else className += " ace_open";
                            if (cell.foldWidget.className != className) cell.foldWidget.className = className;

                            var height = config.lineHeight + "px";
                            if (cell.foldWidget.style.height != height) cell.foldWidget.style.height = height;
                        } else {
                            if (cell.foldWidget) {
                                cell.element.removeChild(cell.foldWidget);
                                cell.foldWidget = null;
                            }
                        }

                        var text = lastLineNumber = gutterRenderer ? gutterRenderer.getText(session, row) : row + firstLineNumber;
                        if (text != cell.textNode.data) cell.textNode.data = text;

                        row++;
                    }

                    this.element.style.height = config.minHeight + "px";

                    if (this.$fixedWidth || session.$useWrapMode) lastLineNumber = session.getLength() + firstLineNumber;

                    var gutterWidth = gutterRenderer ? gutterRenderer.getWidth(session, lastLineNumber, config) : lastLineNumber.toString().length * config.characterWidth;

                    var padding = this.$padding || this.$computePadding();
                    gutterWidth += padding.left + padding.right;
                    if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
                        this.gutterWidth = gutterWidth;
                        this.element.style.width = Math.ceil(this.gutterWidth) + "px";
                        this._emit("changeGutterWidth", gutterWidth);
                    }
                };

                this.$fixedWidth = false;

                this.$showLineNumbers = true;
                this.$renderer = "";
                this.setShowLineNumbers = function (show) {
                    this.$renderer = !show && {
                        getWidth: function () {
                            return "";
                        },
                        getText: function () {
                            return "";
                        }
                    };
                };

                this.getShowLineNumbers = function () {
                    return this.$showLineNumbers;
                };

                this.$showFoldWidgets = true;
                this.setShowFoldWidgets = function (show) {
                    if (show) dom.addCssClass(this.element, "ace_folding-enabled");else dom.removeCssClass(this.element, "ace_folding-enabled");

                    this.$showFoldWidgets = show;
                    this.$padding = null;
                };

                this.getShowFoldWidgets = function () {
                    return this.$showFoldWidgets;
                };

                this.$computePadding = function () {
                    if (!this.element.firstChild) return { left: 0, right: 0 };
                    var style = dom.computedStyle(this.element.firstChild);
                    this.$padding = {};
                    this.$padding.left = parseInt(style.paddingLeft) + 1 || 0;
                    this.$padding.right = parseInt(style.paddingRight) || 0;
                    return this.$padding;
                };

                this.getRegion = function (point) {
                    var padding = this.$padding || this.$computePadding();
                    var rect = this.element.getBoundingClientRect();
                    if (point.x < padding.left + rect.left) return "markers";
                    if (this.$showFoldWidgets && point.x > rect.right - padding.right) return "foldWidgets";
                };
            }).call(Gutter.prototype);

            exports.Gutter = Gutter;
        });

        ace.define("ace/layer/marker", ["require", "exports", "module", "ace/range", "ace/lib/dom"], function (require, exports, module) {
            "use strict";

            var Range = require("../range").Range;
            var dom = require("../lib/dom");

            var Marker = function (parentEl) {
                this.element = dom.createElement("div");
                this.element.className = "ace_layer ace_marker-layer";
                parentEl.appendChild(this.element);
            };

            (function () {

                this.$padding = 0;

                this.setPadding = function (padding) {
                    this.$padding = padding;
                };
                this.setSession = function (session) {
                    this.session = session;
                };

                this.setMarkers = function (markers) {
                    this.markers = markers;
                };

                this.update = function (config) {
                    var config = config || this.config;
                    if (!config) return;

                    this.config = config;

                    var html = [];
                    for (var key in this.markers) {
                        var marker = this.markers[key];

                        if (!marker.range) {
                            marker.update(html, this, this.session, config);
                            continue;
                        }

                        var range = marker.range.clipRows(config.firstRow, config.lastRow);
                        if (range.isEmpty()) continue;

                        range = range.toScreenRange(this.session);
                        if (marker.renderer) {
                            var top = this.$getTop(range.start.row, config);
                            var left = this.$padding + range.start.column * config.characterWidth;
                            marker.renderer(html, range, left, top, config);
                        } else if (marker.type == "fullLine") {
                            this.drawFullLineMarker(html, range, marker.clazz, config);
                        } else if (marker.type == "screenLine") {
                            this.drawScreenLineMarker(html, range, marker.clazz, config);
                        } else if (range.isMultiLine()) {
                            if (marker.type == "text") this.drawTextMarker(html, range, marker.clazz, config);else this.drawMultiLineMarker(html, range, marker.clazz, config);
                        } else {
                            this.drawSingleLineMarker(html, range, marker.clazz + " ace_start" + " ace_br15", config);
                        }
                    }
                    this.element.innerHTML = html.join("");
                };

                this.$getTop = function (row, layerConfig) {
                    return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
                };

                function getBorderClass(tl, tr, br, bl) {
                    return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
                }
                this.drawTextMarker = function (stringBuilder, range, clazz, layerConfig, extraStyle) {
                    var session = this.session;
                    var start = range.start.row;
                    var end = range.end.row;
                    var row = start;
                    var prev = 0;
                    var curr = 0;
                    var next = session.getScreenLastRowColumn(row);
                    var lineRange = new Range(row, range.start.column, row, curr);
                    for (; row <= end; row++) {
                        lineRange.start.row = lineRange.end.row = row;
                        lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
                        lineRange.end.column = next;
                        prev = curr;
                        curr = next;
                        next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
                        this.drawSingleLineMarker(stringBuilder, lineRange, clazz + (row == start ? " ace_start" : "") + " ace_br" + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end), layerConfig, row == end ? 0 : 1, extraStyle);
                    }
                };
                this.drawMultiLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
                    var padding = this.$padding;
                    var height = config.lineHeight;
                    var top = this.$getTop(range.start.row, config);
                    var left = padding + range.start.column * config.characterWidth;
                    extraStyle = extraStyle || "";

                    stringBuilder.push("<div class='", clazz, " ace_br1 ace_start' style='", "height:", height, "px;", "right:0;", "top:", top, "px;", "left:", left, "px;", extraStyle, "'></div>");
                    top = this.$getTop(range.end.row, config);
                    var width = range.end.column * config.characterWidth;

                    stringBuilder.push("<div class='", clazz, " ace_br12' style='", "height:", height, "px;", "width:", width, "px;", "top:", top, "px;", "left:", padding, "px;", extraStyle, "'></div>");
                    height = (range.end.row - range.start.row - 1) * config.lineHeight;
                    if (height <= 0) return;
                    top = this.$getTop(range.start.row + 1, config);

                    var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);

                    stringBuilder.push("<div class='", clazz, radiusClass ? " ace_br" + radiusClass : "", "' style='", "height:", height, "px;", "right:0;", "top:", top, "px;", "left:", padding, "px;", extraStyle, "'></div>");
                };
                this.drawSingleLineMarker = function (stringBuilder, range, clazz, config, extraLength, extraStyle) {
                    var height = config.lineHeight;
                    var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;

                    var top = this.$getTop(range.start.row, config);
                    var left = this.$padding + range.start.column * config.characterWidth;

                    stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "width:", width, "px;", "top:", top, "px;", "left:", left, "px;", extraStyle || "", "'></div>");
                };

                this.drawFullLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
                    var top = this.$getTop(range.start.row, config);
                    var height = config.lineHeight;
                    if (range.start.row != range.end.row) height += this.$getTop(range.end.row, config) - top;

                    stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "top:", top, "px;", "left:0;right:0;", extraStyle || "", "'></div>");
                };

                this.drawScreenLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
                    var top = this.$getTop(range.start.row, config);
                    var height = config.lineHeight;

                    stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "top:", top, "px;", "left:0;right:0;", extraStyle || "", "'></div>");
                };
            }).call(Marker.prototype);

            exports.Marker = Marker;
        });

        ace.define("ace/layer/text", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/lib/event_emitter"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var dom = require("../lib/dom");
            var lang = require("../lib/lang");
            var useragent = require("../lib/useragent");
            var EventEmitter = require("../lib/event_emitter").EventEmitter;

            var Text = function (parentEl) {
                this.element = dom.createElement("div");
                this.element.className = "ace_layer ace_text-layer";
                parentEl.appendChild(this.element);
                this.$updateEolChar = this.$updateEolChar.bind(this);
            };

            (function () {

                oop.implement(this, EventEmitter);

                this.EOF_CHAR = "\xB6";
                this.EOL_CHAR_LF = "\xAC";
                this.EOL_CHAR_CRLF = "\xa4";
                this.EOL_CHAR = this.EOL_CHAR_LF;
                this.TAB_CHAR = "\u2014"; //"\u21E5";
                this.SPACE_CHAR = "\xB7";
                this.$padding = 0;

                this.$updateEolChar = function () {
                    var EOL_CHAR = this.session.doc.getNewLineCharacter() == "\n" ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
                    if (this.EOL_CHAR != EOL_CHAR) {
                        this.EOL_CHAR = EOL_CHAR;
                        return true;
                    }
                };

                this.setPadding = function (padding) {
                    this.$padding = padding;
                    this.element.style.padding = "0 " + padding + "px";
                };

                this.getLineHeight = function () {
                    return this.$fontMetrics.$characterSize.height || 0;
                };

                this.getCharacterWidth = function () {
                    return this.$fontMetrics.$characterSize.width || 0;
                };

                this.$setFontMetrics = function (measure) {
                    this.$fontMetrics = measure;
                    this.$fontMetrics.on("changeCharacterSize", function (e) {
                        this._signal("changeCharacterSize", e);
                    }.bind(this));
                    this.$pollSizeChanges();
                };

                this.checkForSizeChanges = function () {
                    this.$fontMetrics.checkForSizeChanges();
                };
                this.$pollSizeChanges = function () {
                    return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
                };
                this.setSession = function (session) {
                    this.session = session;
                    if (session) this.$computeTabString();
                };

                this.showInvisibles = false;
                this.setShowInvisibles = function (showInvisibles) {
                    if (this.showInvisibles == showInvisibles) return false;

                    this.showInvisibles = showInvisibles;
                    this.$computeTabString();
                    return true;
                };

                this.displayIndentGuides = true;
                this.setDisplayIndentGuides = function (display) {
                    if (this.displayIndentGuides == display) return false;

                    this.displayIndentGuides = display;
                    this.$computeTabString();
                    return true;
                };

                this.$tabStrings = [];
                this.onChangeTabSize = this.$computeTabString = function () {
                    var tabSize = this.session.getTabSize();
                    this.tabSize = tabSize;
                    var tabStr = this.$tabStrings = [0];
                    for (var i = 1; i < tabSize + 1; i++) {
                        if (this.showInvisibles) {
                            tabStr.push("<span class='ace_invisible ace_invisible_tab'>" + lang.stringRepeat(this.TAB_CHAR, i) + "</span>");
                        } else {
                            tabStr.push(lang.stringRepeat(" ", i));
                        }
                    }
                    if (this.displayIndentGuides) {
                        this.$indentGuideRe = /\s\S| \t|\t |\s$/;
                        var className = "ace_indent-guide";
                        var spaceClass = "";
                        var tabClass = "";
                        if (this.showInvisibles) {
                            className += " ace_invisible";
                            spaceClass = " ace_invisible_space";
                            tabClass = " ace_invisible_tab";
                            var spaceContent = lang.stringRepeat(this.SPACE_CHAR, this.tabSize);
                            var tabContent = lang.stringRepeat(this.TAB_CHAR, this.tabSize);
                        } else {
                            var spaceContent = lang.stringRepeat(" ", this.tabSize);
                            var tabContent = spaceContent;
                        }

                        this.$tabStrings[" "] = "<span class='" + className + spaceClass + "'>" + spaceContent + "</span>";
                        this.$tabStrings["\t"] = "<span class='" + className + tabClass + "'>" + tabContent + "</span>";
                    }
                };

                this.updateLines = function (config, firstRow, lastRow) {
                    if (this.config.lastRow != config.lastRow || this.config.firstRow != config.firstRow) {
                        this.scrollLines(config);
                    }
                    this.config = config;

                    var first = Math.max(firstRow, config.firstRow);
                    var last = Math.min(lastRow, config.lastRow);

                    var lineElements = this.element.childNodes;
                    var lineElementsIdx = 0;

                    for (var row = config.firstRow; row < first; row++) {
                        var foldLine = this.session.getFoldLine(row);
                        if (foldLine) {
                            if (foldLine.containsRow(first)) {
                                first = foldLine.start.row;
                                break;
                            } else {
                                row = foldLine.end.row;
                            }
                        }
                        lineElementsIdx++;
                    }

                    var row = first;
                    var foldLine = this.session.getNextFoldLine(row);
                    var foldStart = foldLine ? foldLine.start.row : Infinity;

                    while (true) {
                        if (row > foldStart) {
                            row = foldLine.end.row + 1;
                            foldLine = this.session.getNextFoldLine(row, foldLine);
                            foldStart = foldLine ? foldLine.start.row : Infinity;
                        }
                        if (row > last) break;

                        var lineElement = lineElements[lineElementsIdx++];
                        if (lineElement) {
                            var html = [];
                            this.$renderLine(html, row, !this.$useLineGroups(), row == foldStart ? foldLine : false);
                            lineElement.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
                            lineElement.innerHTML = html.join("");
                        }
                        row++;
                    }
                };

                this.scrollLines = function (config) {
                    var oldConfig = this.config;
                    this.config = config;

                    if (!oldConfig || oldConfig.lastRow < config.firstRow) return this.update(config);

                    if (config.lastRow < oldConfig.firstRow) return this.update(config);

                    var el = this.element;
                    if (oldConfig.firstRow < config.firstRow) for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--) el.removeChild(el.firstChild);

                    if (oldConfig.lastRow > config.lastRow) for (var row = this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row > 0; row--) el.removeChild(el.lastChild);

                    if (config.firstRow < oldConfig.firstRow) {
                        var fragment = this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1);
                        if (el.firstChild) el.insertBefore(fragment, el.firstChild);else el.appendChild(fragment);
                    }

                    if (config.lastRow > oldConfig.lastRow) {
                        var fragment = this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow);
                        el.appendChild(fragment);
                    }
                };

                this.$renderLinesFragment = function (config, firstRow, lastRow) {
                    var fragment = this.element.ownerDocument.createDocumentFragment();
                    var row = firstRow;
                    var foldLine = this.session.getNextFoldLine(row);
                    var foldStart = foldLine ? foldLine.start.row : Infinity;

                    while (true) {
                        if (row > foldStart) {
                            row = foldLine.end.row + 1;
                            foldLine = this.session.getNextFoldLine(row, foldLine);
                            foldStart = foldLine ? foldLine.start.row : Infinity;
                        }
                        if (row > lastRow) break;

                        var container = dom.createElement("div");

                        var html = [];
                        this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
                        container.innerHTML = html.join("");
                        if (this.$useLineGroups()) {
                            container.className = 'ace_line_group';
                            fragment.appendChild(container);
                            container.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
                        } else {
                            while (container.firstChild) fragment.appendChild(container.firstChild);
                        }

                        row++;
                    }
                    return fragment;
                };

                this.update = function (config) {
                    this.config = config;

                    var html = [];
                    var firstRow = config.firstRow,
                        lastRow = config.lastRow;

                    var row = firstRow;
                    var foldLine = this.session.getNextFoldLine(row);
                    var foldStart = foldLine ? foldLine.start.row : Infinity;

                    while (true) {
                        if (row > foldStart) {
                            row = foldLine.end.row + 1;
                            foldLine = this.session.getNextFoldLine(row, foldLine);
                            foldStart = foldLine ? foldLine.start.row : Infinity;
                        }
                        if (row > lastRow) break;

                        if (this.$useLineGroups()) html.push("<div class='ace_line_group' style='height:", config.lineHeight * this.session.getRowLength(row), "px'>");

                        this.$renderLine(html, row, false, row == foldStart ? foldLine : false);

                        if (this.$useLineGroups()) html.push("</div>"); // end the line group

                        row++;
                    }
                    this.element.innerHTML = html.join("");
                };

                this.$textToken = {
                    "text": true,
                    "rparen": true,
                    "lparen": true
                };

                this.$renderToken = function (stringBuilder, screenColumn, token, value) {
                    var self = this;
                    var replaceReg = /\t|&|<|>|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\u3000\uFEFF\uFFF9-\uFFFC])|[\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3000-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]/g;
                    var replaceFunc = function (c, a, b, tabIdx, idx4) {
                        if (a) {
                            return self.showInvisibles ? "<span class='ace_invisible ace_invisible_space'>" + lang.stringRepeat(self.SPACE_CHAR, c.length) + "</span>" : c;
                        } else if (c == "&") {
                            return "&#38;";
                        } else if (c == "<") {
                            return "&#60;";
                        } else if (c == ">") {
                            return "&#62;";
                        } else if (c == "\t") {
                            var tabSize = self.session.getScreenTabSize(screenColumn + tabIdx);
                            screenColumn += tabSize - 1;
                            return self.$tabStrings[tabSize];
                        } else if (c == "\u3000") {
                            var classToUse = self.showInvisibles ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
                            var space = self.showInvisibles ? self.SPACE_CHAR : "";
                            screenColumn += 1;
                            return "<span class='" + classToUse + "' style='width:" + self.config.characterWidth * 2 + "px'>" + space + "</span>";
                        } else if (b) {
                            return "<span class='ace_invisible ace_invisible_space ace_invalid'>" + self.SPACE_CHAR + "</span>";
                        } else {
                            screenColumn += 1;
                            return "<span class='ace_cjk' style='width:" + self.config.characterWidth * 2 + "px'>" + c + "</span>";
                        }
                    };

                    var output = value.replace(replaceReg, replaceFunc);

                    if (!this.$textToken[token.type]) {
                        var classes = "ace_" + token.type.replace(/\./g, " ace_");
                        var style = "";
                        if (token.type == "fold") style = " style='width:" + token.value.length * this.config.characterWidth + "px;' ";
                        stringBuilder.push("<span class='", classes, "'", style, ">", output, "</span>");
                    } else {
                        stringBuilder.push(output);
                    }
                    return screenColumn + value.length;
                };

                this.renderIndentGuide = function (stringBuilder, value, max) {
                    var cols = value.search(this.$indentGuideRe);
                    if (cols <= 0 || cols >= max) return value;
                    if (value[0] == " ") {
                        cols -= cols % this.tabSize;
                        stringBuilder.push(lang.stringRepeat(this.$tabStrings[" "], cols / this.tabSize));
                        return value.substr(cols);
                    } else if (value[0] == "\t") {
                        stringBuilder.push(lang.stringRepeat(this.$tabStrings["\t"], cols));
                        return value.substr(cols);
                    }
                    return value;
                };

                this.$renderWrappedLine = function (stringBuilder, tokens, splits, onlyContents) {
                    var chars = 0;
                    var split = 0;
                    var splitChars = splits[0];
                    var screenColumn = 0;

                    for (var i = 0; i < tokens.length; i++) {
                        var token = tokens[i];
                        var value = token.value;
                        if (i == 0 && this.displayIndentGuides) {
                            chars = value.length;
                            value = this.renderIndentGuide(stringBuilder, value, splitChars);
                            if (!value) continue;
                            chars -= value.length;
                        }

                        if (chars + value.length < splitChars) {
                            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                            chars += value.length;
                        } else {
                            while (chars + value.length >= splitChars) {
                                screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value.substring(0, splitChars - chars));
                                value = value.substring(splitChars - chars);
                                chars = splitChars;

                                if (!onlyContents) {
                                    stringBuilder.push("</div>", "<div class='ace_line' style='height:", this.config.lineHeight, "px'>");
                                }

                                stringBuilder.push(lang.stringRepeat("\xa0", splits.indent));

                                split++;
                                screenColumn = 0;
                                splitChars = splits[split] || Number.MAX_VALUE;
                            }
                            if (value.length != 0) {
                                chars += value.length;
                                screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                            }
                        }
                    }
                };

                this.$renderSimpleLine = function (stringBuilder, tokens) {
                    var screenColumn = 0;
                    var token = tokens[0];
                    var value = token.value;
                    if (this.displayIndentGuides) value = this.renderIndentGuide(stringBuilder, value);
                    if (value) screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                    for (var i = 1; i < tokens.length; i++) {
                        token = tokens[i];
                        value = token.value;
                        screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                    }
                };
                this.$renderLine = function (stringBuilder, row, onlyContents, foldLine) {
                    if (!foldLine && foldLine != false) foldLine = this.session.getFoldLine(row);

                    if (foldLine) var tokens = this.$getFoldLineTokens(row, foldLine);else var tokens = this.session.getTokens(row);

                    if (!onlyContents) {
                        stringBuilder.push("<div class='ace_line' style='height:", this.config.lineHeight * (this.$useLineGroups() ? 1 : this.session.getRowLength(row)), "px'>");
                    }

                    if (tokens.length) {
                        var splits = this.session.getRowSplitData(row);
                        if (splits && splits.length) this.$renderWrappedLine(stringBuilder, tokens, splits, onlyContents);else this.$renderSimpleLine(stringBuilder, tokens);
                    }

                    if (this.showInvisibles) {
                        if (foldLine) row = foldLine.end.row;

                        stringBuilder.push("<span class='ace_invisible ace_invisible_eol'>", row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR, "</span>");
                    }
                    if (!onlyContents) stringBuilder.push("</div>");
                };

                this.$getFoldLineTokens = function (row, foldLine) {
                    var session = this.session;
                    var renderTokens = [];

                    function addTokens(tokens, from, to) {
                        var idx = 0,
                            col = 0;
                        while (col + tokens[idx].value.length < from) {
                            col += tokens[idx].value.length;
                            idx++;

                            if (idx == tokens.length) return;
                        }
                        if (col != from) {
                            var value = tokens[idx].value.substring(from - col);
                            if (value.length > to - from) value = value.substring(0, to - from);

                            renderTokens.push({
                                type: tokens[idx].type,
                                value: value
                            });

                            col = from + value.length;
                            idx += 1;
                        }

                        while (col < to && idx < tokens.length) {
                            var value = tokens[idx].value;
                            if (value.length + col > to) {
                                renderTokens.push({
                                    type: tokens[idx].type,
                                    value: value.substring(0, to - col)
                                });
                            } else renderTokens.push(tokens[idx]);
                            col += value.length;
                            idx += 1;
                        }
                    }

                    var tokens = session.getTokens(row);
                    foldLine.walk(function (placeholder, row, column, lastColumn, isNewRow) {
                        if (placeholder != null) {
                            renderTokens.push({
                                type: "fold",
                                value: placeholder
                            });
                        } else {
                            if (isNewRow) tokens = session.getTokens(row);

                            if (tokens.length) addTokens(tokens, lastColumn, column);
                        }
                    }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);

                    return renderTokens;
                };

                this.$useLineGroups = function () {
                    return this.session.getUseWrapMode();
                };

                this.destroy = function () {
                    clearInterval(this.$pollSizeChangesTimer);
                    if (this.$measureNode) this.$measureNode.parentNode.removeChild(this.$measureNode);
                    delete this.$measureNode;
                };
            }).call(Text.prototype);

            exports.Text = Text;
        });

        ace.define("ace/layer/cursor", ["require", "exports", "module", "ace/lib/dom"], function (require, exports, module) {
            "use strict";

            var dom = require("../lib/dom");
            var isIE8;

            var Cursor = function (parentEl) {
                this.element = dom.createElement("div");
                this.element.className = "ace_layer ace_cursor-layer";
                parentEl.appendChild(this.element);

                if (isIE8 === undefined) isIE8 = !("opacity" in this.element.style);

                this.isVisible = false;
                this.isBlinking = true;
                this.blinkInterval = 1000;
                this.smoothBlinking = false;

                this.cursors = [];
                this.cursor = this.addCursor();
                dom.addCssClass(this.element, "ace_hidden-cursors");
                this.$updateCursors = (isIE8 ? this.$updateVisibility : this.$updateOpacity).bind(this);
            };

            (function () {

                this.$updateVisibility = function (val) {
                    var cursors = this.cursors;
                    for (var i = cursors.length; i--;) cursors[i].style.visibility = val ? "" : "hidden";
                };
                this.$updateOpacity = function (val) {
                    var cursors = this.cursors;
                    for (var i = cursors.length; i--;) cursors[i].style.opacity = val ? "" : "0";
                };

                this.$padding = 0;
                this.setPadding = function (padding) {
                    this.$padding = padding;
                };

                this.setSession = function (session) {
                    this.session = session;
                };

                this.setBlinking = function (blinking) {
                    if (blinking != this.isBlinking) {
                        this.isBlinking = blinking;
                        this.restartTimer();
                    }
                };

                this.setBlinkInterval = function (blinkInterval) {
                    if (blinkInterval != this.blinkInterval) {
                        this.blinkInterval = blinkInterval;
                        this.restartTimer();
                    }
                };

                this.setSmoothBlinking = function (smoothBlinking) {
                    if (smoothBlinking != this.smoothBlinking && !isIE8) {
                        this.smoothBlinking = smoothBlinking;
                        dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
                        this.$updateCursors(true);
                        this.$updateCursors = this.$updateOpacity.bind(this);
                        this.restartTimer();
                    }
                };

                this.addCursor = function () {
                    var el = dom.createElement("div");
                    el.className = "ace_cursor";
                    this.element.appendChild(el);
                    this.cursors.push(el);
                    return el;
                };

                this.removeCursor = function () {
                    if (this.cursors.length > 1) {
                        var el = this.cursors.pop();
                        el.parentNode.removeChild(el);
                        return el;
                    }
                };

                this.hideCursor = function () {
                    this.isVisible = false;
                    dom.addCssClass(this.element, "ace_hidden-cursors");
                    this.restartTimer();
                };

                this.showCursor = function () {
                    this.isVisible = true;
                    dom.removeCssClass(this.element, "ace_hidden-cursors");
                    this.restartTimer();
                };

                this.restartTimer = function () {
                    var update = this.$updateCursors;
                    clearInterval(this.intervalId);
                    clearTimeout(this.timeoutId);
                    if (this.smoothBlinking) {
                        dom.removeCssClass(this.element, "ace_smooth-blinking");
                    }

                    update(true);

                    if (!this.isBlinking || !this.blinkInterval || !this.isVisible) return;

                    if (this.smoothBlinking) {
                        setTimeout(function () {
                            dom.addCssClass(this.element, "ace_smooth-blinking");
                        }.bind(this));
                    }

                    var blink = function () {
                        this.timeoutId = setTimeout(function () {
                            update(false);
                        }, 0.6 * this.blinkInterval);
                    }.bind(this);

                    this.intervalId = setInterval(function () {
                        update(true);
                        blink();
                    }, this.blinkInterval);

                    blink();
                };

                this.getPixelPosition = function (position, onScreen) {
                    if (!this.config || !this.session) return { left: 0, top: 0 };

                    if (!position) position = this.session.selection.getCursor();
                    var pos = this.session.documentToScreenPosition(position);
                    var cursorLeft = this.$padding + pos.column * this.config.characterWidth;
                    var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) * this.config.lineHeight;

                    return { left: cursorLeft, top: cursorTop };
                };

                this.update = function (config) {
                    this.config = config;

                    var selections = this.session.$selectionMarkers;
                    var i = 0,
                        cursorIndex = 0;

                    if (selections === undefined || selections.length === 0) {
                        selections = [{ cursor: null }];
                    }

                    for (var i = 0, n = selections.length; i < n; i++) {
                        var pixelPos = this.getPixelPosition(selections[i].cursor, true);
                        if ((pixelPos.top > config.height + config.offset || pixelPos.top < 0) && i > 1) {
                            continue;
                        }

                        var style = (this.cursors[cursorIndex++] || this.addCursor()).style;

                        if (!this.drawCursor) {
                            style.left = pixelPos.left + "px";
                            style.top = pixelPos.top + "px";
                            style.width = config.characterWidth + "px";
                            style.height = config.lineHeight + "px";
                        } else {
                            this.drawCursor(style, pixelPos, config, selections[i], this.session);
                        }
                    }
                    while (this.cursors.length > cursorIndex) this.removeCursor();

                    var overwrite = this.session.getOverwrite();
                    this.$setOverwrite(overwrite);
                    this.$pixelPos = pixelPos;
                    this.restartTimer();
                };

                this.drawCursor = null;

                this.$setOverwrite = function (overwrite) {
                    if (overwrite != this.overwrite) {
                        this.overwrite = overwrite;
                        if (overwrite) dom.addCssClass(this.element, "ace_overwrite-cursors");else dom.removeCssClass(this.element, "ace_overwrite-cursors");
                    }
                };

                this.destroy = function () {
                    clearInterval(this.intervalId);
                    clearTimeout(this.timeoutId);
                };
            }).call(Cursor.prototype);

            exports.Cursor = Cursor;
        });

        ace.define("ace/scrollbar", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/event", "ace/lib/event_emitter"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var dom = require("./lib/dom");
            var event = require("./lib/event");
            var EventEmitter = require("./lib/event_emitter").EventEmitter;
            var MAX_SCROLL_H = 0x8000;
            var ScrollBar = function (parent) {
                this.element = dom.createElement("div");
                this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix;

                this.inner = dom.createElement("div");
                this.inner.className = "ace_scrollbar-inner";
                this.element.appendChild(this.inner);

                parent.appendChild(this.element);

                this.setVisible(false);
                this.skipEvent = false;

                event.addListener(this.element, "scroll", this.onScroll.bind(this));
                event.addListener(this.element, "mousedown", event.preventDefault);
            };

            (function () {
                oop.implement(this, EventEmitter);

                this.setVisible = function (isVisible) {
                    this.element.style.display = isVisible ? "" : "none";
                    this.isVisible = isVisible;
                    this.coeff = 1;
                };
            }).call(ScrollBar.prototype);
            var VScrollBar = function (parent, renderer) {
                ScrollBar.call(this, parent);
                this.scrollTop = 0;
                this.scrollHeight = 0;
                renderer.$scrollbarWidth = this.width = dom.scrollbarWidth(parent.ownerDocument);
                this.inner.style.width = this.element.style.width = (this.width || 15) + 5 + "px";
            };

            oop.inherits(VScrollBar, ScrollBar);

            (function () {

                this.classSuffix = '-v';
                this.onScroll = function () {
                    if (!this.skipEvent) {
                        this.scrollTop = this.element.scrollTop;
                        if (this.coeff != 1) {
                            var h = this.element.clientHeight / this.scrollHeight;
                            this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);
                        }
                        this._emit("scroll", { data: this.scrollTop });
                    }
                    this.skipEvent = false;
                };
                this.getWidth = function () {
                    return this.isVisible ? this.width : 0;
                };
                this.setHeight = function (height) {
                    this.element.style.height = height + "px";
                };
                this.setInnerHeight = this.setScrollHeight = function (height) {
                    this.scrollHeight = height;
                    if (height > MAX_SCROLL_H) {
                        this.coeff = MAX_SCROLL_H / height;
                        height = MAX_SCROLL_H;
                    } else if (this.coeff != 1) {
                        this.coeff = 1;
                    }
                    this.inner.style.height = height + "px";
                };
                this.setScrollTop = function (scrollTop) {
                    if (this.scrollTop != scrollTop) {
                        this.skipEvent = true;
                        this.scrollTop = scrollTop;
                        this.element.scrollTop = scrollTop * this.coeff;
                    }
                };
            }).call(VScrollBar.prototype);
            var HScrollBar = function (parent, renderer) {
                ScrollBar.call(this, parent);
                this.scrollLeft = 0;
                this.height = renderer.$scrollbarWidth;
                this.inner.style.height = this.element.style.height = (this.height || 15) + 5 + "px";
            };

            oop.inherits(HScrollBar, ScrollBar);

            (function () {

                this.classSuffix = '-h';
                this.onScroll = function () {
                    if (!this.skipEvent) {
                        this.scrollLeft = this.element.scrollLeft;
                        this._emit("scroll", { data: this.scrollLeft });
                    }
                    this.skipEvent = false;
                };
                this.getHeight = function () {
                    return this.isVisible ? this.height : 0;
                };
                this.setWidth = function (width) {
                    this.element.style.width = width + "px";
                };
                this.setInnerWidth = function (width) {
                    this.inner.style.width = width + "px";
                };
                this.setScrollWidth = function (width) {
                    this.inner.style.width = width + "px";
                };
                this.setScrollLeft = function (scrollLeft) {
                    if (this.scrollLeft != scrollLeft) {
                        this.skipEvent = true;
                        this.scrollLeft = this.element.scrollLeft = scrollLeft;
                    }
                };
            }).call(HScrollBar.prototype);

            exports.ScrollBar = VScrollBar; // backward compatibility
            exports.ScrollBarV = VScrollBar; // backward compatibility
            exports.ScrollBarH = HScrollBar; // backward compatibility

            exports.VScrollBar = VScrollBar;
            exports.HScrollBar = HScrollBar;
        });

        ace.define("ace/renderloop", ["require", "exports", "module", "ace/lib/event"], function (require, exports, module) {
            "use strict";

            var event = require("./lib/event");

            var RenderLoop = function (onRender, win) {
                this.onRender = onRender;
                this.pending = false;
                this.changes = 0;
                this.window = win || window;
            };

            (function () {

                this.schedule = function (change) {
                    this.changes = this.changes | change;
                    if (!this.pending && this.changes) {
                        this.pending = true;
                        var _self = this;
                        event.nextFrame(function () {
                            _self.pending = false;
                            var changes;
                            while (changes = _self.changes) {
                                _self.changes = 0;
                                _self.onRender(changes);
                            }
                        }, this.window);
                    }
                };
            }).call(RenderLoop.prototype);

            exports.RenderLoop = RenderLoop;
        });

        ace.define("ace/layer/font_metrics", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/lib/event_emitter"], function (require, exports, module) {

            var oop = require("../lib/oop");
            var dom = require("../lib/dom");
            var lang = require("../lib/lang");
            var useragent = require("../lib/useragent");
            var EventEmitter = require("../lib/event_emitter").EventEmitter;

            var CHAR_COUNT = 0;

            var FontMetrics = exports.FontMetrics = function (parentEl) {
                this.el = dom.createElement("div");
                this.$setMeasureNodeStyles(this.el.style, true);

                this.$main = dom.createElement("div");
                this.$setMeasureNodeStyles(this.$main.style);

                this.$measureNode = dom.createElement("div");
                this.$setMeasureNodeStyles(this.$measureNode.style);

                this.el.appendChild(this.$main);
                this.el.appendChild(this.$measureNode);
                parentEl.appendChild(this.el);

                if (!CHAR_COUNT) this.$testFractionalRect();
                this.$measureNode.innerHTML = lang.stringRepeat("X", CHAR_COUNT);

                this.$characterSize = { width: 0, height: 0 };
                this.checkForSizeChanges();
            };

            (function () {

                oop.implement(this, EventEmitter);

                this.$characterSize = { width: 0, height: 0 };

                this.$testFractionalRect = function () {
                    var el = dom.createElement("div");
                    this.$setMeasureNodeStyles(el.style);
                    el.style.width = "0.2px";
                    document.documentElement.appendChild(el);
                    var w = el.getBoundingClientRect().width;
                    if (w > 0 && w < 1) CHAR_COUNT = 50;else CHAR_COUNT = 100;
                    el.parentNode.removeChild(el);
                };

                this.$setMeasureNodeStyles = function (style, isRoot) {
                    style.width = style.height = "auto";
                    style.left = style.top = "0px";
                    style.visibility = "hidden";
                    style.position = "absolute";
                    style.whiteSpace = "pre";

                    if (useragent.isIE < 8) {
                        style["font-family"] = "inherit";
                    } else {
                        style.font = "inherit";
                    }
                    style.overflow = isRoot ? "hidden" : "visible";
                };

                this.checkForSizeChanges = function () {
                    var size = this.$measureSizes();
                    if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
                        this.$measureNode.style.fontWeight = "bold";
                        var boldSize = this.$measureSizes();
                        this.$measureNode.style.fontWeight = "";
                        this.$characterSize = size;
                        this.charSizes = Object.create(null);
                        this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
                        this._emit("changeCharacterSize", { data: size });
                    }
                };

                this.$pollSizeChanges = function () {
                    if (this.$pollSizeChangesTimer) return this.$pollSizeChangesTimer;
                    var self = this;
                    return this.$pollSizeChangesTimer = setInterval(function () {
                        self.checkForSizeChanges();
                    }, 500);
                };

                this.setPolling = function (val) {
                    if (val) {
                        this.$pollSizeChanges();
                    } else if (this.$pollSizeChangesTimer) {
                        clearInterval(this.$pollSizeChangesTimer);
                        this.$pollSizeChangesTimer = 0;
                    }
                };

                this.$measureSizes = function () {
                    if (CHAR_COUNT === 50) {
                        var rect = null;
                        try {
                            rect = this.$measureNode.getBoundingClientRect();
                        } catch (e) {
                            rect = { width: 0, height: 0 };
                        }
                        var size = {
                            height: rect.height,
                            width: rect.width / CHAR_COUNT
                        };
                    } else {
                        var size = {
                            height: this.$measureNode.clientHeight,
                            width: this.$measureNode.clientWidth / CHAR_COUNT
                        };
                    }
                    if (size.width === 0 || size.height === 0) return null;
                    return size;
                };

                this.$measureCharWidth = function (ch) {
                    this.$main.innerHTML = lang.stringRepeat(ch, CHAR_COUNT);
                    var rect = this.$main.getBoundingClientRect();
                    return rect.width / CHAR_COUNT;
                };

                this.getCharacterWidth = function (ch) {
                    var w = this.charSizes[ch];
                    if (w === undefined) {
                        w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
                    }
                    return w;
                };

                this.destroy = function () {
                    clearInterval(this.$pollSizeChangesTimer);
                    if (this.el && this.el.parentNode) this.el.parentNode.removeChild(this.el);
                };
            }).call(FontMetrics.prototype);
        });

        ace.define("ace/virtual_renderer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/config", "ace/lib/useragent", "ace/layer/gutter", "ace/layer/marker", "ace/layer/text", "ace/layer/cursor", "ace/scrollbar", "ace/scrollbar", "ace/renderloop", "ace/layer/font_metrics", "ace/lib/event_emitter"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var dom = require("./lib/dom");
            var config = require("./config");
            var useragent = require("./lib/useragent");
            var GutterLayer = require("./layer/gutter").Gutter;
            var MarkerLayer = require("./layer/marker").Marker;
            var TextLayer = require("./layer/text").Text;
            var CursorLayer = require("./layer/cursor").Cursor;
            var HScrollBar = require("./scrollbar").HScrollBar;
            var VScrollBar = require("./scrollbar").VScrollBar;
            var RenderLoop = require("./renderloop").RenderLoop;
            var FontMetrics = require("./layer/font_metrics").FontMetrics;
            var EventEmitter = require("./lib/event_emitter").EventEmitter;
            var editorCss = ".ace_editor {\
position: relative;\
overflow: hidden;\
font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;\
direction: ltr;\
text-align: left;\
}\
.ace_scroller {\
position: absolute;\
overflow: hidden;\
top: 0;\
bottom: 0;\
background-color: inherit;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
cursor: text;\
}\
.ace_content {\
position: absolute;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
min-width: 100%;\
}\
.ace_dragging .ace_scroller:before{\
position: absolute;\
top: 0;\
left: 0;\
right: 0;\
bottom: 0;\
content: '';\
background: rgba(250, 250, 250, 0.01);\
z-index: 1000;\
}\
.ace_dragging.ace_dark .ace_scroller:before{\
background: rgba(0, 0, 0, 0.01);\
}\
.ace_selecting, .ace_selecting * {\
cursor: text !important;\
}\
.ace_gutter {\
position: absolute;\
overflow : hidden;\
width: auto;\
top: 0;\
bottom: 0;\
left: 0;\
cursor: default;\
z-index: 4;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
}\
.ace_gutter-active-line {\
position: absolute;\
left: 0;\
right: 0;\
}\
.ace_scroller.ace_scroll-left {\
box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\
}\
.ace_gutter-cell {\
padding-left: 19px;\
padding-right: 6px;\
background-repeat: no-repeat;\
}\
.ace_gutter-cell.ace_error {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_warning {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\");\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\");\
background-position: 2px center;\
}\
.ace_dark .ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\");\
}\
.ace_scrollbar {\
position: absolute;\
right: 0;\
bottom: 0;\
z-index: 6;\
}\
.ace_scrollbar-inner {\
position: absolute;\
cursor: text;\
left: 0;\
top: 0;\
}\
.ace_scrollbar-v{\
overflow-x: hidden;\
overflow-y: scroll;\
top: 0;\
}\
.ace_scrollbar-h {\
overflow-x: scroll;\
overflow-y: hidden;\
left: 0;\
}\
.ace_print-margin {\
position: absolute;\
height: 100%;\
}\
.ace_text-input {\
position: absolute;\
z-index: 0;\
width: 0.5em;\
height: 1em;\
opacity: 0;\
background: transparent;\
-moz-appearance: none;\
appearance: none;\
border: none;\
resize: none;\
outline: none;\
overflow: hidden;\
font: inherit;\
padding: 0 1px;\
margin: 0 -1px;\
text-indent: -1em;\
-ms-user-select: text;\
-moz-user-select: text;\
-webkit-user-select: text;\
user-select: text;\
white-space: pre!important;\
}\
.ace_text-input.ace_composition {\
background: inherit;\
color: inherit;\
z-index: 1000;\
opacity: 1;\
text-indent: 0;\
}\
.ace_layer {\
z-index: 1;\
position: absolute;\
overflow: hidden;\
word-wrap: normal;\
white-space: pre;\
height: 100%;\
width: 100%;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
pointer-events: none;\
}\
.ace_gutter-layer {\
position: relative;\
width: auto;\
text-align: right;\
pointer-events: auto;\
}\
.ace_text-layer {\
font: inherit !important;\
}\
.ace_cjk {\
display: inline-block;\
text-align: center;\
}\
.ace_cursor-layer {\
z-index: 4;\
}\
.ace_cursor {\
z-index: 4;\
position: absolute;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
border-left: 2px solid;\
transform: translatez(0);\
}\
.ace_slim-cursors .ace_cursor {\
border-left-width: 1px;\
}\
.ace_overwrite-cursors .ace_cursor {\
border-left-width: 0;\
border-bottom: 1px solid;\
}\
.ace_hidden-cursors .ace_cursor {\
opacity: 0.2;\
}\
.ace_smooth-blinking .ace_cursor {\
-webkit-transition: opacity 0.18s;\
transition: opacity 0.18s;\
}\
.ace_editor.ace_multiselect .ace_cursor {\
border-left-width: 1px;\
}\
.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\
position: absolute;\
z-index: 3;\
}\
.ace_marker-layer .ace_selection {\
position: absolute;\
z-index: 5;\
}\
.ace_marker-layer .ace_bracket {\
position: absolute;\
z-index: 6;\
}\
.ace_marker-layer .ace_active-line {\
position: absolute;\
z-index: 2;\
}\
.ace_marker-layer .ace_selected-word {\
position: absolute;\
z-index: 4;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
}\
.ace_line .ace_fold {\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
display: inline-block;\
height: 11px;\
margin-top: -2px;\
vertical-align: middle;\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\");\
background-repeat: no-repeat, repeat-x;\
background-position: center center, top left;\
color: transparent;\
border: 1px solid black;\
border-radius: 2px;\
cursor: pointer;\
pointer-events: auto;\
}\
.ace_dark .ace_fold {\
}\
.ace_fold:hover{\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\");\
}\
.ace_tooltip {\
background-color: #FFF;\
background-image: -webkit-linear-gradient(top, transparent, rgba(0, 0, 0, 0.1));\
background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));\
border: 1px solid gray;\
border-radius: 1px;\
box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\
color: black;\
max-width: 100%;\
padding: 3px 4px;\
position: fixed;\
z-index: 999999;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
cursor: default;\
white-space: pre;\
word-wrap: break-word;\
line-height: normal;\
font-style: normal;\
font-weight: normal;\
letter-spacing: normal;\
pointer-events: none;\
}\
.ace_folding-enabled > .ace_gutter-cell {\
padding-right: 13px;\
}\
.ace_fold-widget {\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
margin: 0 -12px 0 1px;\
display: none;\
width: 11px;\
vertical-align: top;\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: center;\
border-radius: 3px;\
border: 1px solid transparent;\
cursor: pointer;\
}\
.ace_folding-enabled .ace_fold-widget {\
display: inline-block;   \
}\
.ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\");\
}\
.ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\");\
}\
.ace_fold-widget:hover {\
border: 1px solid rgba(0, 0, 0, 0.3);\
background-color: rgba(255, 255, 255, 0.2);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\
}\
.ace_fold-widget:active {\
border: 1px solid rgba(0, 0, 0, 0.4);\
background-color: rgba(0, 0, 0, 0.05);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\
}\
.ace_dark .ace_fold-widget {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\");\
}\
.ace_dark .ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget:hover {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
background-color: rgba(255, 255, 255, 0.1);\
}\
.ace_dark .ace_fold-widget:active {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
}\
.ace_fold-widget.ace_invalid {\
background-color: #FFB4B4;\
border-color: #DE5555;\
}\
.ace_fade-fold-widgets .ace_fold-widget {\
-webkit-transition: opacity 0.4s ease 0.05s;\
transition: opacity 0.4s ease 0.05s;\
opacity: 0;\
}\
.ace_fade-fold-widgets:hover .ace_fold-widget {\
-webkit-transition: opacity 0.05s ease 0.05s;\
transition: opacity 0.05s ease 0.05s;\
opacity:1;\
}\
.ace_underline {\
text-decoration: underline;\
}\
.ace_bold {\
font-weight: bold;\
}\
.ace_nobold .ace_bold {\
font-weight: normal;\
}\
.ace_italic {\
font-style: italic;\
}\
.ace_error-marker {\
background-color: rgba(255, 0, 0,0.2);\
position: absolute;\
z-index: 9;\
}\
.ace_highlight-marker {\
background-color: rgba(255, 255, 0,0.2);\
position: absolute;\
z-index: 8;\
}\
.ace_br1 {border-top-left-radius    : 3px;}\
.ace_br2 {border-top-right-radius   : 3px;}\
.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\
.ace_br4 {border-bottom-right-radius: 3px;}\
.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\
.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\
.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\
.ace_br8 {border-bottom-left-radius : 3px;}\
.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\
.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\
.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\
.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\
";

            dom.importCssString(editorCss, "ace_editor.css");

            var VirtualRenderer = function (container, theme) {
                var _self = this;

                this.container = container || dom.createElement("div");
                this.$keepTextAreaAtCursor = !useragent.isOldIE;

                dom.addCssClass(this.container, "ace_editor");

                this.setTheme(theme);

                this.$gutter = dom.createElement("div");
                this.$gutter.className = "ace_gutter";
                this.container.appendChild(this.$gutter);

                this.scroller = dom.createElement("div");
                this.scroller.className = "ace_scroller";
                this.container.appendChild(this.scroller);

                this.content = dom.createElement("div");
                this.content.className = "ace_content";
                this.scroller.appendChild(this.content);

                this.$gutterLayer = new GutterLayer(this.$gutter);
                this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));

                this.$markerBack = new MarkerLayer(this.content);

                var textLayer = this.$textLayer = new TextLayer(this.content);
                this.canvas = textLayer.element;

                this.$markerFront = new MarkerLayer(this.content);

                this.$cursorLayer = new CursorLayer(this.content);
                this.$horizScroll = false;
                this.$vScroll = false;

                this.scrollBar = this.scrollBarV = new VScrollBar(this.container, this);
                this.scrollBarH = new HScrollBar(this.container, this);
                this.scrollBarV.addEventListener("scroll", function (e) {
                    if (!_self.$scrollAnimation) _self.session.setScrollTop(e.data - _self.scrollMargin.top);
                });
                this.scrollBarH.addEventListener("scroll", function (e) {
                    if (!_self.$scrollAnimation) _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
                });

                this.scrollTop = 0;
                this.scrollLeft = 0;

                this.cursorPos = {
                    row: 0,
                    column: 0
                };

                this.$fontMetrics = new FontMetrics(this.container);
                this.$textLayer.$setFontMetrics(this.$fontMetrics);
                this.$textLayer.addEventListener("changeCharacterSize", function (e) {
                    _self.updateCharacterSize();
                    _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
                    _self._signal("changeCharacterSize", e);
                });

                this.$size = {
                    width: 0,
                    height: 0,
                    scrollerHeight: 0,
                    scrollerWidth: 0,
                    $dirty: true
                };

                this.layerConfig = {
                    width: 1,
                    padding: 0,
                    firstRow: 0,
                    firstRowScreen: 0,
                    lastRow: 0,
                    lineHeight: 0,
                    characterWidth: 0,
                    minHeight: 1,
                    maxHeight: 1,
                    offset: 0,
                    height: 1,
                    gutterOffset: 1
                };

                this.scrollMargin = {
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0,
                    v: 0,
                    h: 0
                };

                this.$loop = new RenderLoop(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);
                this.$loop.schedule(this.CHANGE_FULL);

                this.updateCharacterSize();
                this.setPadding(4);
                config.resetOptions(this);
                config._emit("renderer", this);
            };

            (function () {

                this.CHANGE_CURSOR = 1;
                this.CHANGE_MARKER = 2;
                this.CHANGE_GUTTER = 4;
                this.CHANGE_SCROLL = 8;
                this.CHANGE_LINES = 16;
                this.CHANGE_TEXT = 32;
                this.CHANGE_SIZE = 64;
                this.CHANGE_MARKER_BACK = 128;
                this.CHANGE_MARKER_FRONT = 256;
                this.CHANGE_FULL = 512;
                this.CHANGE_H_SCROLL = 1024;

                oop.implement(this, EventEmitter);

                this.updateCharacterSize = function () {
                    if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
                        this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
                        this.setStyle("ace_nobold", !this.$allowBoldFonts);
                    }

                    this.layerConfig.characterWidth = this.characterWidth = this.$textLayer.getCharacterWidth();
                    this.layerConfig.lineHeight = this.lineHeight = this.$textLayer.getLineHeight();
                    this.$updatePrintMargin();
                };
                this.setSession = function (session) {
                    if (this.session) this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);

                    this.session = session;
                    if (session && this.scrollMargin.top && session.getScrollTop() <= 0) session.setScrollTop(-this.scrollMargin.top);

                    this.$cursorLayer.setSession(session);
                    this.$markerBack.setSession(session);
                    this.$markerFront.setSession(session);
                    this.$gutterLayer.setSession(session);
                    this.$textLayer.setSession(session);
                    if (!session) return;

                    this.$loop.schedule(this.CHANGE_FULL);
                    this.session.$setFontMetrics(this.$fontMetrics);
                    this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;

                    this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
                    this.onChangeNewLineMode();
                    this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
                };
                this.updateLines = function (firstRow, lastRow, force) {
                    if (lastRow === undefined) lastRow = Infinity;

                    if (!this.$changedLines) {
                        this.$changedLines = {
                            firstRow: firstRow,
                            lastRow: lastRow
                        };
                    } else {
                        if (this.$changedLines.firstRow > firstRow) this.$changedLines.firstRow = firstRow;

                        if (this.$changedLines.lastRow < lastRow) this.$changedLines.lastRow = lastRow;
                    }
                    if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
                        if (force) this.$changedLines.lastRow = this.layerConfig.lastRow;else return;
                    }
                    if (this.$changedLines.firstRow > this.layerConfig.lastRow) return;
                    this.$loop.schedule(this.CHANGE_LINES);
                };

                this.onChangeNewLineMode = function () {
                    this.$loop.schedule(this.CHANGE_TEXT);
                    this.$textLayer.$updateEolChar();
                };

                this.onChangeTabSize = function () {
                    this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
                    this.$textLayer.onChangeTabSize();
                };
                this.updateText = function () {
                    this.$loop.schedule(this.CHANGE_TEXT);
                };
                this.updateFull = function (force) {
                    if (force) this.$renderChanges(this.CHANGE_FULL, true);else this.$loop.schedule(this.CHANGE_FULL);
                };
                this.updateFontSize = function () {
                    this.$textLayer.checkForSizeChanges();
                };

                this.$changes = 0;
                this.$updateSizeAsync = function () {
                    if (this.$loop.pending) this.$size.$dirty = true;else this.onResize();
                };
                this.onResize = function (force, gutterWidth, width, height) {
                    if (this.resizing > 2) return;else if (this.resizing > 0) this.resizing++;else this.resizing = force ? 1 : 0;
                    var el = this.container;
                    if (!height) height = el.clientHeight || el.scrollHeight;
                    if (!width) width = el.clientWidth || el.scrollWidth;
                    var changes = this.$updateCachedSize(force, gutterWidth, width, height);

                    if (!this.$size.scrollerHeight || !width && !height) return this.resizing = 0;

                    if (force) this.$gutterLayer.$padding = null;

                    if (force) this.$renderChanges(changes | this.$changes, true);else this.$loop.schedule(changes | this.$changes);

                    if (this.resizing) this.resizing = 0;
                    this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;
                };

                this.$updateCachedSize = function (force, gutterWidth, width, height) {
                    height -= this.$extraHeight || 0;
                    var changes = 0;
                    var size = this.$size;
                    var oldSize = {
                        width: size.width,
                        height: size.height,
                        scrollerHeight: size.scrollerHeight,
                        scrollerWidth: size.scrollerWidth
                    };
                    if (height && (force || size.height != height)) {
                        size.height = height;
                        changes |= this.CHANGE_SIZE;

                        size.scrollerHeight = size.height;
                        if (this.$horizScroll) size.scrollerHeight -= this.scrollBarH.getHeight();
                        this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";

                        changes = changes | this.CHANGE_SCROLL;
                    }

                    if (width && (force || size.width != width)) {
                        changes |= this.CHANGE_SIZE;
                        size.width = width;

                        if (gutterWidth == null) gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;

                        this.gutterWidth = gutterWidth;

                        this.scrollBarH.element.style.left = this.scroller.style.left = gutterWidth + "px";
                        size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth());

                        this.scrollBarH.element.style.right = this.scroller.style.right = this.scrollBarV.getWidth() + "px";
                        this.scroller.style.bottom = this.scrollBarH.getHeight() + "px";

                        if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force) changes |= this.CHANGE_FULL;
                    }

                    size.$dirty = !width || !height;

                    if (changes) this._signal("resize", oldSize);

                    return changes;
                };

                this.onGutterResize = function () {
                    var gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
                    if (gutterWidth != this.gutterWidth) this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);

                    if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
                        this.$loop.schedule(this.CHANGE_FULL);
                    } else if (this.$size.$dirty) {
                        this.$loop.schedule(this.CHANGE_FULL);
                    } else {
                        this.$computeLayerConfig();
                        this.$loop.schedule(this.CHANGE_MARKER);
                    }
                };
                this.adjustWrapLimit = function () {
                    var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
                    var limit = Math.floor(availableWidth / this.characterWidth);
                    return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
                };
                this.setAnimatedScroll = function (shouldAnimate) {
                    this.setOption("animatedScroll", shouldAnimate);
                };
                this.getAnimatedScroll = function () {
                    return this.$animatedScroll;
                };
                this.setShowInvisibles = function (showInvisibles) {
                    this.setOption("showInvisibles", showInvisibles);
                };
                this.getShowInvisibles = function () {
                    return this.getOption("showInvisibles");
                };
                this.getDisplayIndentGuides = function () {
                    return this.getOption("displayIndentGuides");
                };

                this.setDisplayIndentGuides = function (display) {
                    this.setOption("displayIndentGuides", display);
                };
                this.setShowPrintMargin = function (showPrintMargin) {
                    this.setOption("showPrintMargin", showPrintMargin);
                };
                this.getShowPrintMargin = function () {
                    return this.getOption("showPrintMargin");
                };
                this.setPrintMarginColumn = function (showPrintMargin) {
                    this.setOption("printMarginColumn", showPrintMargin);
                };
                this.getPrintMarginColumn = function () {
                    return this.getOption("printMarginColumn");
                };
                this.getShowGutter = function () {
                    return this.getOption("showGutter");
                };
                this.setShowGutter = function (show) {
                    return this.setOption("showGutter", show);
                };

                this.getFadeFoldWidgets = function () {
                    return this.getOption("fadeFoldWidgets");
                };

                this.setFadeFoldWidgets = function (show) {
                    this.setOption("fadeFoldWidgets", show);
                };

                this.setHighlightGutterLine = function (shouldHighlight) {
                    this.setOption("highlightGutterLine", shouldHighlight);
                };

                this.getHighlightGutterLine = function () {
                    return this.getOption("highlightGutterLine");
                };

                this.$updateGutterLineHighlight = function () {
                    var pos = this.$cursorLayer.$pixelPos;
                    var height = this.layerConfig.lineHeight;
                    if (this.session.getUseWrapMode()) {
                        var cursor = this.session.selection.getCursor();
                        cursor.column = 0;
                        pos = this.$cursorLayer.getPixelPosition(cursor, true);
                        height *= this.session.getRowLength(cursor.row);
                    }
                    this.$gutterLineHighlight.style.top = pos.top - this.layerConfig.offset + "px";
                    this.$gutterLineHighlight.style.height = height + "px";
                };

                this.$updatePrintMargin = function () {
                    if (!this.$showPrintMargin && !this.$printMarginEl) return;

                    if (!this.$printMarginEl) {
                        var containerEl = dom.createElement("div");
                        containerEl.className = "ace_layer ace_print-margin-layer";
                        this.$printMarginEl = dom.createElement("div");
                        this.$printMarginEl.className = "ace_print-margin";
                        containerEl.appendChild(this.$printMarginEl);
                        this.content.insertBefore(containerEl, this.content.firstChild);
                    }

                    var style = this.$printMarginEl.style;
                    style.left = this.characterWidth * this.$printMarginColumn + this.$padding + "px";
                    style.visibility = this.$showPrintMargin ? "visible" : "hidden";

                    if (this.session && this.session.$wrap == -1) this.adjustWrapLimit();
                };
                this.getContainerElement = function () {
                    return this.container;
                };
                this.getMouseEventTarget = function () {
                    return this.scroller;
                };
                this.getTextAreaContainer = function () {
                    return this.container;
                };
                this.$moveTextAreaToCursor = function () {
                    if (!this.$keepTextAreaAtCursor) return;
                    var config = this.layerConfig;
                    var posTop = this.$cursorLayer.$pixelPos.top;
                    var posLeft = this.$cursorLayer.$pixelPos.left;
                    posTop -= config.offset;

                    var style = this.textarea.style;
                    var h = this.lineHeight;
                    if (posTop < 0 || posTop > config.height - h) {
                        style.top = style.left = "0";
                        return;
                    }

                    var w = this.characterWidth;
                    if (this.$composition) {
                        var val = this.textarea.value.replace(/^\x01+/, "");
                        w *= this.session.$getStringScreenWidth(val)[0] + 2;
                        h += 2;
                    }
                    posLeft -= this.scrollLeft;
                    if (posLeft > this.$size.scrollerWidth - w) posLeft = this.$size.scrollerWidth - w;

                    posLeft += this.gutterWidth;
                    style.height = h + "px";
                    style.width = w + "px";
                    style.left = Math.min(posLeft, this.$size.scrollerWidth - w) + "px";
                    style.top = Math.min(posTop, this.$size.height - h) + "px";
                };
                this.getFirstVisibleRow = function () {
                    return this.layerConfig.firstRow;
                };
                this.getFirstFullyVisibleRow = function () {
                    return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
                };
                this.getLastFullyVisibleRow = function () {
                    var config = this.layerConfig;
                    var lastRow = config.lastRow;
                    var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;
                    if (top - this.session.getScrollTop() > config.height - config.lineHeight) return lastRow - 1;
                    return lastRow;
                };
                this.getLastVisibleRow = function () {
                    return this.layerConfig.lastRow;
                };

                this.$padding = null;
                this.setPadding = function (padding) {
                    this.$padding = padding;
                    this.$textLayer.setPadding(padding);
                    this.$cursorLayer.setPadding(padding);
                    this.$markerFront.setPadding(padding);
                    this.$markerBack.setPadding(padding);
                    this.$loop.schedule(this.CHANGE_FULL);
                    this.$updatePrintMargin();
                };

                this.setScrollMargin = function (top, bottom, left, right) {
                    var sm = this.scrollMargin;
                    sm.top = top | 0;
                    sm.bottom = bottom | 0;
                    sm.right = right | 0;
                    sm.left = left | 0;
                    sm.v = sm.top + sm.bottom;
                    sm.h = sm.left + sm.right;
                    if (sm.top && this.scrollTop <= 0 && this.session) this.session.setScrollTop(-sm.top);
                    this.updateFull();
                };
                this.getHScrollBarAlwaysVisible = function () {
                    return this.$hScrollBarAlwaysVisible;
                };
                this.setHScrollBarAlwaysVisible = function (alwaysVisible) {
                    this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
                };
                this.getVScrollBarAlwaysVisible = function () {
                    return this.$vScrollBarAlwaysVisible;
                };
                this.setVScrollBarAlwaysVisible = function (alwaysVisible) {
                    this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
                };

                this.$updateScrollBarV = function () {
                    var scrollHeight = this.layerConfig.maxHeight;
                    var scrollerHeight = this.$size.scrollerHeight;
                    if (!this.$maxLines && this.$scrollPastEnd) {
                        scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
                        if (this.scrollTop > scrollHeight - scrollerHeight) {
                            scrollHeight = this.scrollTop + scrollerHeight;
                            this.scrollBarV.scrollTop = null;
                        }
                    }
                    this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
                    this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
                };
                this.$updateScrollBarH = function () {
                    this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
                    this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
                };

                this.$frozen = false;
                this.freeze = function () {
                    this.$frozen = true;
                };

                this.unfreeze = function () {
                    this.$frozen = false;
                };

                this.$renderChanges = function (changes, force) {
                    if (this.$changes) {
                        changes |= this.$changes;
                        this.$changes = 0;
                    }
                    if (!this.session || !this.container.offsetWidth || this.$frozen || !changes && !force) {
                        this.$changes |= changes;
                        return;
                    }
                    if (this.$size.$dirty) {
                        this.$changes |= changes;
                        return this.onResize(true);
                    }
                    if (!this.lineHeight) {
                        this.$textLayer.checkForSizeChanges();
                    }

                    this._signal("beforeRender");
                    var config = this.layerConfig;
                    if (changes & this.CHANGE_FULL || changes & this.CHANGE_SIZE || changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES || changes & this.CHANGE_SCROLL || changes & this.CHANGE_H_SCROLL) {
                        changes |= this.$computeLayerConfig();
                        if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {
                            var st = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;
                            if (st > 0) {
                                this.scrollTop = st;
                                changes = changes | this.CHANGE_SCROLL;
                                changes |= this.$computeLayerConfig();
                            }
                        }
                        config = this.layerConfig;
                        this.$updateScrollBarV();
                        if (changes & this.CHANGE_H_SCROLL) this.$updateScrollBarH();
                        this.$gutterLayer.element.style.marginTop = -config.offset + "px";
                        this.content.style.marginTop = -config.offset + "px";
                        this.content.style.width = config.width + 2 * this.$padding + "px";
                        this.content.style.height = config.minHeight + "px";
                    }
                    if (changes & this.CHANGE_H_SCROLL) {
                        this.content.style.marginLeft = -this.scrollLeft + "px";
                        this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
                    }
                    if (changes & this.CHANGE_FULL) {
                        this.$textLayer.update(config);
                        if (this.$showGutter) this.$gutterLayer.update(config);
                        this.$markerBack.update(config);
                        this.$markerFront.update(config);
                        this.$cursorLayer.update(config);
                        this.$moveTextAreaToCursor();
                        this.$highlightGutterLine && this.$updateGutterLineHighlight();
                        this._signal("afterRender");
                        return;
                    }
                    if (changes & this.CHANGE_SCROLL) {
                        if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES) this.$textLayer.update(config);else this.$textLayer.scrollLines(config);

                        if (this.$showGutter) this.$gutterLayer.update(config);
                        this.$markerBack.update(config);
                        this.$markerFront.update(config);
                        this.$cursorLayer.update(config);
                        this.$highlightGutterLine && this.$updateGutterLineHighlight();
                        this.$moveTextAreaToCursor();
                        this._signal("afterRender");
                        return;
                    }

                    if (changes & this.CHANGE_TEXT) {
                        this.$textLayer.update(config);
                        if (this.$showGutter) this.$gutterLayer.update(config);
                    } else if (changes & this.CHANGE_LINES) {
                        if (this.$updateLines() || changes & this.CHANGE_GUTTER && this.$showGutter) this.$gutterLayer.update(config);
                    } else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
                        if (this.$showGutter) this.$gutterLayer.update(config);
                    }

                    if (changes & this.CHANGE_CURSOR) {
                        this.$cursorLayer.update(config);
                        this.$moveTextAreaToCursor();
                        this.$highlightGutterLine && this.$updateGutterLineHighlight();
                    }

                    if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
                        this.$markerFront.update(config);
                    }

                    if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
                        this.$markerBack.update(config);
                    }

                    this._signal("afterRender");
                };

                this.$autosize = function () {
                    var height = this.session.getScreenLength() * this.lineHeight;
                    var maxHeight = this.$maxLines * this.lineHeight;
                    var desiredHeight = Math.min(maxHeight, Math.max((this.$minLines || 1) * this.lineHeight, height)) + this.scrollMargin.v + (this.$extraHeight || 0);
                    if (this.$horizScroll) desiredHeight += this.scrollBarH.getHeight();
                    if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight) desiredHeight = this.$maxPixelHeight;
                    var vScroll = height > maxHeight;

                    if (desiredHeight != this.desiredHeight || this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
                        if (vScroll != this.$vScroll) {
                            this.$vScroll = vScroll;
                            this.scrollBarV.setVisible(vScroll);
                        }

                        var w = this.container.clientWidth;
                        this.container.style.height = desiredHeight + "px";
                        this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
                        this.desiredHeight = desiredHeight;

                        this._signal("autosize");
                    }
                };

                this.$computeLayerConfig = function () {
                    var session = this.session;
                    var size = this.$size;

                    var hideScrollbars = size.height <= 2 * this.lineHeight;
                    var screenLines = this.session.getScreenLength();
                    var maxHeight = screenLines * this.lineHeight;

                    var longestLine = this.$getLongestLine();

                    var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible || size.scrollerWidth - longestLine - 2 * this.$padding < 0);

                    var hScrollChanged = this.$horizScroll !== horizScroll;
                    if (hScrollChanged) {
                        this.$horizScroll = horizScroll;
                        this.scrollBarH.setVisible(horizScroll);
                    }
                    var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine
                    if (this.$maxLines && this.lineHeight > 1) this.$autosize();

                    var offset = this.scrollTop % this.lineHeight;
                    var minHeight = size.scrollerHeight + this.lineHeight;

                    var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd : 0;
                    maxHeight += scrollPastEnd;

                    var sm = this.scrollMargin;
                    this.session.setScrollTop(Math.max(-sm.top, Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));

                    this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));

                    var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible || size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
                    var vScrollChanged = vScrollBefore !== vScroll;
                    if (vScrollChanged) {
                        this.$vScroll = vScroll;
                        this.scrollBarV.setVisible(vScroll);
                    }

                    var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
                    var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
                    var lastRow = firstRow + lineCount;
                    var firstRowScreen, firstRowHeight;
                    var lineHeight = this.lineHeight;
                    firstRow = session.screenToDocumentRow(firstRow, 0);
                    var foldLine = session.getFoldLine(firstRow);
                    if (foldLine) {
                        firstRow = foldLine.start.row;
                    }

                    firstRowScreen = session.documentToScreenRow(firstRow, 0);
                    firstRowHeight = session.getRowLength(firstRow) * lineHeight;

                    lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
                    minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight + firstRowHeight;

                    offset = this.scrollTop - firstRowScreen * lineHeight;

                    var changes = 0;
                    if (this.layerConfig.width != longestLine) changes = this.CHANGE_H_SCROLL;
                    if (hScrollChanged || vScrollChanged) {
                        changes = this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
                        this._signal("scrollbarVisibilityChanged");
                        if (vScrollChanged) longestLine = this.$getLongestLine();
                    }

                    this.layerConfig = {
                        width: longestLine,
                        padding: this.$padding,
                        firstRow: firstRow,
                        firstRowScreen: firstRowScreen,
                        lastRow: lastRow,
                        lineHeight: lineHeight,
                        characterWidth: this.characterWidth,
                        minHeight: minHeight,
                        maxHeight: maxHeight,
                        offset: offset,
                        gutterOffset: lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
                        height: this.$size.scrollerHeight
                    };

                    return changes;
                };

                this.$updateLines = function () {
                    var firstRow = this.$changedLines.firstRow;
                    var lastRow = this.$changedLines.lastRow;
                    this.$changedLines = null;

                    var layerConfig = this.layerConfig;

                    if (firstRow > layerConfig.lastRow + 1) {
                        return;
                    }
                    if (lastRow < layerConfig.firstRow) {
                        return;
                    }
                    if (lastRow === Infinity) {
                        if (this.$showGutter) this.$gutterLayer.update(layerConfig);
                        this.$textLayer.update(layerConfig);
                        return;
                    }
                    this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
                    return true;
                };

                this.$getLongestLine = function () {
                    var charCount = this.session.getScreenWidth();
                    if (this.showInvisibles && !this.session.$useWrapMode) charCount += 1;

                    return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
                };
                this.updateFrontMarkers = function () {
                    this.$markerFront.setMarkers(this.session.getMarkers(true));
                    this.$loop.schedule(this.CHANGE_MARKER_FRONT);
                };
                this.updateBackMarkers = function () {
                    this.$markerBack.setMarkers(this.session.getMarkers());
                    this.$loop.schedule(this.CHANGE_MARKER_BACK);
                };
                this.addGutterDecoration = function (row, className) {
                    this.$gutterLayer.addGutterDecoration(row, className);
                };
                this.removeGutterDecoration = function (row, className) {
                    this.$gutterLayer.removeGutterDecoration(row, className);
                };
                this.updateBreakpoints = function (rows) {
                    this.$loop.schedule(this.CHANGE_GUTTER);
                };
                this.setAnnotations = function (annotations) {
                    this.$gutterLayer.setAnnotations(annotations);
                    this.$loop.schedule(this.CHANGE_GUTTER);
                };
                this.updateCursor = function () {
                    this.$loop.schedule(this.CHANGE_CURSOR);
                };
                this.hideCursor = function () {
                    this.$cursorLayer.hideCursor();
                };
                this.showCursor = function () {
                    this.$cursorLayer.showCursor();
                };

                this.scrollSelectionIntoView = function (anchor, lead, offset) {
                    this.scrollCursorIntoView(anchor, offset);
                    this.scrollCursorIntoView(lead, offset);
                };
                this.scrollCursorIntoView = function (cursor, offset, $viewMargin) {
                    if (this.$size.scrollerHeight === 0) return;

                    var pos = this.$cursorLayer.getPixelPosition(cursor);

                    var left = pos.left;
                    var top = pos.top;

                    var topMargin = $viewMargin && $viewMargin.top || 0;
                    var bottomMargin = $viewMargin && $viewMargin.bottom || 0;

                    var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;

                    if (scrollTop + topMargin > top) {
                        if (offset && scrollTop + topMargin > top + this.lineHeight) top -= offset * this.$size.scrollerHeight;
                        if (top === 0) top = -this.scrollMargin.top;
                        this.session.setScrollTop(top);
                    } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {
                        if (offset && scrollTop + this.$size.scrollerHeight - bottomMargin < top - this.lineHeight) top += offset * this.$size.scrollerHeight;
                        this.session.setScrollTop(top + this.lineHeight - this.$size.scrollerHeight);
                    }

                    var scrollLeft = this.scrollLeft;

                    if (scrollLeft > left) {
                        if (left < this.$padding + 2 * this.layerConfig.characterWidth) left = -this.scrollMargin.left;
                        this.session.setScrollLeft(left);
                    } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {
                        this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
                    } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {
                        this.session.setScrollLeft(0);
                    }
                };
                this.getScrollTop = function () {
                    return this.session.getScrollTop();
                };
                this.getScrollLeft = function () {
                    return this.session.getScrollLeft();
                };
                this.getScrollTopRow = function () {
                    return this.scrollTop / this.lineHeight;
                };
                this.getScrollBottomRow = function () {
                    return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
                };
                this.scrollToRow = function (row) {
                    this.session.setScrollTop(row * this.lineHeight);
                };

                this.alignCursor = function (cursor, alignment) {
                    if (typeof cursor == "number") cursor = { row: cursor, column: 0 };

                    var pos = this.$cursorLayer.getPixelPosition(cursor);
                    var h = this.$size.scrollerHeight - this.lineHeight;
                    var offset = pos.top - h * (alignment || 0);

                    this.session.setScrollTop(offset);
                    return offset;
                };

                this.STEPS = 8;
                this.$calcSteps = function (fromValue, toValue) {
                    var i = 0;
                    var l = this.STEPS;
                    var steps = [];

                    var func = function (t, x_min, dx) {
                        return dx * (Math.pow(t - 1, 3) + 1) + x_min;
                    };

                    for (i = 0; i < l; ++i) steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));

                    return steps;
                };
                this.scrollToLine = function (line, center, animate, callback) {
                    var pos = this.$cursorLayer.getPixelPosition({ row: line, column: 0 });
                    var offset = pos.top;
                    if (center) offset -= this.$size.scrollerHeight / 2;

                    var initialScroll = this.scrollTop;
                    this.session.setScrollTop(offset);
                    if (animate !== false) this.animateScrolling(initialScroll, callback);
                };

                this.animateScrolling = function (fromValue, callback) {
                    var toValue = this.scrollTop;
                    if (!this.$animatedScroll) return;
                    var _self = this;

                    if (fromValue == toValue) return;

                    if (this.$scrollAnimation) {
                        var oldSteps = this.$scrollAnimation.steps;
                        if (oldSteps.length) {
                            fromValue = oldSteps[0];
                            if (fromValue == toValue) return;
                        }
                    }

                    var steps = _self.$calcSteps(fromValue, toValue);
                    this.$scrollAnimation = { from: fromValue, to: toValue, steps: steps };

                    clearInterval(this.$timer);

                    _self.session.setScrollTop(steps.shift());
                    _self.session.$scrollTop = toValue;
                    this.$timer = setInterval(function () {
                        if (steps.length) {
                            _self.session.setScrollTop(steps.shift());
                            _self.session.$scrollTop = toValue;
                        } else if (toValue != null) {
                            _self.session.$scrollTop = -1;
                            _self.session.setScrollTop(toValue);
                            toValue = null;
                        } else {
                            _self.$timer = clearInterval(_self.$timer);
                            _self.$scrollAnimation = null;
                            callback && callback();
                        }
                    }, 10);
                };
                this.scrollToY = function (scrollTop) {
                    if (this.scrollTop !== scrollTop) {
                        this.$loop.schedule(this.CHANGE_SCROLL);
                        this.scrollTop = scrollTop;
                    }
                };
                this.scrollToX = function (scrollLeft) {
                    if (this.scrollLeft !== scrollLeft) this.scrollLeft = scrollLeft;
                    this.$loop.schedule(this.CHANGE_H_SCROLL);
                };
                this.scrollTo = function (x, y) {
                    this.session.setScrollTop(y);
                    this.session.setScrollLeft(y);
                };
                this.scrollBy = function (deltaX, deltaY) {
                    deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
                    deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
                };
                this.isScrollableBy = function (deltaX, deltaY) {
                    if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top) return true;
                    if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom) return true;
                    if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left) return true;
                    if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth - this.layerConfig.width < -1 + this.scrollMargin.right) return true;
                };

                this.pixelToScreenCoordinates = function (x, y) {
                    var canvasPos = this.scroller.getBoundingClientRect();

                    var offset = (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth;
                    var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
                    var col = Math.round(offset);

                    return { row: row, column: col, side: offset - col > 0 ? 1 : -1 };
                };

                this.screenToTextCoordinates = function (x, y) {
                    var canvasPos = this.scroller.getBoundingClientRect();

                    var col = Math.round((x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth);

                    var row = (y + this.scrollTop - canvasPos.top) / this.lineHeight;

                    return this.session.screenToDocumentPosition(row, Math.max(col, 0));
                };
                this.textToScreenCoordinates = function (row, column) {
                    var canvasPos = this.scroller.getBoundingClientRect();
                    var pos = this.session.documentToScreenPosition(row, column);

                    var x = this.$padding + Math.round(pos.column * this.characterWidth);
                    var y = pos.row * this.lineHeight;

                    return {
                        pageX: canvasPos.left + x - this.scrollLeft,
                        pageY: canvasPos.top + y - this.scrollTop
                    };
                };
                this.visualizeFocus = function () {
                    dom.addCssClass(this.container, "ace_focus");
                };
                this.visualizeBlur = function () {
                    dom.removeCssClass(this.container, "ace_focus");
                };
                this.showComposition = function (position) {
                    if (!this.$composition) this.$composition = {
                        keepTextAreaAtCursor: this.$keepTextAreaAtCursor,
                        cssText: this.textarea.style.cssText
                    };

                    this.$keepTextAreaAtCursor = true;
                    dom.addCssClass(this.textarea, "ace_composition");
                    this.textarea.style.cssText = "";
                    this.$moveTextAreaToCursor();
                };
                this.setCompositionText = function (text) {
                    this.$moveTextAreaToCursor();
                };
                this.hideComposition = function () {
                    if (!this.$composition) return;

                    dom.removeCssClass(this.textarea, "ace_composition");
                    this.$keepTextAreaAtCursor = this.$composition.keepTextAreaAtCursor;
                    this.textarea.style.cssText = this.$composition.cssText;
                    this.$composition = null;
                };
                this.setTheme = function (theme, cb) {
                    var _self = this;
                    this.$themeId = theme;
                    _self._dispatchEvent('themeChange', { theme: theme });

                    if (!theme || typeof theme == "string") {
                        var moduleName = theme || this.$options.theme.initialValue;
                        config.loadModule(["theme", moduleName], afterLoad);
                    } else {
                        afterLoad(theme);
                    }

                    function afterLoad(module) {
                        if (_self.$themeId != theme) return cb && cb();
                        if (!module || !module.cssClass) throw new Error("couldn't load module " + theme + " or it didn't call define");
                        dom.importCssString(module.cssText, module.cssClass, _self.container.ownerDocument);

                        if (_self.theme) dom.removeCssClass(_self.container, _self.theme.cssClass);

                        var padding = "padding" in module ? module.padding : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
                        if (_self.$padding && padding != _self.$padding) _self.setPadding(padding);
                        _self.$theme = module.cssClass;

                        _self.theme = module;
                        dom.addCssClass(_self.container, module.cssClass);
                        dom.setCssClass(_self.container, "ace_dark", module.isDark);
                        if (_self.$size) {
                            _self.$size.width = 0;
                            _self.$updateSizeAsync();
                        }

                        _self._dispatchEvent('themeLoaded', { theme: module });
                        cb && cb();
                    }
                };
                this.getTheme = function () {
                    return this.$themeId;
                };
                this.setStyle = function (style, include) {
                    dom.setCssClass(this.container, style, include !== false);
                };
                this.unsetStyle = function (style) {
                    dom.removeCssClass(this.container, style);
                };

                this.setCursorStyle = function (style) {
                    if (this.scroller.style.cursor != style) this.scroller.style.cursor = style;
                };
                this.setMouseCursor = function (cursorStyle) {
                    this.scroller.style.cursor = cursorStyle;
                };
                this.destroy = function () {
                    this.$textLayer.destroy();
                    this.$cursorLayer.destroy();
                };
            }).call(VirtualRenderer.prototype);

            config.defineOptions(VirtualRenderer.prototype, "renderer", {
                animatedScroll: { initialValue: false },
                showInvisibles: {
                    set: function (value) {
                        if (this.$textLayer.setShowInvisibles(value)) this.$loop.schedule(this.CHANGE_TEXT);
                    },
                    initialValue: false
                },
                showPrintMargin: {
                    set: function () {
                        this.$updatePrintMargin();
                    },
                    initialValue: true
                },
                printMarginColumn: {
                    set: function () {
                        this.$updatePrintMargin();
                    },
                    initialValue: 80
                },
                printMargin: {
                    set: function (val) {
                        if (typeof val == "number") this.$printMarginColumn = val;
                        this.$showPrintMargin = !!val;
                        this.$updatePrintMargin();
                    },
                    get: function () {
                        return this.$showPrintMargin && this.$printMarginColumn;
                    }
                },
                showGutter: {
                    set: function (show) {
                        this.$gutter.style.display = show ? "block" : "none";
                        this.$loop.schedule(this.CHANGE_FULL);
                        this.onGutterResize();
                    },
                    initialValue: true
                },
                fadeFoldWidgets: {
                    set: function (show) {
                        dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
                    },
                    initialValue: false
                },
                showFoldWidgets: {
                    set: function (show) {
                        this.$gutterLayer.setShowFoldWidgets(show);
                    },
                    initialValue: true
                },
                showLineNumbers: {
                    set: function (show) {
                        this.$gutterLayer.setShowLineNumbers(show);
                        this.$loop.schedule(this.CHANGE_GUTTER);
                    },
                    initialValue: true
                },
                displayIndentGuides: {
                    set: function (show) {
                        if (this.$textLayer.setDisplayIndentGuides(show)) this.$loop.schedule(this.CHANGE_TEXT);
                    },
                    initialValue: true
                },
                highlightGutterLine: {
                    set: function (shouldHighlight) {
                        if (!this.$gutterLineHighlight) {
                            this.$gutterLineHighlight = dom.createElement("div");
                            this.$gutterLineHighlight.className = "ace_gutter-active-line";
                            this.$gutter.appendChild(this.$gutterLineHighlight);
                            return;
                        }

                        this.$gutterLineHighlight.style.display = shouldHighlight ? "" : "none";
                        if (this.$cursorLayer.$pixelPos) this.$updateGutterLineHighlight();
                    },
                    initialValue: false,
                    value: true
                },
                hScrollBarAlwaysVisible: {
                    set: function (val) {
                        if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll) this.$loop.schedule(this.CHANGE_SCROLL);
                    },
                    initialValue: false
                },
                vScrollBarAlwaysVisible: {
                    set: function (val) {
                        if (!this.$vScrollBarAlwaysVisible || !this.$vScroll) this.$loop.schedule(this.CHANGE_SCROLL);
                    },
                    initialValue: false
                },
                fontSize: {
                    set: function (size) {
                        if (typeof size == "number") size = size + "px";
                        this.container.style.fontSize = size;
                        this.updateFontSize();
                    },
                    initialValue: 12
                },
                fontFamily: {
                    set: function (name) {
                        this.container.style.fontFamily = name;
                        this.updateFontSize();
                    }
                },
                maxLines: {
                    set: function (val) {
                        this.updateFull();
                    }
                },
                minLines: {
                    set: function (val) {
                        this.updateFull();
                    }
                },
                maxPixelHeight: {
                    set: function (val) {
                        this.updateFull();
                    },
                    initialValue: 0
                },
                scrollPastEnd: {
                    set: function (val) {
                        val = +val || 0;
                        if (this.$scrollPastEnd == val) return;
                        this.$scrollPastEnd = val;
                        this.$loop.schedule(this.CHANGE_SCROLL);
                    },
                    initialValue: 0,
                    handlesSet: true
                },
                fixedWidthGutter: {
                    set: function (val) {
                        this.$gutterLayer.$fixedWidth = !!val;
                        this.$loop.schedule(this.CHANGE_GUTTER);
                    }
                },
                theme: {
                    set: function (val) {
                        this.setTheme(val);
                    },
                    get: function () {
                        return this.$themeId || this.theme;
                    },
                    initialValue: "./theme/textmate",
                    handlesSet: true
                }
            });

            exports.VirtualRenderer = VirtualRenderer;
        });

        ace.define("ace/worker/worker_client", ["require", "exports", "module", "ace/lib/oop", "ace/lib/net", "ace/lib/event_emitter", "ace/config"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var net = require("../lib/net");
            var EventEmitter = require("../lib/event_emitter").EventEmitter;
            var config = require("../config");

            var WorkerClient = function (topLevelNamespaces, mod, classname, workerUrl) {
                this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
                this.changeListener = this.changeListener.bind(this);
                this.onMessage = this.onMessage.bind(this);
                if (require.nameToUrl && !require.toUrl) require.toUrl = require.nameToUrl;

                if (config.get("packaged") || !require.toUrl) {
                    workerUrl = workerUrl || config.moduleUrl(mod, "worker");
                } else {
                    var normalizePath = this.$normalizePath;
                    workerUrl = workerUrl || normalizePath(require.toUrl("ace/worker/worker.js", null, "_"));

                    var tlns = {};
                    topLevelNamespaces.forEach(function (ns) {
                        tlns[ns] = normalizePath(require.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
                    });
                }

                try {
                    this.$worker = new Worker(workerUrl);
                } catch (e) {
                    if (e instanceof window.DOMException) {
                        var blob = this.$workerBlob(workerUrl);
                        var URL = window.URL || window.webkitURL;
                        var blobURL = URL.createObjectURL(blob);

                        this.$worker = new Worker(blobURL);
                        URL.revokeObjectURL(blobURL);
                    } else {
                        throw e;
                    }
                }
                this.$worker.postMessage({
                    init: true,
                    tlns: tlns,
                    module: mod,
                    classname: classname
                });

                this.callbackId = 1;
                this.callbacks = {};

                this.$worker.onmessage = this.onMessage;
            };

            (function () {

                oop.implement(this, EventEmitter);

                this.onMessage = function (e) {
                    var msg = e.data;
                    switch (msg.type) {
                        case "event":
                            this._signal(msg.name, { data: msg.data });
                            break;
                        case "call":
                            var callback = this.callbacks[msg.id];
                            if (callback) {
                                callback(msg.data);
                                delete this.callbacks[msg.id];
                            }
                            break;
                        case "error":
                            this.reportError(msg.data);
                            break;
                        case "log":
                            window.console && console.log && console.log.apply(console, msg.data);
                            break;
                    }
                };

                this.reportError = function (err) {
                    window.console && console.error && console.error(err);
                };

                this.$normalizePath = function (path) {
                    return net.qualifyURL(path);
                };

                this.terminate = function () {
                    this._signal("terminate", {});
                    this.deltaQueue = null;
                    this.$worker.terminate();
                    this.$worker = null;
                    if (this.$doc) this.$doc.off("change", this.changeListener);
                    this.$doc = null;
                };

                this.send = function (cmd, args) {
                    this.$worker.postMessage({ command: cmd, args: args });
                };

                this.call = function (cmd, args, callback) {
                    if (callback) {
                        var id = this.callbackId++;
                        this.callbacks[id] = callback;
                        args.push(id);
                    }
                    this.send(cmd, args);
                };

                this.emit = function (event, data) {
                    try {
                        this.$worker.postMessage({ event: event, data: { data: data.data } });
                    } catch (ex) {
                        console.error(ex.stack);
                    }
                };

                this.attachToDocument = function (doc) {
                    if (this.$doc) this.terminate();

                    this.$doc = doc;
                    this.call("setValue", [doc.getValue()]);
                    doc.on("change", this.changeListener);
                };

                this.changeListener = function (delta) {
                    if (!this.deltaQueue) {
                        this.deltaQueue = [];
                        setTimeout(this.$sendDeltaQueue, 0);
                    }
                    if (delta.action == "insert") this.deltaQueue.push(delta.start, delta.lines);else this.deltaQueue.push(delta.start, delta.end);
                };

                this.$sendDeltaQueue = function () {
                    var q = this.deltaQueue;
                    if (!q) return;
                    this.deltaQueue = null;
                    if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {
                        this.call("setValue", [this.$doc.getValue()]);
                    } else this.emit("change", { data: q });
                };

                this.$workerBlob = function (workerUrl) {
                    var script = "importScripts('" + net.qualifyURL(workerUrl) + "');";
                    try {
                        return new Blob([script], { "type": "application/javascript" });
                    } catch (e) {
                        // Backwards-compatibility
                        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
                        var blobBuilder = new BlobBuilder();
                        blobBuilder.append(script);
                        return blobBuilder.getBlob("application/javascript");
                    }
                };
            }).call(WorkerClient.prototype);

            var UIWorkerClient = function (topLevelNamespaces, mod, classname) {
                this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
                this.changeListener = this.changeListener.bind(this);
                this.callbackId = 1;
                this.callbacks = {};
                this.messageBuffer = [];

                var main = null;
                var emitSync = false;
                var sender = Object.create(EventEmitter);
                var _self = this;

                this.$worker = {};
                this.$worker.terminate = function () {};
                this.$worker.postMessage = function (e) {
                    _self.messageBuffer.push(e);
                    if (main) {
                        if (emitSync) setTimeout(processNext);else processNext();
                    }
                };
                this.setEmitSync = function (val) {
                    emitSync = val;
                };

                var processNext = function () {
                    var msg = _self.messageBuffer.shift();
                    if (msg.command) main[msg.command].apply(main, msg.args);else if (msg.event) sender._signal(msg.event, msg.data);
                };

                sender.postMessage = function (msg) {
                    _self.onMessage({ data: msg });
                };
                sender.callback = function (data, callbackId) {
                    this.postMessage({ type: "call", id: callbackId, data: data });
                };
                sender.emit = function (name, data) {
                    this.postMessage({ type: "event", name: name, data: data });
                };

                config.loadModule(["worker", mod], function (Main) {
                    main = new Main[classname](sender);
                    while (_self.messageBuffer.length) processNext();
                });
            };

            UIWorkerClient.prototype = WorkerClient.prototype;

            exports.UIWorkerClient = UIWorkerClient;
            exports.WorkerClient = WorkerClient;
        });

        ace.define("ace/placeholder", ["require", "exports", "module", "ace/range", "ace/lib/event_emitter", "ace/lib/oop"], function (require, exports, module) {
            "use strict";

            var Range = require("./range").Range;
            var EventEmitter = require("./lib/event_emitter").EventEmitter;
            var oop = require("./lib/oop");

            var PlaceHolder = function (session, length, pos, others, mainClass, othersClass) {
                var _self = this;
                this.length = length;
                this.session = session;
                this.doc = session.getDocument();
                this.mainClass = mainClass;
                this.othersClass = othersClass;
                this.$onUpdate = this.onUpdate.bind(this);
                this.doc.on("change", this.$onUpdate);
                this.$others = others;

                this.$onCursorChange = function () {
                    setTimeout(function () {
                        _self.onCursorChange();
                    });
                };

                this.$pos = pos;
                var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || { length: -1 };
                this.$undoStackDepth = undoStack.length;
                this.setup();

                session.selection.on("changeCursor", this.$onCursorChange);
            };

            (function () {

                oop.implement(this, EventEmitter);
                this.setup = function () {
                    var _self = this;
                    var doc = this.doc;
                    var session = this.session;

                    this.selectionBefore = session.selection.toJSON();
                    if (session.selection.inMultiSelectMode) session.selection.toSingleRange();

                    this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
                    var pos = this.pos;
                    pos.$insertRight = true;
                    pos.detach();
                    pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
                    this.others = [];
                    this.$others.forEach(function (other) {
                        var anchor = doc.createAnchor(other.row, other.column);
                        anchor.$insertRight = true;
                        anchor.detach();
                        _self.others.push(anchor);
                    });
                    session.setUndoSelect(false);
                };
                this.showOtherMarkers = function () {
                    if (this.othersActive) return;
                    var session = this.session;
                    var _self = this;
                    this.othersActive = true;
                    this.others.forEach(function (anchor) {
                        anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column + _self.length), _self.othersClass, null, false);
                    });
                };
                this.hideOtherMarkers = function () {
                    if (!this.othersActive) return;
                    this.othersActive = false;
                    for (var i = 0; i < this.others.length; i++) {
                        this.session.removeMarker(this.others[i].markerId);
                    }
                };
                this.onUpdate = function (delta) {
                    if (this.$updating) return this.updateAnchors(delta);

                    var range = delta;
                    if (range.start.row !== range.end.row) return;
                    if (range.start.row !== this.pos.row) return;
                    this.$updating = true;
                    var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
                    var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
                    var distanceFromStart = range.start.column - this.pos.column;

                    this.updateAnchors(delta);

                    if (inMainRange) this.length += lengthDiff;

                    if (inMainRange && !this.session.$fromUndo) {
                        if (delta.action === 'insert') {
                            for (var i = this.others.length - 1; i >= 0; i--) {
                                var otherPos = this.others[i];
                                var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
                                this.doc.insertMergedLines(newPos, delta.lines);
                            }
                        } else if (delta.action === 'remove') {
                            for (var i = this.others.length - 1; i >= 0; i--) {
                                var otherPos = this.others[i];
                                var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
                                this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                            }
                        }
                    }

                    this.$updating = false;
                    this.updateMarkers();
                };

                this.updateAnchors = function (delta) {
                    this.pos.onChange(delta);
                    for (var i = this.others.length; i--;) this.others[i].onChange(delta);
                    this.updateMarkers();
                };

                this.updateMarkers = function () {
                    if (this.$updating) return;
                    var _self = this;
                    var session = this.session;
                    var updateMarker = function (pos, className) {
                        session.removeMarker(pos.markerId);
                        pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + _self.length), className, null, false);
                    };
                    updateMarker(this.pos, this.mainClass);
                    for (var i = this.others.length; i--;) updateMarker(this.others[i], this.othersClass);
                };

                this.onCursorChange = function (event) {
                    if (this.$updating || !this.session) return;
                    var pos = this.session.selection.getCursor();
                    if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
                        this.showOtherMarkers();
                        this._emit("cursorEnter", event);
                    } else {
                        this.hideOtherMarkers();
                        this._emit("cursorLeave", event);
                    }
                };
                this.detach = function () {
                    this.session.removeMarker(this.pos && this.pos.markerId);
                    this.hideOtherMarkers();
                    this.doc.removeEventListener("change", this.$onUpdate);
                    this.session.selection.removeEventListener("changeCursor", this.$onCursorChange);
                    this.session.setUndoSelect(true);
                    this.session = null;
                };
                this.cancel = function () {
                    if (this.$undoStackDepth === -1) return;
                    var undoManager = this.session.getUndoManager();
                    var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
                    for (var i = 0; i < undosRequired; i++) {
                        undoManager.undo(true);
                    }
                    if (this.selectionBefore) this.session.selection.fromJSON(this.selectionBefore);
                };
            }).call(PlaceHolder.prototype);

            exports.PlaceHolder = PlaceHolder;
        });

        ace.define("ace/mouse/multi_select_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function (require, exports, module) {

            var event = require("../lib/event");
            var useragent = require("../lib/useragent");
            function isSamePoint(p1, p2) {
                return p1.row == p2.row && p1.column == p2.column;
            }

            function onMouseDown(e) {
                var ev = e.domEvent;
                var alt = ev.altKey;
                var shift = ev.shiftKey;
                var ctrl = ev.ctrlKey;
                var accel = e.getAccelKey();
                var button = e.getButton();

                if (ctrl && useragent.isMac) button = ev.button;

                if (e.editor.inMultiSelectMode && button == 2) {
                    e.editor.textInput.onContextMenu(e.domEvent);
                    return;
                }

                if (!ctrl && !alt && !accel) {
                    if (button === 0 && e.editor.inMultiSelectMode) e.editor.exitMultiSelectMode();
                    return;
                }

                if (button !== 0) return;

                var editor = e.editor;
                var selection = editor.selection;
                var isMultiSelect = editor.inMultiSelectMode;
                var pos = e.getDocumentPosition();
                var cursor = selection.getCursor();
                var inSelection = e.inSelection() || selection.isEmpty() && isSamePoint(pos, cursor);

                var mouseX = e.x,
                    mouseY = e.y;
                var onMouseSelection = function (e) {
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                };

                var session = editor.session;
                var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
                var screenCursor = screenAnchor;

                var selectionMode;
                if (editor.$mouseHandler.$enableJumpToDef) {
                    if (ctrl && alt || accel && alt) selectionMode = shift ? "block" : "add";else if (alt && editor.$blockSelectEnabled) selectionMode = "block";
                } else {
                    if (accel && !alt) {
                        selectionMode = "add";
                        if (!isMultiSelect && shift) return;
                    } else if (alt && editor.$blockSelectEnabled) {
                        selectionMode = "block";
                    }
                }

                if (selectionMode && useragent.isMac && ev.ctrlKey) {
                    editor.$mouseHandler.cancelContextMenu();
                }

                if (selectionMode == "add") {
                    if (!isMultiSelect && inSelection) return; // dragging

                    if (!isMultiSelect) {
                        var range = selection.toOrientedRange();
                        editor.addSelectionMarker(range);
                    }

                    var oldRange = selection.rangeList.rangeAtPoint(pos);

                    editor.$blockScrolling++;
                    editor.inVirtualSelectionMode = true;

                    if (shift) {
                        oldRange = null;
                        range = selection.ranges[0] || range;
                        editor.removeSelectionMarker(range);
                    }
                    editor.once("mouseup", function () {
                        var tmpSel = selection.toOrientedRange();

                        if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor)) selection.substractPoint(tmpSel.cursor);else {
                            if (shift) {
                                selection.substractPoint(range.cursor);
                            } else if (range) {
                                editor.removeSelectionMarker(range);
                                selection.addRange(range);
                            }
                            selection.addRange(tmpSel);
                        }
                        editor.$blockScrolling--;
                        editor.inVirtualSelectionMode = false;
                    });
                } else if (selectionMode == "block") {
                    e.stop();
                    editor.inVirtualSelectionMode = true;
                    var initialRange;
                    var rectSel = [];
                    var blockSelect = function () {
                        var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
                        var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column);

                        if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead)) return;
                        screenCursor = newCursor;

                        editor.$blockScrolling++;
                        editor.selection.moveToPosition(cursor);
                        editor.renderer.scrollCursorIntoView();

                        editor.removeSelectionMarkers(rectSel);
                        rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
                        if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty()) rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
                        rectSel.forEach(editor.addSelectionMarker, editor);
                        editor.updateSelectionMarkers();
                        editor.$blockScrolling--;
                    };
                    editor.$blockScrolling++;
                    if (isMultiSelect && !accel) {
                        selection.toSingleRange();
                    } else if (!isMultiSelect && accel) {
                        initialRange = selection.toOrientedRange();
                        editor.addSelectionMarker(initialRange);
                    }

                    if (shift) screenAnchor = session.documentToScreenPosition(selection.lead);else selection.moveToPosition(pos);
                    editor.$blockScrolling--;

                    screenCursor = { row: -1, column: -1 };

                    var onMouseSelectionEnd = function (e) {
                        clearInterval(timerId);
                        editor.removeSelectionMarkers(rectSel);
                        if (!rectSel.length) rectSel = [selection.toOrientedRange()];
                        editor.$blockScrolling++;
                        if (initialRange) {
                            editor.removeSelectionMarker(initialRange);
                            selection.toSingleRange(initialRange);
                        }
                        for (var i = 0; i < rectSel.length; i++) selection.addRange(rectSel[i]);
                        editor.inVirtualSelectionMode = false;
                        editor.$mouseHandler.$clickSelection = null;
                        editor.$blockScrolling--;
                    };

                    var onSelectionInterval = blockSelect;

                    event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
                    var timerId = setInterval(function () {
                        onSelectionInterval();
                    }, 20);

                    return e.preventDefault();
                }
            }

            exports.onMouseDown = onMouseDown;
        });

        ace.define("ace/commands/multi_select_commands", ["require", "exports", "module", "ace/keyboard/hash_handler"], function (require, exports, module) {
            exports.defaultCommands = [{
                name: "addCursorAbove",
                exec: function (editor) {
                    editor.selectMoreLines(-1);
                },
                bindKey: { win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up" },
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "addCursorBelow",
                exec: function (editor) {
                    editor.selectMoreLines(1);
                },
                bindKey: { win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down" },
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "addCursorAboveSkipCurrent",
                exec: function (editor) {
                    editor.selectMoreLines(-1, true);
                },
                bindKey: { win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up" },
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "addCursorBelowSkipCurrent",
                exec: function (editor) {
                    editor.selectMoreLines(1, true);
                },
                bindKey: { win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down" },
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectMoreBefore",
                exec: function (editor) {
                    editor.selectMore(-1);
                },
                bindKey: { win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left" },
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectMoreAfter",
                exec: function (editor) {
                    editor.selectMore(1);
                },
                bindKey: { win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right" },
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectNextBefore",
                exec: function (editor) {
                    editor.selectMore(-1, true);
                },
                bindKey: { win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left" },
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectNextAfter",
                exec: function (editor) {
                    editor.selectMore(1, true);
                },
                bindKey: { win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right" },
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "splitIntoLines",
                exec: function (editor) {
                    editor.multiSelect.splitIntoLines();
                },
                bindKey: { win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L" },
                readOnly: true
            }, {
                name: "alignCursors",
                exec: function (editor) {
                    editor.alignCursors();
                },
                bindKey: { win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A" },
                scrollIntoView: "cursor"
            }, {
                name: "findAll",
                exec: function (editor) {
                    editor.findAll();
                },
                bindKey: { win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G" },
                scrollIntoView: "cursor",
                readOnly: true
            }];
            exports.multiSelectCommands = [{
                name: "singleSelection",
                bindKey: "esc",
                exec: function (editor) {
                    editor.exitMultiSelectMode();
                },
                scrollIntoView: "cursor",
                readOnly: true,
                isAvailable: function (editor) {
                    return editor && editor.inMultiSelectMode;
                }
            }];

            var HashHandler = require("../keyboard/hash_handler").HashHandler;
            exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);
        });

        ace.define("ace/multi_select", ["require", "exports", "module", "ace/range_list", "ace/range", "ace/selection", "ace/mouse/multi_select_handler", "ace/lib/event", "ace/lib/lang", "ace/commands/multi_select_commands", "ace/search", "ace/edit_session", "ace/editor", "ace/config"], function (require, exports, module) {

            var RangeList = require("./range_list").RangeList;
            var Range = require("./range").Range;
            var Selection = require("./selection").Selection;
            var onMouseDown = require("./mouse/multi_select_handler").onMouseDown;
            var event = require("./lib/event");
            var lang = require("./lib/lang");
            var commands = require("./commands/multi_select_commands");
            exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
            var Search = require("./search").Search;
            var search = new Search();

            function find(session, needle, dir) {
                search.$options.wrap = true;
                search.$options.needle = needle;
                search.$options.backwards = dir == -1;
                return search.find(session);
            }
            var EditSession = require("./edit_session").EditSession;
            (function () {
                this.getSelectionMarkers = function () {
                    return this.$selectionMarkers;
                };
            }).call(EditSession.prototype);
            (function () {
                this.ranges = null;
                this.rangeList = null;
                this.addRange = function (range, $blockChangeEvents) {
                    if (!range) return;

                    if (!this.inMultiSelectMode && this.rangeCount === 0) {
                        var oldRange = this.toOrientedRange();
                        this.rangeList.add(oldRange);
                        this.rangeList.add(range);
                        if (this.rangeList.ranges.length != 2) {
                            this.rangeList.removeAll();
                            return $blockChangeEvents || this.fromOrientedRange(range);
                        }
                        this.rangeList.removeAll();
                        this.rangeList.add(oldRange);
                        this.$onAddRange(oldRange);
                    }

                    if (!range.cursor) range.cursor = range.end;

                    var removed = this.rangeList.add(range);

                    this.$onAddRange(range);

                    if (removed.length) this.$onRemoveRange(removed);

                    if (this.rangeCount > 1 && !this.inMultiSelectMode) {
                        this._signal("multiSelect");
                        this.inMultiSelectMode = true;
                        this.session.$undoSelect = false;
                        this.rangeList.attach(this.session);
                    }

                    return $blockChangeEvents || this.fromOrientedRange(range);
                };

                this.toSingleRange = function (range) {
                    range = range || this.ranges[0];
                    var removed = this.rangeList.removeAll();
                    if (removed.length) this.$onRemoveRange(removed);

                    range && this.fromOrientedRange(range);
                };
                this.substractPoint = function (pos) {
                    var removed = this.rangeList.substractPoint(pos);
                    if (removed) {
                        this.$onRemoveRange(removed);
                        return removed[0];
                    }
                };
                this.mergeOverlappingRanges = function () {
                    var removed = this.rangeList.merge();
                    if (removed.length) this.$onRemoveRange(removed);else if (this.ranges[0]) this.fromOrientedRange(this.ranges[0]);
                };

                this.$onAddRange = function (range) {
                    this.rangeCount = this.rangeList.ranges.length;
                    this.ranges.unshift(range);
                    this._signal("addRange", { range: range });
                };

                this.$onRemoveRange = function (removed) {
                    this.rangeCount = this.rangeList.ranges.length;
                    if (this.rangeCount == 1 && this.inMultiSelectMode) {
                        var lastRange = this.rangeList.ranges.pop();
                        removed.push(lastRange);
                        this.rangeCount = 0;
                    }

                    for (var i = removed.length; i--;) {
                        var index = this.ranges.indexOf(removed[i]);
                        this.ranges.splice(index, 1);
                    }

                    this._signal("removeRange", { ranges: removed });

                    if (this.rangeCount === 0 && this.inMultiSelectMode) {
                        this.inMultiSelectMode = false;
                        this._signal("singleSelect");
                        this.session.$undoSelect = true;
                        this.rangeList.detach(this.session);
                    }

                    lastRange = lastRange || this.ranges[0];
                    if (lastRange && !lastRange.isEqual(this.getRange())) this.fromOrientedRange(lastRange);
                };
                this.$initRangeList = function () {
                    if (this.rangeList) return;

                    this.rangeList = new RangeList();
                    this.ranges = [];
                    this.rangeCount = 0;
                };
                this.getAllRanges = function () {
                    return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
                };

                this.splitIntoLines = function () {
                    if (this.rangeCount > 1) {
                        var ranges = this.rangeList.ranges;
                        var lastRange = ranges[ranges.length - 1];
                        var range = Range.fromPoints(ranges[0].start, lastRange.end);

                        this.toSingleRange();
                        this.setSelectionRange(range, lastRange.cursor == lastRange.start);
                    } else {
                        var range = this.getRange();
                        var isBackwards = this.isBackwards();
                        var startRow = range.start.row;
                        var endRow = range.end.row;
                        if (startRow == endRow) {
                            if (isBackwards) var start = range.end,
                                end = range.start;else var start = range.start,
                                end = range.end;

                            this.addRange(Range.fromPoints(end, end));
                            this.addRange(Range.fromPoints(start, start));
                            return;
                        }

                        var rectSel = [];
                        var r = this.getLineRange(startRow, true);
                        r.start.column = range.start.column;
                        rectSel.push(r);

                        for (var i = startRow + 1; i < endRow; i++) rectSel.push(this.getLineRange(i, true));

                        r = this.getLineRange(endRow, true);
                        r.end.column = range.end.column;
                        rectSel.push(r);

                        rectSel.forEach(this.addRange, this);
                    }
                };
                this.toggleBlockSelection = function () {
                    if (this.rangeCount > 1) {
                        var ranges = this.rangeList.ranges;
                        var lastRange = ranges[ranges.length - 1];
                        var range = Range.fromPoints(ranges[0].start, lastRange.end);

                        this.toSingleRange();
                        this.setSelectionRange(range, lastRange.cursor == lastRange.start);
                    } else {
                        var cursor = this.session.documentToScreenPosition(this.selectionLead);
                        var anchor = this.session.documentToScreenPosition(this.selectionAnchor);

                        var rectSel = this.rectangularRangeBlock(cursor, anchor);
                        rectSel.forEach(this.addRange, this);
                    }
                };
                this.rectangularRangeBlock = function (screenCursor, screenAnchor, includeEmptyLines) {
                    var rectSel = [];

                    var xBackwards = screenCursor.column < screenAnchor.column;
                    if (xBackwards) {
                        var startColumn = screenCursor.column;
                        var endColumn = screenAnchor.column;
                    } else {
                        var startColumn = screenAnchor.column;
                        var endColumn = screenCursor.column;
                    }

                    var yBackwards = screenCursor.row < screenAnchor.row;
                    if (yBackwards) {
                        var startRow = screenCursor.row;
                        var endRow = screenAnchor.row;
                    } else {
                        var startRow = screenAnchor.row;
                        var endRow = screenCursor.row;
                    }

                    if (startColumn < 0) startColumn = 0;
                    if (startRow < 0) startRow = 0;

                    if (startRow == endRow) includeEmptyLines = true;

                    for (var row = startRow; row <= endRow; row++) {
                        var range = Range.fromPoints(this.session.screenToDocumentPosition(row, startColumn), this.session.screenToDocumentPosition(row, endColumn));
                        if (range.isEmpty()) {
                            if (docEnd && isSamePoint(range.end, docEnd)) break;
                            var docEnd = range.end;
                        }
                        range.cursor = xBackwards ? range.start : range.end;
                        rectSel.push(range);
                    }

                    if (yBackwards) rectSel.reverse();

                    if (!includeEmptyLines) {
                        var end = rectSel.length - 1;
                        while (rectSel[end].isEmpty() && end > 0) end--;
                        if (end > 0) {
                            var start = 0;
                            while (rectSel[start].isEmpty()) start++;
                        }
                        for (var i = end; i >= start; i--) {
                            if (rectSel[i].isEmpty()) rectSel.splice(i, 1);
                        }
                    }

                    return rectSel;
                };
            }).call(Selection.prototype);
            var Editor = require("./editor").Editor;
            (function () {
                this.updateSelectionMarkers = function () {
                    this.renderer.updateCursor();
                    this.renderer.updateBackMarkers();
                };
                this.addSelectionMarker = function (orientedRange) {
                    if (!orientedRange.cursor) orientedRange.cursor = orientedRange.end;

                    var style = this.getSelectionStyle();
                    orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);

                    this.session.$selectionMarkers.push(orientedRange);
                    this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
                    return orientedRange;
                };
                this.removeSelectionMarker = function (range) {
                    if (!range.marker) return;
                    this.session.removeMarker(range.marker);
                    var index = this.session.$selectionMarkers.indexOf(range);
                    if (index != -1) this.session.$selectionMarkers.splice(index, 1);
                    this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
                };

                this.removeSelectionMarkers = function (ranges) {
                    var markerList = this.session.$selectionMarkers;
                    for (var i = ranges.length; i--;) {
                        var range = ranges[i];
                        if (!range.marker) continue;
                        this.session.removeMarker(range.marker);
                        var index = markerList.indexOf(range);
                        if (index != -1) markerList.splice(index, 1);
                    }
                    this.session.selectionMarkerCount = markerList.length;
                };

                this.$onAddRange = function (e) {
                    this.addSelectionMarker(e.range);
                    this.renderer.updateCursor();
                    this.renderer.updateBackMarkers();
                };

                this.$onRemoveRange = function (e) {
                    this.removeSelectionMarkers(e.ranges);
                    this.renderer.updateCursor();
                    this.renderer.updateBackMarkers();
                };

                this.$onMultiSelect = function (e) {
                    if (this.inMultiSelectMode) return;
                    this.inMultiSelectMode = true;

                    this.setStyle("ace_multiselect");
                    this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
                    this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);

                    this.renderer.updateCursor();
                    this.renderer.updateBackMarkers();
                };

                this.$onSingleSelect = function (e) {
                    if (this.session.multiSelect.inVirtualMode) return;
                    this.inMultiSelectMode = false;

                    this.unsetStyle("ace_multiselect");
                    this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);

                    this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
                    this.renderer.updateCursor();
                    this.renderer.updateBackMarkers();
                    this._emit("changeSelection");
                };

                this.$onMultiSelectExec = function (e) {
                    var command = e.command;
                    var editor = e.editor;
                    if (!editor.multiSelect) return;
                    if (!command.multiSelectAction) {
                        var result = command.exec(editor, e.args || {});
                        editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
                        editor.multiSelect.mergeOverlappingRanges();
                    } else if (command.multiSelectAction == "forEach") {
                        result = editor.forEachSelection(command, e.args);
                    } else if (command.multiSelectAction == "forEachLine") {
                        result = editor.forEachSelection(command, e.args, true);
                    } else if (command.multiSelectAction == "single") {
                        editor.exitMultiSelectMode();
                        result = command.exec(editor, e.args || {});
                    } else {
                        result = command.multiSelectAction(editor, e.args || {});
                    }
                    return result;
                };
                this.forEachSelection = function (cmd, args, options) {
                    if (this.inVirtualSelectionMode) return;
                    var keepOrder = options && options.keepOrder;
                    var $byLines = options == true || options && options.$byLines;
                    var session = this.session;
                    var selection = this.selection;
                    var rangeList = selection.rangeList;
                    var ranges = (keepOrder ? selection : rangeList).ranges;
                    var result;

                    if (!ranges.length) return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});

                    var reg = selection._eventRegistry;
                    selection._eventRegistry = {};

                    var tmpSel = new Selection(session);
                    this.inVirtualSelectionMode = true;
                    for (var i = ranges.length; i--;) {
                        if ($byLines) {
                            while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row) i--;
                        }
                        tmpSel.fromOrientedRange(ranges[i]);
                        tmpSel.index = i;
                        this.selection = session.selection = tmpSel;
                        var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
                        if (!result && cmdResult !== undefined) result = cmdResult;
                        tmpSel.toOrientedRange(ranges[i]);
                    }
                    tmpSel.detach();

                    this.selection = session.selection = selection;
                    this.inVirtualSelectionMode = false;
                    selection._eventRegistry = reg;
                    selection.mergeOverlappingRanges();

                    var anim = this.renderer.$scrollAnimation;
                    this.onCursorChange();
                    this.onSelectionChange();
                    if (anim && anim.from == anim.to) this.renderer.animateScrolling(anim.from);

                    return result;
                };
                this.exitMultiSelectMode = function () {
                    if (!this.inMultiSelectMode || this.inVirtualSelectionMode) return;
                    this.multiSelect.toSingleRange();
                };

                this.getSelectedText = function () {
                    var text = "";
                    if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
                        var ranges = this.multiSelect.rangeList.ranges;
                        var buf = [];
                        for (var i = 0; i < ranges.length; i++) {
                            buf.push(this.session.getTextRange(ranges[i]));
                        }
                        var nl = this.session.getDocument().getNewLineCharacter();
                        text = buf.join(nl);
                        if (text.length == (buf.length - 1) * nl.length) text = "";
                    } else if (!this.selection.isEmpty()) {
                        text = this.session.getTextRange(this.getSelectionRange());
                    }
                    return text;
                };

                this.$checkMultiselectChange = function (e, anchor) {
                    if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
                        var range = this.multiSelect.ranges[0];
                        if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor) return;
                        var pos = anchor == this.multiSelect.anchor ? range.cursor == range.start ? range.end : range.start : range.cursor;
                        if (pos.row != anchor.row || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column) this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
                    }
                };
                this.findAll = function (needle, options, additive) {
                    options = options || {};
                    options.needle = needle || options.needle;
                    if (options.needle == undefined) {
                        var range = this.selection.isEmpty() ? this.selection.getWordRange() : this.selection.getRange();
                        options.needle = this.session.getTextRange(range);
                    }
                    this.$search.set(options);

                    var ranges = this.$search.findAll(this.session);
                    if (!ranges.length) return 0;

                    this.$blockScrolling += 1;
                    var selection = this.multiSelect;

                    if (!additive) selection.toSingleRange(ranges[0]);

                    for (var i = ranges.length; i--;) selection.addRange(ranges[i], true);
                    if (range && selection.rangeList.rangeAtPoint(range.start)) selection.addRange(range, true);

                    this.$blockScrolling -= 1;

                    return ranges.length;
                };
                this.selectMoreLines = function (dir, skip) {
                    var range = this.selection.toOrientedRange();
                    var isBackwards = range.cursor == range.end;

                    var screenLead = this.session.documentToScreenPosition(range.cursor);
                    if (this.selection.$desiredColumn) screenLead.column = this.selection.$desiredColumn;

                    var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);

                    if (!range.isEmpty()) {
                        var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
                        var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
                    } else {
                        var anchor = lead;
                    }

                    if (isBackwards) {
                        var newRange = Range.fromPoints(lead, anchor);
                        newRange.cursor = newRange.start;
                    } else {
                        var newRange = Range.fromPoints(anchor, lead);
                        newRange.cursor = newRange.end;
                    }

                    newRange.desiredColumn = screenLead.column;
                    if (!this.selection.inMultiSelectMode) {
                        this.selection.addRange(range);
                    } else {
                        if (skip) var toRemove = range.cursor;
                    }

                    this.selection.addRange(newRange);
                    if (toRemove) this.selection.substractPoint(toRemove);
                };
                this.transposeSelections = function (dir) {
                    var session = this.session;
                    var sel = session.multiSelect;
                    var all = sel.ranges;

                    for (var i = all.length; i--;) {
                        var range = all[i];
                        if (range.isEmpty()) {
                            var tmp = session.getWordRange(range.start.row, range.start.column);
                            range.start.row = tmp.start.row;
                            range.start.column = tmp.start.column;
                            range.end.row = tmp.end.row;
                            range.end.column = tmp.end.column;
                        }
                    }
                    sel.mergeOverlappingRanges();

                    var words = [];
                    for (var i = all.length; i--;) {
                        var range = all[i];
                        words.unshift(session.getTextRange(range));
                    }

                    if (dir < 0) words.unshift(words.pop());else words.push(words.shift());

                    for (var i = all.length; i--;) {
                        var range = all[i];
                        var tmp = range.clone();
                        session.replace(range, words[i]);
                        range.start.row = tmp.start.row;
                        range.start.column = tmp.start.column;
                    }
                };
                this.selectMore = function (dir, skip, stopAtFirst) {
                    var session = this.session;
                    var sel = session.multiSelect;

                    var range = sel.toOrientedRange();
                    if (range.isEmpty()) {
                        range = session.getWordRange(range.start.row, range.start.column);
                        range.cursor = dir == -1 ? range.start : range.end;
                        this.multiSelect.addRange(range);
                        if (stopAtFirst) return;
                    }
                    var needle = session.getTextRange(range);

                    var newRange = find(session, needle, dir);
                    if (newRange) {
                        newRange.cursor = dir == -1 ? newRange.start : newRange.end;
                        this.$blockScrolling += 1;
                        this.session.unfold(newRange);
                        this.multiSelect.addRange(newRange);
                        this.$blockScrolling -= 1;
                        this.renderer.scrollCursorIntoView(null, 0.5);
                    }
                    if (skip) this.multiSelect.substractPoint(range.cursor);
                };
                this.alignCursors = function () {
                    var session = this.session;
                    var sel = session.multiSelect;
                    var ranges = sel.ranges;
                    var row = -1;
                    var sameRowRanges = ranges.filter(function (r) {
                        if (r.cursor.row == row) return true;
                        row = r.cursor.row;
                    });

                    if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
                        var range = this.selection.getRange();
                        var fr = range.start.row,
                            lr = range.end.row;
                        var guessRange = fr == lr;
                        if (guessRange) {
                            var max = this.session.getLength();
                            var line;
                            do {
                                line = this.session.getLine(lr);
                            } while (/[=:]/.test(line) && ++lr < max);
                            do {
                                line = this.session.getLine(fr);
                            } while (/[=:]/.test(line) && --fr > 0);

                            if (fr < 0) fr = 0;
                            if (lr >= max) lr = max - 1;
                        }
                        var lines = this.session.removeFullLines(fr, lr);
                        lines = this.$reAlignText(lines, guessRange);
                        this.session.insert({ row: fr, column: 0 }, lines.join("\n") + "\n");
                        if (!guessRange) {
                            range.start.column = 0;
                            range.end.column = lines[lines.length - 1].length;
                        }
                        this.selection.setRange(range);
                    } else {
                        sameRowRanges.forEach(function (r) {
                            sel.substractPoint(r.cursor);
                        });

                        var maxCol = 0;
                        var minSpace = Infinity;
                        var spaceOffsets = ranges.map(function (r) {
                            var p = r.cursor;
                            var line = session.getLine(p.row);
                            var spaceOffset = line.substr(p.column).search(/\S/g);
                            if (spaceOffset == -1) spaceOffset = 0;

                            if (p.column > maxCol) maxCol = p.column;
                            if (spaceOffset < minSpace) minSpace = spaceOffset;
                            return spaceOffset;
                        });
                        ranges.forEach(function (r, i) {
                            var p = r.cursor;
                            var l = maxCol - p.column;
                            var d = spaceOffsets[i] - minSpace;
                            if (l > d) session.insert(p, lang.stringRepeat(" ", l - d));else session.remove(new Range(p.row, p.column, p.row, p.column - l + d));

                            r.start.column = r.end.column = maxCol;
                            r.start.row = r.end.row = p.row;
                            r.cursor = r.end;
                        });
                        sel.fromOrientedRange(ranges[0]);
                        this.renderer.updateCursor();
                        this.renderer.updateBackMarkers();
                    }
                };

                this.$reAlignText = function (lines, forceLeft) {
                    var isLeftAligned = true,
                        isRightAligned = true;
                    var startW, textW, endW;

                    return lines.map(function (line) {
                        var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
                        if (!m) return [line];

                        if (startW == null) {
                            startW = m[1].length;
                            textW = m[2].length;
                            endW = m[3].length;
                            return m;
                        }

                        if (startW + textW + endW != m[1].length + m[2].length + m[3].length) isRightAligned = false;
                        if (startW != m[1].length) isLeftAligned = false;

                        if (startW > m[1].length) startW = m[1].length;
                        if (textW < m[2].length) textW = m[2].length;
                        if (endW > m[3].length) endW = m[3].length;

                        return m;
                    }).map(forceLeft ? alignLeft : isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);

                    function spaces(n) {
                        return lang.stringRepeat(" ", n);
                    }

                    function alignLeft(m) {
                        return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(textW - m[2].length + endW) + m[4].replace(/^([=:])\s+/, "$1 ");
                    }
                    function alignRight(m) {
                        return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2] + spaces(endW, " ") + m[4].replace(/^([=:])\s+/, "$1 ");
                    }
                    function unAlign(m) {
                        return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(endW) + m[4].replace(/^([=:])\s+/, "$1 ");
                    }
                };
            }).call(Editor.prototype);

            function isSamePoint(p1, p2) {
                return p1.row == p2.row && p1.column == p2.column;
            }
            exports.onSessionChange = function (e) {
                var session = e.session;
                if (session && !session.multiSelect) {
                    session.$selectionMarkers = [];
                    session.selection.$initRangeList();
                    session.multiSelect = session.selection;
                }
                this.multiSelect = session && session.multiSelect;

                var oldSession = e.oldSession;
                if (oldSession) {
                    oldSession.multiSelect.off("addRange", this.$onAddRange);
                    oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
                    oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
                    oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
                    oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
                    oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
                }

                if (session) {
                    session.multiSelect.on("addRange", this.$onAddRange);
                    session.multiSelect.on("removeRange", this.$onRemoveRange);
                    session.multiSelect.on("multiSelect", this.$onMultiSelect);
                    session.multiSelect.on("singleSelect", this.$onSingleSelect);
                    session.multiSelect.lead.on("change", this.$checkMultiselectChange);
                    session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
                }

                if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
                    if (session.selection.inMultiSelectMode) this.$onMultiSelect();else this.$onSingleSelect();
                }
            };
            function MultiSelect(editor) {
                if (editor.$multiselectOnSessionChange) return;
                editor.$onAddRange = editor.$onAddRange.bind(editor);
                editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
                editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
                editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
                editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
                editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);

                editor.$multiselectOnSessionChange(editor);
                editor.on("changeSession", editor.$multiselectOnSessionChange);

                editor.on("mousedown", onMouseDown);
                editor.commands.addCommands(commands.defaultCommands);

                addAltCursorListeners(editor);
            }

            function addAltCursorListeners(editor) {
                var el = editor.textInput.getElement();
                var altCursor = false;
                event.addListener(el, "keydown", function (e) {
                    var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
                    if (editor.$blockSelectEnabled && altDown) {
                        if (!altCursor) {
                            editor.renderer.setMouseCursor("crosshair");
                            altCursor = true;
                        }
                    } else if (altCursor) {
                        reset();
                    }
                });

                event.addListener(el, "keyup", reset);
                event.addListener(el, "blur", reset);
                function reset(e) {
                    if (altCursor) {
                        editor.renderer.setMouseCursor("");
                        altCursor = false;
                    }
                }
            }

            exports.MultiSelect = MultiSelect;

            require("./config").defineOptions(Editor.prototype, "editor", {
                enableMultiselect: {
                    set: function (val) {
                        MultiSelect(this);
                        if (val) {
                            this.on("changeSession", this.$multiselectOnSessionChange);
                            this.on("mousedown", onMouseDown);
                        } else {
                            this.off("changeSession", this.$multiselectOnSessionChange);
                            this.off("mousedown", onMouseDown);
                        }
                    },
                    value: true
                },
                enableBlockSelect: {
                    set: function (val) {
                        this.$blockSelectEnabled = val;
                    },
                    value: true
                }
            });
        });

        ace.define("ace/mode/folding/fold_mode", ["require", "exports", "module", "ace/range"], function (require, exports, module) {
            "use strict";

            var Range = require("../../range").Range;

            var FoldMode = exports.FoldMode = function () {};

            (function () {

                this.foldingStartMarker = null;
                this.foldingStopMarker = null;
                this.getFoldWidget = function (session, foldStyle, row) {
                    var line = session.getLine(row);
                    if (this.foldingStartMarker.test(line)) return "start";
                    if (foldStyle == "markbeginend" && this.foldingStopMarker && this.foldingStopMarker.test(line)) return "end";
                    return "";
                };

                this.getFoldWidgetRange = function (session, foldStyle, row) {
                    return null;
                };

                this.indentationBlock = function (session, row, column) {
                    var re = /\S/;
                    var line = session.getLine(row);
                    var startLevel = line.search(re);
                    if (startLevel == -1) return;

                    var startColumn = column || line.length;
                    var maxRow = session.getLength();
                    var startRow = row;
                    var endRow = row;

                    while (++row < maxRow) {
                        var level = session.getLine(row).search(re);

                        if (level == -1) continue;

                        if (level <= startLevel) break;

                        endRow = row;
                    }

                    if (endRow > startRow) {
                        var endColumn = session.getLine(endRow).length;
                        return new Range(startRow, startColumn, endRow, endColumn);
                    }
                };

                this.openingBracketBlock = function (session, bracket, row, column, typeRe) {
                    var start = { row: row, column: column + 1 };
                    var end = session.$findClosingBracket(bracket, start, typeRe);
                    if (!end) return;

                    var fw = session.foldWidgets[end.row];
                    if (fw == null) fw = session.getFoldWidget(end.row);

                    if (fw == "start" && end.row > start.row) {
                        end.row--;
                        end.column = session.getLine(end.row).length;
                    }
                    return Range.fromPoints(start, end);
                };

                this.closingBracketBlock = function (session, bracket, row, column, typeRe) {
                    var end = { row: row, column: column };
                    var start = session.$findOpeningBracket(bracket, end);

                    if (!start) return;

                    start.column++;
                    end.column--;

                    return Range.fromPoints(start, end);
                };
            }).call(FoldMode.prototype);
        });

        ace.define("ace/theme/textmate", ["require", "exports", "module", "ace/lib/dom"], function (require, exports, module) {
            "use strict";

            exports.isDark = false;
            exports.cssClass = "ace-tm";
            exports.cssText = ".ace-tm .ace_gutter {\
background: #f0f0f0;\
color: #333;\
}\
.ace-tm .ace_print-margin {\
width: 1px;\
background: #e8e8e8;\
}\
.ace-tm .ace_fold {\
background-color: #6B72E6;\
}\
.ace-tm {\
background-color: #FFFFFF;\
color: black;\
}\
.ace-tm .ace_cursor {\
color: black;\
}\
.ace-tm .ace_invisible {\
color: rgb(191, 191, 191);\
}\
.ace-tm .ace_storage,\
.ace-tm .ace_keyword {\
color: blue;\
}\
.ace-tm .ace_constant {\
color: rgb(197, 6, 11);\
}\
.ace-tm .ace_constant.ace_buildin {\
color: rgb(88, 72, 246);\
}\
.ace-tm .ace_constant.ace_language {\
color: rgb(88, 92, 246);\
}\
.ace-tm .ace_constant.ace_library {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_invalid {\
background-color: rgba(255, 0, 0, 0.1);\
color: red;\
}\
.ace-tm .ace_support.ace_function {\
color: rgb(60, 76, 114);\
}\
.ace-tm .ace_support.ace_constant {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_support.ace_type,\
.ace-tm .ace_support.ace_class {\
color: rgb(109, 121, 222);\
}\
.ace-tm .ace_keyword.ace_operator {\
color: rgb(104, 118, 135);\
}\
.ace-tm .ace_string {\
color: rgb(3, 106, 7);\
}\
.ace-tm .ace_comment {\
color: rgb(76, 136, 107);\
}\
.ace-tm .ace_comment.ace_doc {\
color: rgb(0, 102, 255);\
}\
.ace-tm .ace_comment.ace_doc.ace_tag {\
color: rgb(128, 159, 191);\
}\
.ace-tm .ace_constant.ace_numeric {\
color: rgb(0, 0, 205);\
}\
.ace-tm .ace_variable {\
color: rgb(49, 132, 149);\
}\
.ace-tm .ace_xml-pe {\
color: rgb(104, 104, 91);\
}\
.ace-tm .ace_entity.ace_name.ace_function {\
color: #0000A2;\
}\
.ace-tm .ace_heading {\
color: rgb(12, 7, 255);\
}\
.ace-tm .ace_list {\
color:rgb(185, 6, 144);\
}\
.ace-tm .ace_meta.ace_tag {\
color:rgb(0, 22, 142);\
}\
.ace-tm .ace_string.ace_regex {\
color: rgb(255, 0, 0)\
}\
.ace-tm .ace_marker-layer .ace_selection {\
background: rgb(181, 213, 255);\
}\
.ace-tm.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px white;\
}\
.ace-tm .ace_marker-layer .ace_step {\
background: rgb(252, 255, 0);\
}\
.ace-tm .ace_marker-layer .ace_stack {\
background: rgb(164, 229, 101);\
}\
.ace-tm .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid rgb(192, 192, 192);\
}\
.ace-tm .ace_marker-layer .ace_active-line {\
background: rgba(0, 0, 0, 0.07);\
}\
.ace-tm .ace_gutter-active-line {\
background-color : #dcdcdc;\
}\
.ace-tm .ace_marker-layer .ace_selected-word {\
background: rgb(250, 250, 255);\
border: 1px solid rgb(200, 200, 250);\
}\
.ace-tm .ace_indent-guide {\
background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\") right repeat-y;\
}\
";

            var dom = require("../lib/dom");
            dom.importCssString(exports.cssText, exports.cssClass);
        });

        ace.define("ace/line_widgets", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/range"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var dom = require("./lib/dom");
            var Range = require("./range").Range;

            function LineWidgets(session) {
                this.session = session;
                this.session.widgetManager = this;
                this.session.getRowLength = this.getRowLength;
                this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
                this.updateOnChange = this.updateOnChange.bind(this);
                this.renderWidgets = this.renderWidgets.bind(this);
                this.measureWidgets = this.measureWidgets.bind(this);
                this.session._changedWidgets = [];
                this.$onChangeEditor = this.$onChangeEditor.bind(this);

                this.session.on("change", this.updateOnChange);
                this.session.on("changeFold", this.updateOnFold);
                this.session.on("changeEditor", this.$onChangeEditor);
            }

            (function () {
                this.getRowLength = function (row) {
                    var h;
                    if (this.lineWidgets) h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;else h = 0;
                    if (!this.$useWrapMode || !this.$wrapData[row]) {
                        return 1 + h;
                    } else {
                        return this.$wrapData[row].length + 1 + h;
                    }
                };

                this.$getWidgetScreenLength = function () {
                    var screenRows = 0;
                    this.lineWidgets.forEach(function (w) {
                        if (w && w.rowCount && !w.hidden) screenRows += w.rowCount;
                    });
                    return screenRows;
                };

                this.$onChangeEditor = function (e) {
                    this.attach(e.editor);
                };

                this.attach = function (editor) {
                    if (editor && editor.widgetManager && editor.widgetManager != this) editor.widgetManager.detach();

                    if (this.editor == editor) return;

                    this.detach();
                    this.editor = editor;

                    if (editor) {
                        editor.widgetManager = this;
                        editor.renderer.on("beforeRender", this.measureWidgets);
                        editor.renderer.on("afterRender", this.renderWidgets);
                    }
                };
                this.detach = function (e) {
                    var editor = this.editor;
                    if (!editor) return;

                    this.editor = null;
                    editor.widgetManager = null;

                    editor.renderer.off("beforeRender", this.measureWidgets);
                    editor.renderer.off("afterRender", this.renderWidgets);
                    var lineWidgets = this.session.lineWidgets;
                    lineWidgets && lineWidgets.forEach(function (w) {
                        if (w && w.el && w.el.parentNode) {
                            w._inDocument = false;
                            w.el.parentNode.removeChild(w.el);
                        }
                    });
                };

                this.updateOnFold = function (e, session) {
                    var lineWidgets = session.lineWidgets;
                    if (!lineWidgets || !e.action) return;
                    var fold = e.data;
                    var start = fold.start.row;
                    var end = fold.end.row;
                    var hide = e.action == "add";
                    for (var i = start + 1; i < end; i++) {
                        if (lineWidgets[i]) lineWidgets[i].hidden = hide;
                    }
                    if (lineWidgets[end]) {
                        if (hide) {
                            if (!lineWidgets[start]) lineWidgets[start] = lineWidgets[end];else lineWidgets[end].hidden = hide;
                        } else {
                            if (lineWidgets[start] == lineWidgets[end]) lineWidgets[start] = undefined;
                            lineWidgets[end].hidden = hide;
                        }
                    }
                };

                this.updateOnChange = function (delta) {
                    var lineWidgets = this.session.lineWidgets;
                    if (!lineWidgets) return;

                    var startRow = delta.start.row;
                    var len = delta.end.row - startRow;

                    if (len === 0) {} else if (delta.action == 'remove') {
                        var removed = lineWidgets.splice(startRow + 1, len);
                        removed.forEach(function (w) {
                            w && this.removeLineWidget(w);
                        }, this);
                        this.$updateRows();
                    } else {
                        var args = new Array(len);
                        args.unshift(startRow, 0);
                        lineWidgets.splice.apply(lineWidgets, args);
                        this.$updateRows();
                    }
                };

                this.$updateRows = function () {
                    var lineWidgets = this.session.lineWidgets;
                    if (!lineWidgets) return;
                    var noWidgets = true;
                    lineWidgets.forEach(function (w, i) {
                        if (w) {
                            noWidgets = false;
                            w.row = i;
                            while (w.$oldWidget) {
                                w.$oldWidget.row = i;
                                w = w.$oldWidget;
                            }
                        }
                    });
                    if (noWidgets) this.session.lineWidgets = null;
                };

                this.addLineWidget = function (w) {
                    if (!this.session.lineWidgets) this.session.lineWidgets = new Array(this.session.getLength());

                    var old = this.session.lineWidgets[w.row];
                    if (old) {
                        w.$oldWidget = old;
                        if (old.el && old.el.parentNode) {
                            old.el.parentNode.removeChild(old.el);
                            old._inDocument = false;
                        }
                    }

                    this.session.lineWidgets[w.row] = w;

                    w.session = this.session;

                    var renderer = this.editor.renderer;
                    if (w.html && !w.el) {
                        w.el = dom.createElement("div");
                        w.el.innerHTML = w.html;
                    }
                    if (w.el) {
                        dom.addCssClass(w.el, "ace_lineWidgetContainer");
                        w.el.style.position = "absolute";
                        w.el.style.zIndex = 5;
                        renderer.container.appendChild(w.el);
                        w._inDocument = true;
                    }

                    if (!w.coverGutter) {
                        w.el.style.zIndex = 3;
                    }
                    if (w.pixelHeight == null) {
                        w.pixelHeight = w.el.offsetHeight;
                    }
                    if (w.rowCount == null) {
                        w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
                    }

                    var fold = this.session.getFoldAt(w.row, 0);
                    w.$fold = fold;
                    if (fold) {
                        var lineWidgets = this.session.lineWidgets;
                        if (w.row == fold.end.row && !lineWidgets[fold.start.row]) lineWidgets[fold.start.row] = w;else w.hidden = true;
                    }

                    this.session._emit("changeFold", { data: { start: { row: w.row } } });

                    this.$updateRows();
                    this.renderWidgets(null, renderer);
                    this.onWidgetChanged(w);
                    return w;
                };

                this.removeLineWidget = function (w) {
                    w._inDocument = false;
                    w.session = null;
                    if (w.el && w.el.parentNode) w.el.parentNode.removeChild(w.el);
                    if (w.editor && w.editor.destroy) try {
                        w.editor.destroy();
                    } catch (e) {}
                    if (this.session.lineWidgets) {
                        var w1 = this.session.lineWidgets[w.row];
                        if (w1 == w) {
                            this.session.lineWidgets[w.row] = w.$oldWidget;
                            if (w.$oldWidget) this.onWidgetChanged(w.$oldWidget);
                        } else {
                            while (w1) {
                                if (w1.$oldWidget == w) {
                                    w1.$oldWidget = w.$oldWidget;
                                    break;
                                }
                                w1 = w1.$oldWidget;
                            }
                        }
                    }
                    this.session._emit("changeFold", { data: { start: { row: w.row } } });
                    this.$updateRows();
                };

                this.getWidgetsAtRow = function (row) {
                    var lineWidgets = this.session.lineWidgets;
                    var w = lineWidgets && lineWidgets[row];
                    var list = [];
                    while (w) {
                        list.push(w);
                        w = w.$oldWidget;
                    }
                    return list;
                };

                this.onWidgetChanged = function (w) {
                    this.session._changedWidgets.push(w);
                    this.editor && this.editor.renderer.updateFull();
                };

                this.measureWidgets = function (e, renderer) {
                    var changedWidgets = this.session._changedWidgets;
                    var config = renderer.layerConfig;

                    if (!changedWidgets || !changedWidgets.length) return;
                    var min = Infinity;
                    for (var i = 0; i < changedWidgets.length; i++) {
                        var w = changedWidgets[i];
                        if (!w || !w.el) continue;
                        if (w.session != this.session) continue;
                        if (!w._inDocument) {
                            if (this.session.lineWidgets[w.row] != w) continue;
                            w._inDocument = true;
                            renderer.container.appendChild(w.el);
                        }

                        w.h = w.el.offsetHeight;

                        if (!w.fixedWidth) {
                            w.w = w.el.offsetWidth;
                            w.screenWidth = Math.ceil(w.w / config.characterWidth);
                        }

                        var rowCount = w.h / config.lineHeight;
                        if (w.coverLine) {
                            rowCount -= this.session.getRowLineCount(w.row);
                            if (rowCount < 0) rowCount = 0;
                        }
                        if (w.rowCount != rowCount) {
                            w.rowCount = rowCount;
                            if (w.row < min) min = w.row;
                        }
                    }
                    if (min != Infinity) {
                        this.session._emit("changeFold", { data: { start: { row: min } } });
                        this.session.lineWidgetWidth = null;
                    }
                    this.session._changedWidgets = [];
                };

                this.renderWidgets = function (e, renderer) {
                    var config = renderer.layerConfig;
                    var lineWidgets = this.session.lineWidgets;
                    if (!lineWidgets) return;
                    var first = Math.min(this.firstRow, config.firstRow);
                    var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);

                    while (first > 0 && !lineWidgets[first]) first--;

                    this.firstRow = config.firstRow;
                    this.lastRow = config.lastRow;

                    renderer.$cursorLayer.config = config;
                    for (var i = first; i <= last; i++) {
                        var w = lineWidgets[i];
                        if (!w || !w.el) continue;
                        if (w.hidden) {
                            w.el.style.top = -100 - (w.pixelHeight || 0) + "px";
                            continue;
                        }
                        if (!w._inDocument) {
                            w._inDocument = true;
                            renderer.container.appendChild(w.el);
                        }
                        var top = renderer.$cursorLayer.getPixelPosition({ row: i, column: 0 }, true).top;
                        if (!w.coverLine) top += config.lineHeight * this.session.getRowLineCount(w.row);
                        w.el.style.top = top - config.offset + "px";

                        var left = w.coverGutter ? 0 : renderer.gutterWidth;
                        if (!w.fixedWidth) left -= renderer.scrollLeft;
                        w.el.style.left = left + "px";

                        if (w.fullWidth && w.screenWidth) {
                            w.el.style.minWidth = config.width + 2 * config.padding + "px";
                        }

                        if (w.fixedWidth) {
                            w.el.style.right = renderer.scrollBar.getWidth() + "px";
                        } else {
                            w.el.style.right = "";
                        }
                    }
                };
            }).call(LineWidgets.prototype);

            exports.LineWidgets = LineWidgets;
        });

        ace.define("ace/ext/error_marker", ["require", "exports", "module", "ace/line_widgets", "ace/lib/dom", "ace/range"], function (require, exports, module) {
            "use strict";

            var LineWidgets = require("../line_widgets").LineWidgets;
            var dom = require("../lib/dom");
            var Range = require("../range").Range;

            function binarySearch(array, needle, comparator) {
                var first = 0;
                var last = array.length - 1;

                while (first <= last) {
                    var mid = first + last >> 1;
                    var c = comparator(needle, array[mid]);
                    if (c > 0) first = mid + 1;else if (c < 0) last = mid - 1;else return mid;
                }
                return -(first + 1);
            }

            function findAnnotations(session, row, dir) {
                var annotations = session.getAnnotations().sort(Range.comparePoints);
                if (!annotations.length) return;

                var i = binarySearch(annotations, { row: row, column: -1 }, Range.comparePoints);
                if (i < 0) i = -i - 1;

                if (i >= annotations.length) i = dir > 0 ? 0 : annotations.length - 1;else if (i === 0 && dir < 0) i = annotations.length - 1;

                var annotation = annotations[i];
                if (!annotation || !dir) return;

                if (annotation.row === row) {
                    do {
                        annotation = annotations[i += dir];
                    } while (annotation && annotation.row === row);
                    if (!annotation) return annotations.slice();
                }

                var matched = [];
                row = annotation.row;
                do {
                    matched[dir < 0 ? "unshift" : "push"](annotation);
                    annotation = annotations[i += dir];
                } while (annotation && annotation.row == row);
                return matched.length && matched;
            }

            exports.showErrorMarker = function (editor, dir) {
                var session = editor.session;
                if (!session.widgetManager) {
                    session.widgetManager = new LineWidgets(session);
                    session.widgetManager.attach(editor);
                }

                var pos = editor.getCursorPosition();
                var row = pos.row;
                var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function (w) {
                    return w.type == "errorMarker";
                })[0];
                if (oldWidget) {
                    oldWidget.destroy();
                } else {
                    row -= dir;
                }
                var annotations = findAnnotations(session, row, dir);
                var gutterAnno;
                if (annotations) {
                    var annotation = annotations[0];
                    pos.column = (annotation.pos && typeof annotation.column != "number" ? annotation.pos.sc : annotation.column) || 0;
                    pos.row = annotation.row;
                    gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
                } else if (oldWidget) {
                    return;
                } else {
                    gutterAnno = {
                        text: ["Looks good!"],
                        className: "ace_ok"
                    };
                }
                editor.session.unfold(pos.row);
                editor.selection.moveToPosition(pos);

                var w = {
                    row: pos.row,
                    fixedWidth: true,
                    coverGutter: true,
                    el: dom.createElement("div"),
                    type: "errorMarker"
                };
                var el = w.el.appendChild(dom.createElement("div"));
                var arrow = w.el.appendChild(dom.createElement("div"));
                arrow.className = "error_widget_arrow " + gutterAnno.className;

                var left = editor.renderer.$cursorLayer.getPixelPosition(pos).left;
                arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";

                w.el.className = "error_widget_wrapper";
                el.className = "error_widget " + gutterAnno.className;
                el.innerHTML = gutterAnno.text.join("<br>");

                el.appendChild(dom.createElement("div"));

                var kb = function (_, hashId, keyString) {
                    if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
                        w.destroy();
                        return { command: "null" };
                    }
                };

                w.destroy = function () {
                    if (editor.$mouseHandler.isMousePressed) return;
                    editor.keyBinding.removeKeyboardHandler(kb);
                    session.widgetManager.removeLineWidget(w);
                    editor.off("changeSelection", w.destroy);
                    editor.off("changeSession", w.destroy);
                    editor.off("mouseup", w.destroy);
                    editor.off("change", w.destroy);
                };

                editor.keyBinding.addKeyboardHandler(kb);
                editor.on("changeSelection", w.destroy);
                editor.on("changeSession", w.destroy);
                editor.on("mouseup", w.destroy);
                editor.on("change", w.destroy);

                editor.session.widgetManager.addLineWidget(w);

                w.el.onmousedown = editor.focus.bind(editor);

                editor.renderer.scrollCursorIntoView(null, 0.5, { bottom: w.el.offsetHeight });
            };

            dom.importCssString("\
    .error_widget_wrapper {\
        background: inherit;\
        color: inherit;\
        border:none\
    }\
    .error_widget {\
        border-top: solid 2px;\
        border-bottom: solid 2px;\
        margin: 5px 0;\
        padding: 10px 40px;\
        white-space: pre-wrap;\
    }\
    .error_widget.ace_error, .error_widget_arrow.ace_error{\
        border-color: #ff5a5a\
    }\
    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\
        border-color: #F1D817\
    }\
    .error_widget.ace_info, .error_widget_arrow.ace_info{\
        border-color: #5a5a5a\
    }\
    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\
        border-color: #5aaa5a\
    }\
    .error_widget_arrow {\
        position: absolute;\
        border: solid 5px;\
        border-top-color: transparent!important;\
        border-right-color: transparent!important;\
        border-left-color: transparent!important;\
        top: -5px;\
    }\
", "");
        });

        ace.define("ace/ace", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/dom", "ace/lib/event", "ace/editor", "ace/edit_session", "ace/undomanager", "ace/virtual_renderer", "ace/worker/worker_client", "ace/keyboard/hash_handler", "ace/placeholder", "ace/multi_select", "ace/mode/folding/fold_mode", "ace/theme/textmate", "ace/ext/error_marker", "ace/config"], function (require, exports, module) {
            "use strict";

            require("./lib/fixoldbrowsers");

            var dom = require("./lib/dom");
            var event = require("./lib/event");

            var Editor = require("./editor").Editor;
            var EditSession = require("./edit_session").EditSession;
            var UndoManager = require("./undomanager").UndoManager;
            var Renderer = require("./virtual_renderer").VirtualRenderer;
            require("./worker/worker_client");
            require("./keyboard/hash_handler");
            require("./placeholder");
            require("./multi_select");
            require("./mode/folding/fold_mode");
            require("./theme/textmate");
            require("./ext/error_marker");

            exports.config = require("./config");
            exports.require = require;

            if (typeof define === "function") exports.define = define;
            exports.edit = function (el) {
                if (typeof el == "string") {
                    var _id = el;
                    el = document.getElementById(_id);
                    if (!el) throw new Error("ace.edit can't find div #" + _id);
                }

                if (el && el.env && el.env.editor instanceof Editor) return el.env.editor;

                var value = "";
                if (el && /input|textarea/i.test(el.tagName)) {
                    var oldNode = el;
                    value = oldNode.value;
                    el = dom.createElement("pre");
                    oldNode.parentNode.replaceChild(el, oldNode);
                } else if (el) {
                    value = dom.getInnerText(el);
                    el.innerHTML = "";
                }

                var doc = exports.createEditSession(value);

                var editor = new Editor(new Renderer(el));
                editor.setSession(doc);

                var env = {
                    document: doc,
                    editor: editor,
                    onResize: editor.resize.bind(editor, null)
                };
                if (oldNode) env.textarea = oldNode;
                event.addListener(window, "resize", env.onResize);
                editor.on("destroy", function () {
                    event.removeListener(window, "resize", env.onResize);
                    env.editor.container.env = null; // prevent memory leak on old ie
                });
                editor.container.env = editor.env = env;
                return editor;
            };
            exports.createEditSession = function (text, mode) {
                var doc = new EditSession(text, mode);
                doc.setUndoManager(new UndoManager());
                return doc;
            };
            exports.EditSession = EditSession;
            exports.UndoManager = UndoManager;
            exports.version = "1.2.6";
        });
        (function () {
            ace.require(["ace/ace"], function (a) {
                if (a) {
                    a.config.init(true);
                    a.define = ace.define;
                }
                if (!window.ace) window.ace = a;
                for (var key in a) if (a.hasOwnProperty(key)) window.ace[key] = a[key];
            });
        })();
    })(this);

    return _retrieveGlobal();
});
System.registerDynamic("github:ajaxorg/ace-builds@1.2.6.json", [], false, function() {
  return {
    "main": "ace",
    "format": "global",
    "map": {
      "ace": "."
    },
    "meta": {
      "ace.js": {
        "exports": "ace",
        "format": "global"
      },
      "*.js": {
        "deps": [
          "ace/ace"
        ],
        "format": "global"
      }
    }
  };
});

System.registerDynamic("github:ajaxorg/ace-builds@1.2.6/worker-javascript.js", ["ace/ace"], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    "no use strict";

    ;(function (window) {
      if (typeof window.window != "undefined" && window.document) return;
      if (window.require && window.define) return;

      if (!window.console) {
        window.console = function () {
          var msgs = Array.prototype.slice.call(arguments, 0);
          postMessage({ type: "log", data: msgs });
        };
        window.console.error = window.console.warn = window.console.log = window.console.trace = window.console;
      }
      window.window = window;
      window.ace = window;

      window.onerror = function (message, file, line, col, err) {
        postMessage({ type: "error", data: {
            message: message,
            data: err.data,
            file: file,
            line: line,
            col: col,
            stack: err.stack
          } });
      };

      window.normalizeModule = function (parentId, moduleName) {
        // normalize plugin requires
        if (moduleName.indexOf("!") !== -1) {
          var chunks = moduleName.split("!");
          return window.normalizeModule(parentId, chunks[0]) + "!" + window.normalizeModule(parentId, chunks[1]);
        }
        // normalize relative requires
        if (moduleName.charAt(0) == ".") {
          var base = parentId.split("/").slice(0, -1).join("/");
          moduleName = (base ? base + "/" : "") + moduleName;

          while (moduleName.indexOf(".") !== -1 && previous != moduleName) {
            var previous = moduleName;
            moduleName = moduleName.replace(/^\.\//, "").replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
          }
        }

        return moduleName;
      };

      window.require = function require(parentId, id) {
        if (!id) {
          id = parentId;
          parentId = null;
        }
        if (!id.charAt) throw new Error("worker.js require() accepts only (parentId, id) as arguments");

        id = window.normalizeModule(parentId, id);

        var module = window.require.modules[id];
        if (module) {
          if (!module.initialized) {
            module.initialized = true;
            module.exports = module.factory().exports;
          }
          return module.exports;
        }

        if (!window.require.tlns) return console.log("unable to load " + id);

        var path = resolveModuleId(id, window.require.tlns);
        if (path.slice(-3) != ".js") path += ".js";

        window.require.id = id;
        window.require.modules[id] = {}; // prevent infinite loop on broken modules
        importScripts(path);
        return window.require(parentId, id);
      };
      function resolveModuleId(id, paths) {
        var testPath = id,
            tail = "";
        while (testPath) {
          var alias = paths[testPath];
          if (typeof alias == "string") {
            return alias + tail;
          } else if (alias) {
            return alias.location.replace(/\/*$/, "/") + (tail || alias.main || alias.name);
          } else if (alias === false) {
            return "";
          }
          var i = testPath.lastIndexOf("/");
          if (i === -1) break;
          tail = testPath.substr(i) + tail;
          testPath = testPath.slice(0, i);
        }
        return id;
      }
      window.require.modules = {};
      window.require.tlns = {};

      window.define = function (id, deps, factory) {
        if (arguments.length == 2) {
          factory = deps;
          if (typeof id != "string") {
            deps = id;
            id = window.require.id;
          }
        } else if (arguments.length == 1) {
          factory = id;
          deps = [];
          id = window.require.id;
        }

        if (typeof factory != "function") {
          window.require.modules[id] = {
            exports: factory,
            initialized: true
          };
          return;
        }

        if (!deps.length)
          // If there is no dependencies, we inject "require", "exports" and
          // "module" as dependencies, to provide CommonJS compatibility.
          deps = ["require", "exports", "module"];

        var req = function (childId) {
          return window.require(id, childId);
        };

        window.require.modules[id] = {
          exports: {},
          factory: function () {
            var module = this;
            var returnExports = factory.apply(this, deps.map(function (dep) {
              switch (dep) {
                // Because "require", "exports" and "module" aren't actual
                // dependencies, we must handle them seperately.
                case "require":
                  return req;
                case "exports":
                  return module.exports;
                case "module":
                  return module;
                // But for all other dependencies, we can just go ahead and
                // require them.
                default:
                  return req(dep);
              }
            }));
            if (returnExports) module.exports = returnExports;
            return module;
          }
        };
      };
      window.define.amd = {};
      require.tlns = {};
      window.initBaseUrls = function initBaseUrls(topLevelNamespaces) {
        for (var i in topLevelNamespaces) require.tlns[i] = topLevelNamespaces[i];
      };

      window.initSender = function initSender() {

        var EventEmitter = window.require("ace/lib/event_emitter").EventEmitter;
        var oop = window.require("ace/lib/oop");

        var Sender = function () {};

        (function () {

          oop.implement(this, EventEmitter);

          this.callback = function (data, callbackId) {
            postMessage({
              type: "call",
              id: callbackId,
              data: data
            });
          };

          this.emit = function (name, data) {
            postMessage({
              type: "event",
              name: name,
              data: data
            });
          };
        }).call(Sender.prototype);

        return new Sender();
      };

      var main = window.main = null;
      var sender = window.sender = null;

      window.onmessage = function (e) {
        var msg = e.data;
        if (msg.event && sender) {
          sender._signal(msg.event, msg.data);
        } else if (msg.command) {
          if (main[msg.command]) main[msg.command].apply(main, msg.args);else if (window[msg.command]) window[msg.command].apply(window, msg.args);else throw new Error("Unknown command:" + msg.command);
        } else if (msg.init) {
          window.initBaseUrls(msg.tlns);
          require("ace/lib/es5-shim");
          sender = window.sender = window.initSender();
          var clazz = require(msg.module)[msg.classname];
          main = window.main = new clazz(sender);
        }
      };
    })(this);

    ace.define("ace/lib/oop", ["require", "exports", "module"], function (require, exports, module) {
      "use strict";

      exports.inherits = function (ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };

      exports.mixin = function (obj, mixin) {
        for (var key in mixin) {
          obj[key] = mixin[key];
        }
        return obj;
      };

      exports.implement = function (proto, mixin) {
        exports.mixin(proto, mixin);
      };
    });

    ace.define("ace/range", ["require", "exports", "module"], function (require, exports, module) {
      "use strict";

      var comparePoints = function (p1, p2) {
        return p1.row - p2.row || p1.column - p2.column;
      };
      var Range = function (startRow, startColumn, endRow, endColumn) {
        this.start = {
          row: startRow,
          column: startColumn
        };

        this.end = {
          row: endRow,
          column: endColumn
        };
      };

      (function () {
        this.isEqual = function (range) {
          return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;
        };
        this.toString = function () {
          return "Range: [" + this.start.row + "/" + this.start.column + "] -> [" + this.end.row + "/" + this.end.column + "]";
        };

        this.contains = function (row, column) {
          return this.compare(row, column) == 0;
        };
        this.compareRange = function (range) {
          var cmp,
              end = range.end,
              start = range.start;

          cmp = this.compare(end.row, end.column);
          if (cmp == 1) {
            cmp = this.compare(start.row, start.column);
            if (cmp == 1) {
              return 2;
            } else if (cmp == 0) {
              return 1;
            } else {
              return 0;
            }
          } else if (cmp == -1) {
            return -2;
          } else {
            cmp = this.compare(start.row, start.column);
            if (cmp == -1) {
              return -1;
            } else if (cmp == 1) {
              return 42;
            } else {
              return 0;
            }
          }
        };
        this.comparePoint = function (p) {
          return this.compare(p.row, p.column);
        };
        this.containsRange = function (range) {
          return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
        };
        this.intersects = function (range) {
          var cmp = this.compareRange(range);
          return cmp == -1 || cmp == 0 || cmp == 1;
        };
        this.isEnd = function (row, column) {
          return this.end.row == row && this.end.column == column;
        };
        this.isStart = function (row, column) {
          return this.start.row == row && this.start.column == column;
        };
        this.setStart = function (row, column) {
          if (typeof row == "object") {
            this.start.column = row.column;
            this.start.row = row.row;
          } else {
            this.start.row = row;
            this.start.column = column;
          }
        };
        this.setEnd = function (row, column) {
          if (typeof row == "object") {
            this.end.column = row.column;
            this.end.row = row.row;
          } else {
            this.end.row = row;
            this.end.column = column;
          }
        };
        this.inside = function (row, column) {
          if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column) || this.isStart(row, column)) {
              return false;
            } else {
              return true;
            }
          }
          return false;
        };
        this.insideStart = function (row, column) {
          if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column)) {
              return false;
            } else {
              return true;
            }
          }
          return false;
        };
        this.insideEnd = function (row, column) {
          if (this.compare(row, column) == 0) {
            if (this.isStart(row, column)) {
              return false;
            } else {
              return true;
            }
          }
          return false;
        };
        this.compare = function (row, column) {
          if (!this.isMultiLine()) {
            if (row === this.start.row) {
              return column < this.start.column ? -1 : column > this.end.column ? 1 : 0;
            }
          }

          if (row < this.start.row) return -1;

          if (row > this.end.row) return 1;

          if (this.start.row === row) return column >= this.start.column ? 0 : -1;

          if (this.end.row === row) return column <= this.end.column ? 0 : 1;

          return 0;
        };
        this.compareStart = function (row, column) {
          if (this.start.row == row && this.start.column == column) {
            return -1;
          } else {
            return this.compare(row, column);
          }
        };
        this.compareEnd = function (row, column) {
          if (this.end.row == row && this.end.column == column) {
            return 1;
          } else {
            return this.compare(row, column);
          }
        };
        this.compareInside = function (row, column) {
          if (this.end.row == row && this.end.column == column) {
            return 1;
          } else if (this.start.row == row && this.start.column == column) {
            return -1;
          } else {
            return this.compare(row, column);
          }
        };
        this.clipRows = function (firstRow, lastRow) {
          if (this.end.row > lastRow) var end = { row: lastRow + 1, column: 0 };else if (this.end.row < firstRow) var end = { row: firstRow, column: 0 };

          if (this.start.row > lastRow) var start = { row: lastRow + 1, column: 0 };else if (this.start.row < firstRow) var start = { row: firstRow, column: 0 };

          return Range.fromPoints(start || this.start, end || this.end);
        };
        this.extend = function (row, column) {
          var cmp = this.compare(row, column);

          if (cmp == 0) return this;else if (cmp == -1) var start = { row: row, column: column };else var end = { row: row, column: column };

          return Range.fromPoints(start || this.start, end || this.end);
        };

        this.isEmpty = function () {
          return this.start.row === this.end.row && this.start.column === this.end.column;
        };
        this.isMultiLine = function () {
          return this.start.row !== this.end.row;
        };
        this.clone = function () {
          return Range.fromPoints(this.start, this.end);
        };
        this.collapseRows = function () {
          if (this.end.column == 0) return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);else return new Range(this.start.row, 0, this.end.row, 0);
        };
        this.toScreenRange = function (session) {
          var screenPosStart = session.documentToScreenPosition(this.start);
          var screenPosEnd = session.documentToScreenPosition(this.end);

          return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
        };
        this.moveBy = function (row, column) {
          this.start.row += row;
          this.start.column += column;
          this.end.row += row;
          this.end.column += column;
        };
      }).call(Range.prototype);
      Range.fromPoints = function (start, end) {
        return new Range(start.row, start.column, end.row, end.column);
      };
      Range.comparePoints = comparePoints;

      Range.comparePoints = function (p1, p2) {
        return p1.row - p2.row || p1.column - p2.column;
      };

      exports.Range = Range;
    });

    ace.define("ace/apply_delta", ["require", "exports", "module"], function (require, exports, module) {
      "use strict";

      function throwDeltaError(delta, errorText) {
        console.log("Invalid Delta:", delta);
        throw "Invalid Delta: " + errorText;
      }

      function positionInDocument(docLines, position) {
        return position.row >= 0 && position.row < docLines.length && position.column >= 0 && position.column <= docLines[position.row].length;
      }

      function validateDelta(docLines, delta) {
        if (delta.action != "insert" && delta.action != "remove") throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
        if (!(delta.lines instanceof Array)) throwDeltaError(delta, "delta.lines must be an Array");
        if (!delta.start || !delta.end) throwDeltaError(delta, "delta.start/end must be an present");
        var start = delta.start;
        if (!positionInDocument(docLines, delta.start)) throwDeltaError(delta, "delta.start must be contained in document");
        var end = delta.end;
        if (delta.action == "remove" && !positionInDocument(docLines, end)) throwDeltaError(delta, "delta.end must contained in document for 'remove' actions");
        var numRangeRows = end.row - start.row;
        var numRangeLastLineChars = end.column - (numRangeRows == 0 ? start.column : 0);
        if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars) throwDeltaError(delta, "delta.range must match delta lines");
      }

      exports.applyDelta = function (docLines, delta, doNotValidate) {

        var row = delta.start.row;
        var startColumn = delta.start.column;
        var line = docLines[row] || "";
        switch (delta.action) {
          case "insert":
            var lines = delta.lines;
            if (lines.length === 1) {
              docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
            } else {
              var args = [row, 1].concat(delta.lines);
              docLines.splice.apply(docLines, args);
              docLines[row] = line.substring(0, startColumn) + docLines[row];
              docLines[row + delta.lines.length - 1] += line.substring(startColumn);
            }
            break;
          case "remove":
            var endColumn = delta.end.column;
            var endRow = delta.end.row;
            if (row === endRow) {
              docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
            } else {
              docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));
            }
            break;
        }
      };
    });

    ace.define("ace/lib/event_emitter", ["require", "exports", "module"], function (require, exports, module) {
      "use strict";

      var EventEmitter = {};
      var stopPropagation = function () {
        this.propagationStopped = true;
      };
      var preventDefault = function () {
        this.defaultPrevented = true;
      };

      EventEmitter._emit = EventEmitter._dispatchEvent = function (eventName, e) {
        this._eventRegistry || (this._eventRegistry = {});
        this._defaultHandlers || (this._defaultHandlers = {});

        var listeners = this._eventRegistry[eventName] || [];
        var defaultHandler = this._defaultHandlers[eventName];
        if (!listeners.length && !defaultHandler) return;

        if (typeof e != "object" || !e) e = {};

        if (!e.type) e.type = eventName;
        if (!e.stopPropagation) e.stopPropagation = stopPropagation;
        if (!e.preventDefault) e.preventDefault = preventDefault;

        listeners = listeners.slice();
        for (var i = 0; i < listeners.length; i++) {
          listeners[i](e, this);
          if (e.propagationStopped) break;
        }

        if (defaultHandler && !e.defaultPrevented) return defaultHandler(e, this);
      };

      EventEmitter._signal = function (eventName, e) {
        var listeners = (this._eventRegistry || {})[eventName];
        if (!listeners) return;
        listeners = listeners.slice();
        for (var i = 0; i < listeners.length; i++) listeners[i](e, this);
      };

      EventEmitter.once = function (eventName, callback) {
        var _self = this;
        callback && this.addEventListener(eventName, function newCallback() {
          _self.removeEventListener(eventName, newCallback);
          callback.apply(null, arguments);
        });
      };

      EventEmitter.setDefaultHandler = function (eventName, callback) {
        var handlers = this._defaultHandlers;
        if (!handlers) handlers = this._defaultHandlers = { _disabled_: {} };

        if (handlers[eventName]) {
          var old = handlers[eventName];
          var disabled = handlers._disabled_[eventName];
          if (!disabled) handlers._disabled_[eventName] = disabled = [];
          disabled.push(old);
          var i = disabled.indexOf(callback);
          if (i != -1) disabled.splice(i, 1);
        }
        handlers[eventName] = callback;
      };
      EventEmitter.removeDefaultHandler = function (eventName, callback) {
        var handlers = this._defaultHandlers;
        if (!handlers) return;
        var disabled = handlers._disabled_[eventName];

        if (handlers[eventName] == callback) {
          var old = handlers[eventName];
          if (disabled) this.setDefaultHandler(eventName, disabled.pop());
        } else if (disabled) {
          var i = disabled.indexOf(callback);
          if (i != -1) disabled.splice(i, 1);
        }
      };

      EventEmitter.on = EventEmitter.addEventListener = function (eventName, callback, capturing) {
        this._eventRegistry = this._eventRegistry || {};

        var listeners = this._eventRegistry[eventName];
        if (!listeners) listeners = this._eventRegistry[eventName] = [];

        if (listeners.indexOf(callback) == -1) listeners[capturing ? "unshift" : "push"](callback);
        return callback;
      };

      EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function (eventName, callback) {
        this._eventRegistry = this._eventRegistry || {};

        var listeners = this._eventRegistry[eventName];
        if (!listeners) return;

        var index = listeners.indexOf(callback);
        if (index !== -1) listeners.splice(index, 1);
      };

      EventEmitter.removeAllListeners = function (eventName) {
        if (this._eventRegistry) this._eventRegistry[eventName] = [];
      };

      exports.EventEmitter = EventEmitter;
    });

    ace.define("ace/anchor", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function (require, exports, module) {
      "use strict";

      var oop = require("./lib/oop");
      var EventEmitter = require("./lib/event_emitter").EventEmitter;

      var Anchor = exports.Anchor = function (doc, row, column) {
        this.$onChange = this.onChange.bind(this);
        this.attach(doc);

        if (typeof column == "undefined") this.setPosition(row.row, row.column);else this.setPosition(row, column);
      };

      (function () {

        oop.implement(this, EventEmitter);
        this.getPosition = function () {
          return this.$clipPositionToDocument(this.row, this.column);
        };
        this.getDocument = function () {
          return this.document;
        };
        this.$insertRight = false;
        this.onChange = function (delta) {
          if (delta.start.row == delta.end.row && delta.start.row != this.row) return;

          if (delta.start.row > this.row) return;

          var point = $getTransformedPoint(delta, { row: this.row, column: this.column }, this.$insertRight);
          this.setPosition(point.row, point.column, true);
        };

        function $pointsInOrder(point1, point2, equalPointsInOrder) {
          var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
          return point1.row < point2.row || point1.row == point2.row && bColIsAfter;
        }

        function $getTransformedPoint(delta, point, moveIfEqual) {
          var deltaIsInsert = delta.action == "insert";
          var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);
          var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
          var deltaStart = delta.start;
          var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
          if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
            return {
              row: point.row,
              column: point.column
            };
          }
          if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
            return {
              row: point.row + deltaRowShift,
              column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
            };
          }

          return {
            row: deltaStart.row,
            column: deltaStart.column
          };
        }
        this.setPosition = function (row, column, noClip) {
          var pos;
          if (noClip) {
            pos = {
              row: row,
              column: column
            };
          } else {
            pos = this.$clipPositionToDocument(row, column);
          }

          if (this.row == pos.row && this.column == pos.column) return;

          var old = {
            row: this.row,
            column: this.column
          };

          this.row = pos.row;
          this.column = pos.column;
          this._signal("change", {
            old: old,
            value: pos
          });
        };
        this.detach = function () {
          this.document.removeEventListener("change", this.$onChange);
        };
        this.attach = function (doc) {
          this.document = doc || this.document;
          this.document.on("change", this.$onChange);
        };
        this.$clipPositionToDocument = function (row, column) {
          var pos = {};

          if (row >= this.document.getLength()) {
            pos.row = Math.max(0, this.document.getLength() - 1);
            pos.column = this.document.getLine(pos.row).length;
          } else if (row < 0) {
            pos.row = 0;
            pos.column = 0;
          } else {
            pos.row = row;
            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
          }

          if (column < 0) pos.column = 0;

          return pos;
        };
      }).call(Anchor.prototype);
    });

    ace.define("ace/document", ["require", "exports", "module", "ace/lib/oop", "ace/apply_delta", "ace/lib/event_emitter", "ace/range", "ace/anchor"], function (require, exports, module) {
      "use strict";

      var oop = require("./lib/oop");
      var applyDelta = require("./apply_delta").applyDelta;
      var EventEmitter = require("./lib/event_emitter").EventEmitter;
      var Range = require("./range").Range;
      var Anchor = require("./anchor").Anchor;

      var Document = function (textOrLines) {
        this.$lines = [""];
        if (textOrLines.length === 0) {
          this.$lines = [""];
        } else if (Array.isArray(textOrLines)) {
          this.insertMergedLines({ row: 0, column: 0 }, textOrLines);
        } else {
          this.insert({ row: 0, column: 0 }, textOrLines);
        }
      };

      (function () {

        oop.implement(this, EventEmitter);
        this.setValue = function (text) {
          var len = this.getLength() - 1;
          this.remove(new Range(0, 0, len, this.getLine(len).length));
          this.insert({ row: 0, column: 0 }, text);
        };
        this.getValue = function () {
          return this.getAllLines().join(this.getNewLineCharacter());
        };
        this.createAnchor = function (row, column) {
          return new Anchor(this, row, column);
        };
        if ("aaa".split(/a/).length === 0) {
          this.$split = function (text) {
            return text.replace(/\r\n|\r/g, "\n").split("\n");
          };
        } else {
          this.$split = function (text) {
            return text.split(/\r\n|\r|\n/);
          };
        }

        this.$detectNewLine = function (text) {
          var match = text.match(/^.*?(\r\n|\r|\n)/m);
          this.$autoNewLine = match ? match[1] : "\n";
          this._signal("changeNewLineMode");
        };
        this.getNewLineCharacter = function () {
          switch (this.$newLineMode) {
            case "windows":
              return "\r\n";
            case "unix":
              return "\n";
            default:
              return this.$autoNewLine || "\n";
          }
        };

        this.$autoNewLine = "";
        this.$newLineMode = "auto";
        this.setNewLineMode = function (newLineMode) {
          if (this.$newLineMode === newLineMode) return;

          this.$newLineMode = newLineMode;
          this._signal("changeNewLineMode");
        };
        this.getNewLineMode = function () {
          return this.$newLineMode;
        };
        this.isNewLine = function (text) {
          return text == "\r\n" || text == "\r" || text == "\n";
        };
        this.getLine = function (row) {
          return this.$lines[row] || "";
        };
        this.getLines = function (firstRow, lastRow) {
          return this.$lines.slice(firstRow, lastRow + 1);
        };
        this.getAllLines = function () {
          return this.getLines(0, this.getLength());
        };
        this.getLength = function () {
          return this.$lines.length;
        };
        this.getTextRange = function (range) {
          return this.getLinesForRange(range).join(this.getNewLineCharacter());
        };
        this.getLinesForRange = function (range) {
          var lines;
          if (range.start.row === range.end.row) {
            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
          } else {
            lines = this.getLines(range.start.row, range.end.row);
            lines[0] = (lines[0] || "").substring(range.start.column);
            var l = lines.length - 1;
            if (range.end.row - range.start.row == l) lines[l] = lines[l].substring(0, range.end.column);
          }
          return lines;
        };
        this.insertLines = function (row, lines) {
          console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
          return this.insertFullLines(row, lines);
        };
        this.removeLines = function (firstRow, lastRow) {
          console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
          return this.removeFullLines(firstRow, lastRow);
        };
        this.insertNewLine = function (position) {
          console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
          return this.insertMergedLines(position, ["", ""]);
        };
        this.insert = function (position, text) {
          if (this.getLength() <= 1) this.$detectNewLine(text);

          return this.insertMergedLines(position, this.$split(text));
        };
        this.insertInLine = function (position, text) {
          var start = this.clippedPos(position.row, position.column);
          var end = this.pos(position.row, position.column + text.length);

          this.applyDelta({
            start: start,
            end: end,
            action: "insert",
            lines: [text]
          }, true);

          return this.clonePos(end);
        };

        this.clippedPos = function (row, column) {
          var length = this.getLength();
          if (row === undefined) {
            row = length;
          } else if (row < 0) {
            row = 0;
          } else if (row >= length) {
            row = length - 1;
            column = undefined;
          }
          var line = this.getLine(row);
          if (column == undefined) column = line.length;
          column = Math.min(Math.max(column, 0), line.length);
          return { row: row, column: column };
        };

        this.clonePos = function (pos) {
          return { row: pos.row, column: pos.column };
        };

        this.pos = function (row, column) {
          return { row: row, column: column };
        };

        this.$clipPosition = function (position) {
          var length = this.getLength();
          if (position.row >= length) {
            position.row = Math.max(0, length - 1);
            position.column = this.getLine(length - 1).length;
          } else {
            position.row = Math.max(0, position.row);
            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
          }
          return position;
        };
        this.insertFullLines = function (row, lines) {
          row = Math.min(Math.max(row, 0), this.getLength());
          var column = 0;
          if (row < this.getLength()) {
            lines = lines.concat([""]);
            column = 0;
          } else {
            lines = [""].concat(lines);
            row--;
            column = this.$lines[row].length;
          }
          this.insertMergedLines({ row: row, column: column }, lines);
        };
        this.insertMergedLines = function (position, lines) {
          var start = this.clippedPos(position.row, position.column);
          var end = {
            row: start.row + lines.length - 1,
            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
          };

          this.applyDelta({
            start: start,
            end: end,
            action: "insert",
            lines: lines
          });

          return this.clonePos(end);
        };
        this.remove = function (range) {
          var start = this.clippedPos(range.start.row, range.start.column);
          var end = this.clippedPos(range.end.row, range.end.column);
          this.applyDelta({
            start: start,
            end: end,
            action: "remove",
            lines: this.getLinesForRange({ start: start, end: end })
          });
          return this.clonePos(start);
        };
        this.removeInLine = function (row, startColumn, endColumn) {
          var start = this.clippedPos(row, startColumn);
          var end = this.clippedPos(row, endColumn);

          this.applyDelta({
            start: start,
            end: end,
            action: "remove",
            lines: this.getLinesForRange({ start: start, end: end })
          }, true);

          return this.clonePos(start);
        };
        this.removeFullLines = function (firstRow, lastRow) {
          firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
          lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);
          var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
          var deleteLastNewLine = lastRow < this.getLength() - 1;
          var startRow = deleteFirstNewLine ? firstRow - 1 : firstRow;
          var startCol = deleteFirstNewLine ? this.getLine(startRow).length : 0;
          var endRow = deleteLastNewLine ? lastRow + 1 : lastRow;
          var endCol = deleteLastNewLine ? 0 : this.getLine(endRow).length;
          var range = new Range(startRow, startCol, endRow, endCol);
          var deletedLines = this.$lines.slice(firstRow, lastRow + 1);

          this.applyDelta({
            start: range.start,
            end: range.end,
            action: "remove",
            lines: this.getLinesForRange(range)
          });
          return deletedLines;
        };
        this.removeNewLine = function (row) {
          if (row < this.getLength() - 1 && row >= 0) {
            this.applyDelta({
              start: this.pos(row, this.getLine(row).length),
              end: this.pos(row + 1, 0),
              action: "remove",
              lines: ["", ""]
            });
          }
        };
        this.replace = function (range, text) {
          if (!(range instanceof Range)) range = Range.fromPoints(range.start, range.end);
          if (text.length === 0 && range.isEmpty()) return range.start;
          if (text == this.getTextRange(range)) return range.end;

          this.remove(range);
          var end;
          if (text) {
            end = this.insert(range.start, text);
          } else {
            end = range.start;
          }

          return end;
        };
        this.applyDeltas = function (deltas) {
          for (var i = 0; i < deltas.length; i++) {
            this.applyDelta(deltas[i]);
          }
        };
        this.revertDeltas = function (deltas) {
          for (var i = deltas.length - 1; i >= 0; i--) {
            this.revertDelta(deltas[i]);
          }
        };
        this.applyDelta = function (delta, doNotValidate) {
          var isInsert = delta.action == "insert";
          if (isInsert ? delta.lines.length <= 1 && !delta.lines[0] : !Range.comparePoints(delta.start, delta.end)) {
            return;
          }

          if (isInsert && delta.lines.length > 20000) this.$splitAndapplyLargeDelta(delta, 20000);
          applyDelta(this.$lines, delta, doNotValidate);
          this._signal("change", delta);
        };

        this.$splitAndapplyLargeDelta = function (delta, MAX) {
          var lines = delta.lines;
          var l = lines.length;
          var row = delta.start.row;
          var column = delta.start.column;
          var from = 0,
              to = 0;
          do {
            from = to;
            to += MAX - 1;
            var chunk = lines.slice(from, to);
            if (to > l) {
              delta.lines = chunk;
              delta.start.row = row + from;
              delta.start.column = column;
              break;
            }
            chunk.push("");
            this.applyDelta({
              start: this.pos(row + from, column),
              end: this.pos(row + to, column = 0),
              action: delta.action,
              lines: chunk
            }, true);
          } while (true);
        };
        this.revertDelta = function (delta) {
          this.applyDelta({
            start: this.clonePos(delta.start),
            end: this.clonePos(delta.end),
            action: delta.action == "insert" ? "remove" : "insert",
            lines: delta.lines.slice()
          });
        };
        this.indexToPosition = function (index, startRow) {
          var lines = this.$lines || this.getAllLines();
          var newlineLength = this.getNewLineCharacter().length;
          for (var i = startRow || 0, l = lines.length; i < l; i++) {
            index -= lines[i].length + newlineLength;
            if (index < 0) return { row: i, column: index + lines[i].length + newlineLength };
          }
          return { row: l - 1, column: lines[l - 1].length };
        };
        this.positionToIndex = function (pos, startRow) {
          var lines = this.$lines || this.getAllLines();
          var newlineLength = this.getNewLineCharacter().length;
          var index = 0;
          var row = Math.min(pos.row, lines.length);
          for (var i = startRow || 0; i < row; ++i) index += lines[i].length + newlineLength;

          return index + pos.column;
        };
      }).call(Document.prototype);

      exports.Document = Document;
    });

    ace.define("ace/lib/lang", ["require", "exports", "module"], function (require, exports, module) {
      "use strict";

      exports.last = function (a) {
        return a[a.length - 1];
      };

      exports.stringReverse = function (string) {
        return string.split("").reverse().join("");
      };

      exports.stringRepeat = function (string, count) {
        var result = '';
        while (count > 0) {
          if (count & 1) result += string;

          if (count >>= 1) string += string;
        }
        return result;
      };

      var trimBeginRegexp = /^\s\s*/;
      var trimEndRegexp = /\s\s*$/;

      exports.stringTrimLeft = function (string) {
        return string.replace(trimBeginRegexp, '');
      };

      exports.stringTrimRight = function (string) {
        return string.replace(trimEndRegexp, '');
      };

      exports.copyObject = function (obj) {
        var copy = {};
        for (var key in obj) {
          copy[key] = obj[key];
        }
        return copy;
      };

      exports.copyArray = function (array) {
        var copy = [];
        for (var i = 0, l = array.length; i < l; i++) {
          if (array[i] && typeof array[i] == "object") copy[i] = this.copyObject(array[i]);else copy[i] = array[i];
        }
        return copy;
      };

      exports.deepCopy = function deepCopy(obj) {
        if (typeof obj !== "object" || !obj) return obj;
        var copy;
        if (Array.isArray(obj)) {
          copy = [];
          for (var key = 0; key < obj.length; key++) {
            copy[key] = deepCopy(obj[key]);
          }
          return copy;
        }
        if (Object.prototype.toString.call(obj) !== "[object Object]") return obj;

        copy = {};
        for (var key in obj) copy[key] = deepCopy(obj[key]);
        return copy;
      };

      exports.arrayToMap = function (arr) {
        var map = {};
        for (var i = 0; i < arr.length; i++) {
          map[arr[i]] = 1;
        }
        return map;
      };

      exports.createMap = function (props) {
        var map = Object.create(null);
        for (var i in props) {
          map[i] = props[i];
        }
        return map;
      };
      exports.arrayRemove = function (array, value) {
        for (var i = 0; i <= array.length; i++) {
          if (value === array[i]) {
            array.splice(i, 1);
          }
        }
      };

      exports.escapeRegExp = function (str) {
        return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
      };

      exports.escapeHTML = function (str) {
        return str.replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
      };

      exports.getMatchOffsets = function (string, regExp) {
        var matches = [];

        string.replace(regExp, function (str) {
          matches.push({
            offset: arguments[arguments.length - 2],
            length: str.length
          });
        });

        return matches;
      };
      exports.deferredCall = function (fcn) {
        var timer = null;
        var callback = function () {
          timer = null;
          fcn();
        };

        var deferred = function (timeout) {
          deferred.cancel();
          timer = setTimeout(callback, timeout || 0);
          return deferred;
        };

        deferred.schedule = deferred;

        deferred.call = function () {
          this.cancel();
          fcn();
          return deferred;
        };

        deferred.cancel = function () {
          clearTimeout(timer);
          timer = null;
          return deferred;
        };

        deferred.isPending = function () {
          return timer;
        };

        return deferred;
      };

      exports.delayedCall = function (fcn, defaultTimeout) {
        var timer = null;
        var callback = function () {
          timer = null;
          fcn();
        };

        var _self = function (timeout) {
          if (timer == null) timer = setTimeout(callback, timeout || defaultTimeout);
        };

        _self.delay = function (timeout) {
          timer && clearTimeout(timer);
          timer = setTimeout(callback, timeout || defaultTimeout);
        };
        _self.schedule = _self;

        _self.call = function () {
          this.cancel();
          fcn();
        };

        _self.cancel = function () {
          timer && clearTimeout(timer);
          timer = null;
        };

        _self.isPending = function () {
          return timer;
        };

        return _self;
      };
    });

    ace.define("ace/worker/mirror", ["require", "exports", "module", "ace/range", "ace/document", "ace/lib/lang"], function (require, exports, module) {
      "use strict";

      var Range = require("../range").Range;
      var Document = require("../document").Document;
      var lang = require("../lib/lang");

      var Mirror = exports.Mirror = function (sender) {
        this.sender = sender;
        var doc = this.doc = new Document("");

        var deferredUpdate = this.deferredUpdate = lang.delayedCall(this.onUpdate.bind(this));

        var _self = this;
        sender.on("change", function (e) {
          var data = e.data;
          if (data[0].start) {
            doc.applyDeltas(data);
          } else {
            for (var i = 0; i < data.length; i += 2) {
              if (Array.isArray(data[i + 1])) {
                var d = { action: "insert", start: data[i], lines: data[i + 1] };
              } else {
                var d = { action: "remove", start: data[i], end: data[i + 1] };
              }
              doc.applyDelta(d, true);
            }
          }
          if (_self.$timeout) return deferredUpdate.schedule(_self.$timeout);
          _self.onUpdate();
        });
      };

      (function () {

        this.$timeout = 500;

        this.setTimeout = function (timeout) {
          this.$timeout = timeout;
        };

        this.setValue = function (value) {
          this.doc.setValue(value);
          this.deferredUpdate.schedule(this.$timeout);
        };

        this.getValue = function (callbackId) {
          this.sender.callback(this.doc.getValue(), callbackId);
        };

        this.onUpdate = function () {};

        this.isPending = function () {
          return this.deferredUpdate.isPending();
        };
      }).call(Mirror.prototype);
    });

    ace.define("ace/mode/javascript/jshint", ["require", "exports", "module"], function (require, exports, module) {
      module.exports = function outer(modules, cache, entry) {
        var previousRequire = typeof require == "function" && require;
        function newRequire(name, jumped) {
          if (!cache[name]) {
            if (!modules[name]) {
              var currentRequire = typeof require == "function" && require;
              if (!jumped && currentRequire) return currentRequire(name, true);
              if (previousRequire) return previousRequire(name, true);
              var err = new Error('Cannot find module \'' + name + '\'');
              err.code = 'MODULE_NOT_FOUND';
              throw err;
            }
            var m = cache[name] = { exports: {} };
            modules[name][0].call(m.exports, function (x) {
              var id = modules[name][1][x];
              return newRequire(id ? id : x);
            }, m, m.exports, outer, modules, cache, entry);
          }
          return cache[name].exports;
        }
        for (var i = 0; i < entry.length; i++) newRequire(entry[i]);
        return newRequire(entry[0]);
      }({ "/node_modules/browserify/node_modules/events/events.js": [function (_dereq_, module, exports) {

          function EventEmitter() {
            this._events = this._events || {};
            this._maxListeners = this._maxListeners || undefined;
          }
          module.exports = EventEmitter;
          EventEmitter.EventEmitter = EventEmitter;

          EventEmitter.prototype._events = undefined;
          EventEmitter.prototype._maxListeners = undefined;
          EventEmitter.defaultMaxListeners = 10;
          EventEmitter.prototype.setMaxListeners = function (n) {
            if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');
            this._maxListeners = n;
            return this;
          };

          EventEmitter.prototype.emit = function (type) {
            var er, handler, len, args, i, listeners;

            if (!this._events) this._events = {};
            if (type === 'error') {
              if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
                er = arguments[1];
                if (er instanceof Error) {
                  throw er; // Unhandled 'error' event
                }
                throw TypeError('Uncaught, unspecified "error" event.');
              }
            }

            handler = this._events[type];

            if (isUndefined(handler)) return false;

            if (isFunction(handler)) {
              switch (arguments.length) {
                case 1:
                  handler.call(this);
                  break;
                case 2:
                  handler.call(this, arguments[1]);
                  break;
                case 3:
                  handler.call(this, arguments[1], arguments[2]);
                  break;
                default:
                  len = arguments.length;
                  args = new Array(len - 1);
                  for (i = 1; i < len; i++) args[i - 1] = arguments[i];
                  handler.apply(this, args);
              }
            } else if (isObject(handler)) {
              len = arguments.length;
              args = new Array(len - 1);
              for (i = 1; i < len; i++) args[i - 1] = arguments[i];

              listeners = handler.slice();
              len = listeners.length;
              for (i = 0; i < len; i++) listeners[i].apply(this, args);
            }

            return true;
          };

          EventEmitter.prototype.addListener = function (type, listener) {
            var m;

            if (!isFunction(listener)) throw TypeError('listener must be a function');

            if (!this._events) this._events = {};
            if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);

            if (!this._events[type]) this._events[type] = listener;else if (isObject(this._events[type])) this._events[type].push(listener);else this._events[type] = [this._events[type], listener];
            if (isObject(this._events[type]) && !this._events[type].warned) {
              var m;
              if (!isUndefined(this._maxListeners)) {
                m = this._maxListeners;
              } else {
                m = EventEmitter.defaultMaxListeners;
              }

              if (m && m > 0 && this._events[type].length > m) {
                this._events[type].warned = true;
                console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
                if (typeof console.trace === 'function') {
                  console.trace();
                }
              }
            }

            return this;
          };

          EventEmitter.prototype.on = EventEmitter.prototype.addListener;

          EventEmitter.prototype.once = function (type, listener) {
            if (!isFunction(listener)) throw TypeError('listener must be a function');

            var fired = false;

            function g() {
              this.removeListener(type, g);

              if (!fired) {
                fired = true;
                listener.apply(this, arguments);
              }
            }

            g.listener = listener;
            this.on(type, g);

            return this;
          };
          EventEmitter.prototype.removeListener = function (type, listener) {
            var list, position, length, i;

            if (!isFunction(listener)) throw TypeError('listener must be a function');

            if (!this._events || !this._events[type]) return this;

            list = this._events[type];
            length = list.length;
            position = -1;

            if (list === listener || isFunction(list.listener) && list.listener === listener) {
              delete this._events[type];
              if (this._events.removeListener) this.emit('removeListener', type, listener);
            } else if (isObject(list)) {
              for (i = length; i-- > 0;) {
                if (list[i] === listener || list[i].listener && list[i].listener === listener) {
                  position = i;
                  break;
                }
              }

              if (position < 0) return this;

              if (list.length === 1) {
                list.length = 0;
                delete this._events[type];
              } else {
                list.splice(position, 1);
              }

              if (this._events.removeListener) this.emit('removeListener', type, listener);
            }

            return this;
          };

          EventEmitter.prototype.removeAllListeners = function (type) {
            var key, listeners;

            if (!this._events) return this;
            if (!this._events.removeListener) {
              if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];
              return this;
            }
            if (arguments.length === 0) {
              for (key in this._events) {
                if (key === 'removeListener') continue;
                this.removeAllListeners(key);
              }
              this.removeAllListeners('removeListener');
              this._events = {};
              return this;
            }

            listeners = this._events[type];

            if (isFunction(listeners)) {
              this.removeListener(type, listeners);
            } else {
              while (listeners.length) this.removeListener(type, listeners[listeners.length - 1]);
            }
            delete this._events[type];

            return this;
          };

          EventEmitter.prototype.listeners = function (type) {
            var ret;
            if (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();
            return ret;
          };

          EventEmitter.listenerCount = function (emitter, type) {
            var ret;
            if (!emitter._events || !emitter._events[type]) ret = 0;else if (isFunction(emitter._events[type])) ret = 1;else ret = emitter._events[type].length;
            return ret;
          };

          function isFunction(arg) {
            return typeof arg === 'function';
          }

          function isNumber(arg) {
            return typeof arg === 'number';
          }

          function isObject(arg) {
            return typeof arg === 'object' && arg !== null;
          }

          function isUndefined(arg) {
            return arg === void 0;
          }
        }, {}], "/node_modules/jshint/data/ascii-identifier-data.js": [function (_dereq_, module, exports) {
          var identifierStartTable = [];

          for (var i = 0; i < 128; i++) {
            identifierStartTable[i] = i === 36 || // $
            i >= 65 && i <= 90 || // A-Z
            i === 95 || // _
            i >= 97 && i <= 122; // a-z
          }

          var identifierPartTable = [];

          for (var i = 0; i < 128; i++) {
            identifierPartTable[i] = identifierStartTable[i] || // $, _, A-Z, a-z
            i >= 48 && i <= 57; // 0-9
          }

          module.exports = {
            asciiIdentifierStartTable: identifierStartTable,
            asciiIdentifierPartTable: identifierPartTable
          };
        }, {}], "/node_modules/jshint/lodash.js": [function (_dereq_, module, exports) {
          (function (global) {
            ;(function () {

              var undefined;

              var VERSION = '3.7.0';

              var FUNC_ERROR_TEXT = 'Expected a function';

              var argsTag = '[object Arguments]',
                  arrayTag = '[object Array]',
                  boolTag = '[object Boolean]',
                  dateTag = '[object Date]',
                  errorTag = '[object Error]',
                  funcTag = '[object Function]',
                  mapTag = '[object Map]',
                  numberTag = '[object Number]',
                  objectTag = '[object Object]',
                  regexpTag = '[object RegExp]',
                  setTag = '[object Set]',
                  stringTag = '[object String]',
                  weakMapTag = '[object WeakMap]';

              var arrayBufferTag = '[object ArrayBuffer]',
                  float32Tag = '[object Float32Array]',
                  float64Tag = '[object Float64Array]',
                  int8Tag = '[object Int8Array]',
                  int16Tag = '[object Int16Array]',
                  int32Tag = '[object Int32Array]',
                  uint8Tag = '[object Uint8Array]',
                  uint8ClampedTag = '[object Uint8ClampedArray]',
                  uint16Tag = '[object Uint16Array]',
                  uint32Tag = '[object Uint32Array]';

              var reIsDeepProp = /\.|\[(?:[^[\]]+|(["'])(?:(?!\1)[^\n\\]|\\.)*?)\1\]/,
                  reIsPlainProp = /^\w*$/,
                  rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

              var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
                  reHasRegExpChars = RegExp(reRegExpChars.source);

              var reEscapeChar = /\\(\\)?/g;

              var reFlags = /\w*$/;

              var reIsHostCtor = /^\[object .+?Constructor\]$/;

              var typedArrayTags = {};
              typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
              typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

              var cloneableTags = {};
              cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[stringTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
              cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[mapTag] = cloneableTags[setTag] = cloneableTags[weakMapTag] = false;

              var objectTypes = {
                'function': true,
                'object': true
              };

              var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

              var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

              var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;

              var freeSelf = objectTypes[typeof self] && self && self.Object && self;

              var freeWindow = objectTypes[typeof window] && window && window.Object && window;

              var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

              var root = freeGlobal || freeWindow !== (this && this.window) && freeWindow || freeSelf || this;

              function baseFindIndex(array, predicate, fromRight) {
                var length = array.length,
                    index = fromRight ? length : -1;

                while (fromRight ? index-- : ++index < length) {
                  if (predicate(array[index], index, array)) {
                    return index;
                  }
                }
                return -1;
              }

              function baseIndexOf(array, value, fromIndex) {
                if (value !== value) {
                  return indexOfNaN(array, fromIndex);
                }
                var index = fromIndex - 1,
                    length = array.length;

                while (++index < length) {
                  if (array[index] === value) {
                    return index;
                  }
                }
                return -1;
              }

              function baseIsFunction(value) {
                return typeof value == 'function' || false;
              }

              function baseToString(value) {
                if (typeof value == 'string') {
                  return value;
                }
                return value == null ? '' : value + '';
              }

              function indexOfNaN(array, fromIndex, fromRight) {
                var length = array.length,
                    index = fromIndex + (fromRight ? 0 : -1);

                while (fromRight ? index-- : ++index < length) {
                  var other = array[index];
                  if (other !== other) {
                    return index;
                  }
                }
                return -1;
              }

              function isObjectLike(value) {
                return !!value && typeof value == 'object';
              }

              var arrayProto = Array.prototype,
                  objectProto = Object.prototype;

              var fnToString = Function.prototype.toString;

              var hasOwnProperty = objectProto.hasOwnProperty;

              var objToString = objectProto.toString;

              var reIsNative = RegExp('^' + escapeRegExp(objToString).replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

              var ArrayBuffer = isNative(ArrayBuffer = root.ArrayBuffer) && ArrayBuffer,
                  bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice,
                  floor = Math.floor,
                  getOwnPropertySymbols = isNative(getOwnPropertySymbols = Object.getOwnPropertySymbols) && getOwnPropertySymbols,
                  getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
                  push = arrayProto.push,
                  preventExtensions = isNative(Object.preventExtensions = Object.preventExtensions) && preventExtensions,
                  propertyIsEnumerable = objectProto.propertyIsEnumerable,
                  Uint8Array = isNative(Uint8Array = root.Uint8Array) && Uint8Array;

              var Float64Array = function () {
                try {
                  var func = isNative(func = root.Float64Array) && func,
                      result = new func(new ArrayBuffer(10), 0, 1) && func;
                } catch (e) {}
                return result;
              }();

              var nativeAssign = function () {
                var object = { '1': 0 },
                    func = preventExtensions && isNative(func = Object.assign) && func;

                try {
                  func(preventExtensions(object), 'xo');
                } catch (e) {}
                return !object[1] && func;
              }();

              var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
                  nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
                  nativeMax = Math.max,
                  nativeMin = Math.min;

              var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY;

              var MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1,
                  MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
                  HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

              var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;

              var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

              function lodash() {}

              var support = lodash.support = {};

              (function (x) {
                var Ctor = function () {
                  this.x = x;
                },
                    object = { '0': x, 'length': x },
                    props = [];

                Ctor.prototype = { 'valueOf': x, 'y': x };
                for (var key in new Ctor()) {
                  props.push(key);
                }

                support.funcDecomp = /\bthis\b/.test(function () {
                  return this;
                });

                support.funcNames = typeof Function.name == 'string';

                try {
                  support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);
                } catch (e) {
                  support.nonEnumArgs = true;
                }
              })(1, 0);

              function arrayCopy(source, array) {
                var index = -1,
                    length = source.length;

                array || (array = Array(length));
                while (++index < length) {
                  array[index] = source[index];
                }
                return array;
              }

              function arrayEach(array, iteratee) {
                var index = -1,
                    length = array.length;

                while (++index < length) {
                  if (iteratee(array[index], index, array) === false) {
                    break;
                  }
                }
                return array;
              }

              function arrayFilter(array, predicate) {
                var index = -1,
                    length = array.length,
                    resIndex = -1,
                    result = [];

                while (++index < length) {
                  var value = array[index];
                  if (predicate(value, index, array)) {
                    result[++resIndex] = value;
                  }
                }
                return result;
              }

              function arrayMap(array, iteratee) {
                var index = -1,
                    length = array.length,
                    result = Array(length);

                while (++index < length) {
                  result[index] = iteratee(array[index], index, array);
                }
                return result;
              }

              function arrayMax(array) {
                var index = -1,
                    length = array.length,
                    result = NEGATIVE_INFINITY;

                while (++index < length) {
                  var value = array[index];
                  if (value > result) {
                    result = value;
                  }
                }
                return result;
              }

              function arraySome(array, predicate) {
                var index = -1,
                    length = array.length;

                while (++index < length) {
                  if (predicate(array[index], index, array)) {
                    return true;
                  }
                }
                return false;
              }

              function assignWith(object, source, customizer) {
                var props = keys(source);
                push.apply(props, getSymbols(source));

                var index = -1,
                    length = props.length;

                while (++index < length) {
                  var key = props[index],
                      value = object[key],
                      result = customizer(value, source[key], key, object, source);

                  if ((result === result ? result !== value : value === value) || value === undefined && !(key in object)) {
                    object[key] = result;
                  }
                }
                return object;
              }

              var baseAssign = nativeAssign || function (object, source) {
                return source == null ? object : baseCopy(source, getSymbols(source), baseCopy(source, keys(source), object));
              };

              function baseCopy(source, props, object) {
                object || (object = {});

                var index = -1,
                    length = props.length;

                while (++index < length) {
                  var key = props[index];
                  object[key] = source[key];
                }
                return object;
              }

              function baseCallback(func, thisArg, argCount) {
                var type = typeof func;
                if (type == 'function') {
                  return thisArg === undefined ? func : bindCallback(func, thisArg, argCount);
                }
                if (func == null) {
                  return identity;
                }
                if (type == 'object') {
                  return baseMatches(func);
                }
                return thisArg === undefined ? property(func) : baseMatchesProperty(func, thisArg);
              }

              function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
                var result;
                if (customizer) {
                  result = object ? customizer(value, key, object) : customizer(value);
                }
                if (result !== undefined) {
                  return result;
                }
                if (!isObject(value)) {
                  return value;
                }
                var isArr = isArray(value);
                if (isArr) {
                  result = initCloneArray(value);
                  if (!isDeep) {
                    return arrayCopy(value, result);
                  }
                } else {
                  var tag = objToString.call(value),
                      isFunc = tag == funcTag;

                  if (tag == objectTag || tag == argsTag || isFunc && !object) {
                    result = initCloneObject(isFunc ? {} : value);
                    if (!isDeep) {
                      return baseAssign(result, value);
                    }
                  } else {
                    return cloneableTags[tag] ? initCloneByTag(value, tag, isDeep) : object ? value : {};
                  }
                }
                stackA || (stackA = []);
                stackB || (stackB = []);

                var length = stackA.length;
                while (length--) {
                  if (stackA[length] == value) {
                    return stackB[length];
                  }
                }
                stackA.push(value);
                stackB.push(result);

                (isArr ? arrayEach : baseForOwn)(value, function (subValue, key) {
                  result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
                });
                return result;
              }

              var baseEach = createBaseEach(baseForOwn);

              function baseFilter(collection, predicate) {
                var result = [];
                baseEach(collection, function (value, index, collection) {
                  if (predicate(value, index, collection)) {
                    result.push(value);
                  }
                });
                return result;
              }

              var baseFor = createBaseFor();

              function baseForIn(object, iteratee) {
                return baseFor(object, iteratee, keysIn);
              }

              function baseForOwn(object, iteratee) {
                return baseFor(object, iteratee, keys);
              }

              function baseGet(object, path, pathKey) {
                if (object == null) {
                  return;
                }
                if (pathKey !== undefined && pathKey in toObject(object)) {
                  path = [pathKey];
                }
                var index = -1,
                    length = path.length;

                while (object != null && ++index < length) {
                  var result = object = object[path[index]];
                }
                return result;
              }

              function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
                if (value === other) {
                  return value !== 0 || 1 / value == 1 / other;
                }
                var valType = typeof value,
                    othType = typeof other;

                if (valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object' || value == null || other == null) {
                  return value !== value && other !== other;
                }
                return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
              }

              function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
                var objIsArr = isArray(object),
                    othIsArr = isArray(other),
                    objTag = arrayTag,
                    othTag = arrayTag;

                if (!objIsArr) {
                  objTag = objToString.call(object);
                  if (objTag == argsTag) {
                    objTag = objectTag;
                  } else if (objTag != objectTag) {
                    objIsArr = isTypedArray(object);
                  }
                }
                if (!othIsArr) {
                  othTag = objToString.call(other);
                  if (othTag == argsTag) {
                    othTag = objectTag;
                  } else if (othTag != objectTag) {
                    othIsArr = isTypedArray(other);
                  }
                }
                var objIsObj = objTag == objectTag,
                    othIsObj = othTag == objectTag,
                    isSameTag = objTag == othTag;

                if (isSameTag && !(objIsArr || objIsObj)) {
                  return equalByTag(object, other, objTag);
                }
                if (!isLoose) {
                  var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                      othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

                  if (valWrapped || othWrapped) {
                    return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
                  }
                }
                if (!isSameTag) {
                  return false;
                }
                stackA || (stackA = []);
                stackB || (stackB = []);

                var length = stackA.length;
                while (length--) {
                  if (stackA[length] == object) {
                    return stackB[length] == other;
                  }
                }
                stackA.push(object);
                stackB.push(other);

                var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

                stackA.pop();
                stackB.pop();

                return result;
              }

              function baseIsMatch(object, props, values, strictCompareFlags, customizer) {
                var index = -1,
                    length = props.length,
                    noCustomizer = !customizer;

                while (++index < length) {
                  if (noCustomizer && strictCompareFlags[index] ? values[index] !== object[props[index]] : !(props[index] in object)) {
                    return false;
                  }
                }
                index = -1;
                while (++index < length) {
                  var key = props[index],
                      objValue = object[key],
                      srcValue = values[index];

                  if (noCustomizer && strictCompareFlags[index]) {
                    var result = objValue !== undefined || key in object;
                  } else {
                    result = customizer ? customizer(objValue, srcValue, key) : undefined;
                    if (result === undefined) {
                      result = baseIsEqual(srcValue, objValue, customizer, true);
                    }
                  }
                  if (!result) {
                    return false;
                  }
                }
                return true;
              }

              function baseMatches(source) {
                var props = keys(source),
                    length = props.length;

                if (!length) {
                  return constant(true);
                }
                if (length == 1) {
                  var key = props[0],
                      value = source[key];

                  if (isStrictComparable(value)) {
                    return function (object) {
                      if (object == null) {
                        return false;
                      }
                      return object[key] === value && (value !== undefined || key in toObject(object));
                    };
                  }
                }
                var values = Array(length),
                    strictCompareFlags = Array(length);

                while (length--) {
                  value = source[props[length]];
                  values[length] = value;
                  strictCompareFlags[length] = isStrictComparable(value);
                }
                return function (object) {
                  return object != null && baseIsMatch(toObject(object), props, values, strictCompareFlags);
                };
              }

              function baseMatchesProperty(path, value) {
                var isArr = isArray(path),
                    isCommon = isKey(path) && isStrictComparable(value),
                    pathKey = path + '';

                path = toPath(path);
                return function (object) {
                  if (object == null) {
                    return false;
                  }
                  var key = pathKey;
                  object = toObject(object);
                  if ((isArr || !isCommon) && !(key in object)) {
                    object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                    if (object == null) {
                      return false;
                    }
                    key = last(path);
                    object = toObject(object);
                  }
                  return object[key] === value ? value !== undefined || key in object : baseIsEqual(value, object[key], null, true);
                };
              }

              function baseMerge(object, source, customizer, stackA, stackB) {
                if (!isObject(object)) {
                  return object;
                }
                var isSrcArr = isLength(source.length) && (isArray(source) || isTypedArray(source));
                if (!isSrcArr) {
                  var props = keys(source);
                  push.apply(props, getSymbols(source));
                }
                arrayEach(props || source, function (srcValue, key) {
                  if (props) {
                    key = srcValue;
                    srcValue = source[key];
                  }
                  if (isObjectLike(srcValue)) {
                    stackA || (stackA = []);
                    stackB || (stackB = []);
                    baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
                  } else {
                    var value = object[key],
                        result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                        isCommon = result === undefined;

                    if (isCommon) {
                      result = srcValue;
                    }
                    if ((isSrcArr || result !== undefined) && (isCommon || (result === result ? result !== value : value === value))) {
                      object[key] = result;
                    }
                  }
                });
                return object;
              }

              function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
                var length = stackA.length,
                    srcValue = source[key];

                while (length--) {
                  if (stackA[length] == srcValue) {
                    object[key] = stackB[length];
                    return;
                  }
                }
                var value = object[key],
                    result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                    isCommon = result === undefined;

                if (isCommon) {
                  result = srcValue;
                  if (isLength(srcValue.length) && (isArray(srcValue) || isTypedArray(srcValue))) {
                    result = isArray(value) ? value : getLength(value) ? arrayCopy(value) : [];
                  } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                    result = isArguments(value) ? toPlainObject(value) : isPlainObject(value) ? value : {};
                  } else {
                    isCommon = false;
                  }
                }
                stackA.push(srcValue);
                stackB.push(result);

                if (isCommon) {
                  object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
                } else if (result === result ? result !== value : value === value) {
                  object[key] = result;
                }
              }

              function baseProperty(key) {
                return function (object) {
                  return object == null ? undefined : object[key];
                };
              }

              function basePropertyDeep(path) {
                var pathKey = path + '';
                path = toPath(path);
                return function (object) {
                  return baseGet(object, path, pathKey);
                };
              }

              function baseSlice(array, start, end) {
                var index = -1,
                    length = array.length;

                start = start == null ? 0 : +start || 0;
                if (start < 0) {
                  start = -start > length ? 0 : length + start;
                }
                end = end === undefined || end > length ? length : +end || 0;
                if (end < 0) {
                  end += length;
                }
                length = start > end ? 0 : end - start >>> 0;
                start >>>= 0;

                var result = Array(length);
                while (++index < length) {
                  result[index] = array[index + start];
                }
                return result;
              }

              function baseSome(collection, predicate) {
                var result;

                baseEach(collection, function (value, index, collection) {
                  result = predicate(value, index, collection);
                  return !result;
                });
                return !!result;
              }

              function baseValues(object, props) {
                var index = -1,
                    length = props.length,
                    result = Array(length);

                while (++index < length) {
                  result[index] = object[props[index]];
                }
                return result;
              }

              function binaryIndex(array, value, retHighest) {
                var low = 0,
                    high = array ? array.length : low;

                if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                  while (low < high) {
                    var mid = low + high >>> 1,
                        computed = array[mid];

                    if (retHighest ? computed <= value : computed < value) {
                      low = mid + 1;
                    } else {
                      high = mid;
                    }
                  }
                  return high;
                }
                return binaryIndexBy(array, value, identity, retHighest);
              }

              function binaryIndexBy(array, value, iteratee, retHighest) {
                value = iteratee(value);

                var low = 0,
                    high = array ? array.length : 0,
                    valIsNaN = value !== value,
                    valIsUndef = value === undefined;

                while (low < high) {
                  var mid = floor((low + high) / 2),
                      computed = iteratee(array[mid]),
                      isReflexive = computed === computed;

                  if (valIsNaN) {
                    var setLow = isReflexive || retHighest;
                  } else if (valIsUndef) {
                    setLow = isReflexive && (retHighest || computed !== undefined);
                  } else {
                    setLow = retHighest ? computed <= value : computed < value;
                  }
                  if (setLow) {
                    low = mid + 1;
                  } else {
                    high = mid;
                  }
                }
                return nativeMin(high, MAX_ARRAY_INDEX);
              }

              function bindCallback(func, thisArg, argCount) {
                if (typeof func != 'function') {
                  return identity;
                }
                if (thisArg === undefined) {
                  return func;
                }
                switch (argCount) {
                  case 1:
                    return function (value) {
                      return func.call(thisArg, value);
                    };
                  case 3:
                    return function (value, index, collection) {
                      return func.call(thisArg, value, index, collection);
                    };
                  case 4:
                    return function (accumulator, value, index, collection) {
                      return func.call(thisArg, accumulator, value, index, collection);
                    };
                  case 5:
                    return function (value, other, key, object, source) {
                      return func.call(thisArg, value, other, key, object, source);
                    };
                }
                return function () {
                  return func.apply(thisArg, arguments);
                };
              }

              function bufferClone(buffer) {
                return bufferSlice.call(buffer, 0);
              }
              if (!bufferSlice) {
                bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function (buffer) {
                  var byteLength = buffer.byteLength,
                      floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0,
                      offset = floatLength * FLOAT64_BYTES_PER_ELEMENT,
                      result = new ArrayBuffer(byteLength);

                  if (floatLength) {
                    var view = new Float64Array(result, 0, floatLength);
                    view.set(new Float64Array(buffer, 0, floatLength));
                  }
                  if (byteLength != offset) {
                    view = new Uint8Array(result, offset);
                    view.set(new Uint8Array(buffer, offset));
                  }
                  return result;
                };
              }

              function createAssigner(assigner) {
                return restParam(function (object, sources) {
                  var index = -1,
                      length = object == null ? 0 : sources.length,
                      customizer = length > 2 && sources[length - 2],
                      guard = length > 2 && sources[2],
                      thisArg = length > 1 && sources[length - 1];

                  if (typeof customizer == 'function') {
                    customizer = bindCallback(customizer, thisArg, 5);
                    length -= 2;
                  } else {
                    customizer = typeof thisArg == 'function' ? thisArg : null;
                    length -= customizer ? 1 : 0;
                  }
                  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                    customizer = length < 3 ? null : customizer;
                    length = 1;
                  }
                  while (++index < length) {
                    var source = sources[index];
                    if (source) {
                      assigner(object, source, customizer);
                    }
                  }
                  return object;
                });
              }

              function createBaseEach(eachFunc, fromRight) {
                return function (collection, iteratee) {
                  var length = collection ? getLength(collection) : 0;
                  if (!isLength(length)) {
                    return eachFunc(collection, iteratee);
                  }
                  var index = fromRight ? length : -1,
                      iterable = toObject(collection);

                  while (fromRight ? index-- : ++index < length) {
                    if (iteratee(iterable[index], index, iterable) === false) {
                      break;
                    }
                  }
                  return collection;
                };
              }

              function createBaseFor(fromRight) {
                return function (object, iteratee, keysFunc) {
                  var iterable = toObject(object),
                      props = keysFunc(object),
                      length = props.length,
                      index = fromRight ? length : -1;

                  while (fromRight ? index-- : ++index < length) {
                    var key = props[index];
                    if (iteratee(iterable[key], key, iterable) === false) {
                      break;
                    }
                  }
                  return object;
                };
              }

              function createFindIndex(fromRight) {
                return function (array, predicate, thisArg) {
                  if (!(array && array.length)) {
                    return -1;
                  }
                  predicate = getCallback(predicate, thisArg, 3);
                  return baseFindIndex(array, predicate, fromRight);
                };
              }

              function createForEach(arrayFunc, eachFunc) {
                return function (collection, iteratee, thisArg) {
                  return typeof iteratee == 'function' && thisArg === undefined && isArray(collection) ? arrayFunc(collection, iteratee) : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
                };
              }

              function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
                var index = -1,
                    arrLength = array.length,
                    othLength = other.length,
                    result = true;

                if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
                  return false;
                }
                while (result && ++index < arrLength) {
                  var arrValue = array[index],
                      othValue = other[index];

                  result = undefined;
                  if (customizer) {
                    result = isLoose ? customizer(othValue, arrValue, index) : customizer(arrValue, othValue, index);
                  }
                  if (result === undefined) {
                    if (isLoose) {
                      var othIndex = othLength;
                      while (othIndex--) {
                        othValue = other[othIndex];
                        result = arrValue && arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
                        if (result) {
                          break;
                        }
                      }
                    } else {
                      result = arrValue && arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
                    }
                  }
                }
                return !!result;
              }

              function equalByTag(object, other, tag) {
                switch (tag) {
                  case boolTag:
                  case dateTag:
                    return +object == +other;

                  case errorTag:
                    return object.name == other.name && object.message == other.message;

                  case numberTag:
                    return object != +object ? other != +other : object == 0 ? 1 / object == 1 / other : object == +other;

                  case regexpTag:
                  case stringTag:
                    return object == other + '';
                }
                return false;
              }

              function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
                var objProps = keys(object),
                    objLength = objProps.length,
                    othProps = keys(other),
                    othLength = othProps.length;

                if (objLength != othLength && !isLoose) {
                  return false;
                }
                var skipCtor = isLoose,
                    index = -1;

                while (++index < objLength) {
                  var key = objProps[index],
                      result = isLoose ? key in other : hasOwnProperty.call(other, key);

                  if (result) {
                    var objValue = object[key],
                        othValue = other[key];

                    result = undefined;
                    if (customizer) {
                      result = isLoose ? customizer(othValue, objValue, key) : customizer(objValue, othValue, key);
                    }
                    if (result === undefined) {
                      result = objValue && objValue === othValue || equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB);
                    }
                  }
                  if (!result) {
                    return false;
                  }
                  skipCtor || (skipCtor = key == 'constructor');
                }
                if (!skipCtor) {
                  var objCtor = object.constructor,
                      othCtor = other.constructor;

                  if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                    return false;
                  }
                }
                return true;
              }

              function getCallback(func, thisArg, argCount) {
                var result = lodash.callback || callback;
                result = result === callback ? baseCallback : result;
                return argCount ? result(func, thisArg, argCount) : result;
              }

              function getIndexOf(collection, target, fromIndex) {
                var result = lodash.indexOf || indexOf;
                result = result === indexOf ? baseIndexOf : result;
                return collection ? result(collection, target, fromIndex) : result;
              }

              var getLength = baseProperty('length');

              var getSymbols = !getOwnPropertySymbols ? constant([]) : function (object) {
                return getOwnPropertySymbols(toObject(object));
              };

              function initCloneArray(array) {
                var length = array.length,
                    result = new array.constructor(length);

                if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
                  result.index = array.index;
                  result.input = array.input;
                }
                return result;
              }

              function initCloneObject(object) {
                var Ctor = object.constructor;
                if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
                  Ctor = Object;
                }
                return new Ctor();
              }

              function initCloneByTag(object, tag, isDeep) {
                var Ctor = object.constructor;
                switch (tag) {
                  case arrayBufferTag:
                    return bufferClone(object);

                  case boolTag:
                  case dateTag:
                    return new Ctor(+object);

                  case float32Tag:case float64Tag:
                  case int8Tag:case int16Tag:case int32Tag:
                  case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:
                    var buffer = object.buffer;
                    return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

                  case numberTag:
                  case stringTag:
                    return new Ctor(object);

                  case regexpTag:
                    var result = new Ctor(object.source, reFlags.exec(object));
                    result.lastIndex = object.lastIndex;
                }
                return result;
              }

              function isIndex(value, length) {
                value = +value;
                length = length == null ? MAX_SAFE_INTEGER : length;
                return value > -1 && value % 1 == 0 && value < length;
              }

              function isIterateeCall(value, index, object) {
                if (!isObject(object)) {
                  return false;
                }
                var type = typeof index;
                if (type == 'number') {
                  var length = getLength(object),
                      prereq = isLength(length) && isIndex(index, length);
                } else {
                  prereq = type == 'string' && index in object;
                }
                if (prereq) {
                  var other = object[index];
                  return value === value ? value === other : other !== other;
                }
                return false;
              }

              function isKey(value, object) {
                var type = typeof value;
                if (type == 'string' && reIsPlainProp.test(value) || type == 'number') {
                  return true;
                }
                if (isArray(value)) {
                  return false;
                }
                var result = !reIsDeepProp.test(value);
                return result || object != null && value in toObject(object);
              }

              function isLength(value) {
                return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
              }

              function isStrictComparable(value) {
                return value === value && (value === 0 ? 1 / value > 0 : !isObject(value));
              }

              function shimIsPlainObject(value) {
                var Ctor,
                    support = lodash.support;

                if (!(isObjectLike(value) && objToString.call(value) == objectTag) || !hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor))) {
                  return false;
                }
                var result;
                baseForIn(value, function (subValue, key) {
                  result = key;
                });
                return result === undefined || hasOwnProperty.call(value, result);
              }

              function shimKeys(object) {
                var props = keysIn(object),
                    propsLength = props.length,
                    length = propsLength && object.length,
                    support = lodash.support;

                var allowIndexes = length && isLength(length) && (isArray(object) || support.nonEnumArgs && isArguments(object));

                var index = -1,
                    result = [];

                while (++index < propsLength) {
                  var key = props[index];
                  if (allowIndexes && isIndex(key, length) || hasOwnProperty.call(object, key)) {
                    result.push(key);
                  }
                }
                return result;
              }

              function toObject(value) {
                return isObject(value) ? value : Object(value);
              }

              function toPath(value) {
                if (isArray(value)) {
                  return value;
                }
                var result = [];
                baseToString(value).replace(rePropName, function (match, number, quote, string) {
                  result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
                });
                return result;
              }

              var findLastIndex = createFindIndex(true);

              function indexOf(array, value, fromIndex) {
                var length = array ? array.length : 0;
                if (!length) {
                  return -1;
                }
                if (typeof fromIndex == 'number') {
                  fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
                } else if (fromIndex) {
                  var index = binaryIndex(array, value),
                      other = array[index];

                  if (value === value ? value === other : other !== other) {
                    return index;
                  }
                  return -1;
                }
                return baseIndexOf(array, value, fromIndex || 0);
              }

              function last(array) {
                var length = array ? array.length : 0;
                return length ? array[length - 1] : undefined;
              }

              function slice(array, start, end) {
                var length = array ? array.length : 0;
                if (!length) {
                  return [];
                }
                if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
                  start = 0;
                  end = length;
                }
                return baseSlice(array, start, end);
              }

              function unzip(array) {
                var index = -1,
                    length = (array && array.length && arrayMax(arrayMap(array, getLength))) >>> 0,
                    result = Array(length);

                while (++index < length) {
                  result[index] = arrayMap(array, baseProperty(index));
                }
                return result;
              }

              var zip = restParam(unzip);

              var forEach = createForEach(arrayEach, baseEach);

              function includes(collection, target, fromIndex, guard) {
                var length = collection ? getLength(collection) : 0;
                if (!isLength(length)) {
                  collection = values(collection);
                  length = collection.length;
                }
                if (!length) {
                  return false;
                }
                if (typeof fromIndex != 'number' || guard && isIterateeCall(target, fromIndex, guard)) {
                  fromIndex = 0;
                } else {
                  fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex || 0;
                }
                return typeof collection == 'string' || !isArray(collection) && isString(collection) ? fromIndex < length && collection.indexOf(target, fromIndex) > -1 : getIndexOf(collection, target, fromIndex) > -1;
              }

              function reject(collection, predicate, thisArg) {
                var func = isArray(collection) ? arrayFilter : baseFilter;
                predicate = getCallback(predicate, thisArg, 3);
                return func(collection, function (value, index, collection) {
                  return !predicate(value, index, collection);
                });
              }

              function some(collection, predicate, thisArg) {
                var func = isArray(collection) ? arraySome : baseSome;
                if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
                  predicate = null;
                }
                if (typeof predicate != 'function' || thisArg !== undefined) {
                  predicate = getCallback(predicate, thisArg, 3);
                }
                return func(collection, predicate);
              }

              function restParam(func, start) {
                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                start = nativeMax(start === undefined ? func.length - 1 : +start || 0, 0);
                return function () {
                  var args = arguments,
                      index = -1,
                      length = nativeMax(args.length - start, 0),
                      rest = Array(length);

                  while (++index < length) {
                    rest[index] = args[start + index];
                  }
                  switch (start) {
                    case 0:
                      return func.call(this, rest);
                    case 1:
                      return func.call(this, args[0], rest);
                    case 2:
                      return func.call(this, args[0], args[1], rest);
                  }
                  var otherArgs = Array(start + 1);
                  index = -1;
                  while (++index < start) {
                    otherArgs[index] = args[index];
                  }
                  otherArgs[start] = rest;
                  return func.apply(this, otherArgs);
                };
              }

              function clone(value, isDeep, customizer, thisArg) {
                if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
                  isDeep = false;
                } else if (typeof isDeep == 'function') {
                  thisArg = customizer;
                  customizer = isDeep;
                  isDeep = false;
                }
                customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
                return baseClone(value, isDeep, customizer);
              }

              function isArguments(value) {
                var length = isObjectLike(value) ? value.length : undefined;
                return isLength(length) && objToString.call(value) == argsTag;
              }

              var isArray = nativeIsArray || function (value) {
                return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
              };

              function isEmpty(value) {
                if (value == null) {
                  return true;
                }
                var length = getLength(value);
                if (isLength(length) && (isArray(value) || isString(value) || isArguments(value) || isObjectLike(value) && isFunction(value.splice))) {
                  return !length;
                }
                return !keys(value).length;
              }

              var isFunction = !(baseIsFunction(/x/) || Uint8Array && !baseIsFunction(Uint8Array)) ? baseIsFunction : function (value) {
                return objToString.call(value) == funcTag;
              };

              function isObject(value) {
                var type = typeof value;
                return type == 'function' || !!value && type == 'object';
              }

              function isNative(value) {
                if (value == null) {
                  return false;
                }
                if (objToString.call(value) == funcTag) {
                  return reIsNative.test(fnToString.call(value));
                }
                return isObjectLike(value) && reIsHostCtor.test(value);
              }

              function isNumber(value) {
                return typeof value == 'number' || isObjectLike(value) && objToString.call(value) == numberTag;
              }

              var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function (value) {
                if (!(value && objToString.call(value) == objectTag)) {
                  return false;
                }
                var valueOf = value.valueOf,
                    objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

                return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
              };

              function isString(value) {
                return typeof value == 'string' || isObjectLike(value) && objToString.call(value) == stringTag;
              }

              function isTypedArray(value) {
                return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
              }

              function toPlainObject(value) {
                return baseCopy(value, keysIn(value));
              }

              var assign = createAssigner(function (object, source, customizer) {
                return customizer ? assignWith(object, source, customizer) : baseAssign(object, source);
              });

              function has(object, path) {
                if (object == null) {
                  return false;
                }
                var result = hasOwnProperty.call(object, path);
                if (!result && !isKey(path)) {
                  path = toPath(path);
                  object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                  path = last(path);
                  result = object != null && hasOwnProperty.call(object, path);
                }
                return result;
              }

              var keys = !nativeKeys ? shimKeys : function (object) {
                if (object) {
                  var Ctor = object.constructor,
                      length = object.length;
                }
                if (typeof Ctor == 'function' && Ctor.prototype === object || typeof object != 'function' && isLength(length)) {
                  return shimKeys(object);
                }
                return isObject(object) ? nativeKeys(object) : [];
              };

              function keysIn(object) {
                if (object == null) {
                  return [];
                }
                if (!isObject(object)) {
                  object = Object(object);
                }
                var length = object.length;
                length = length && isLength(length) && (isArray(object) || support.nonEnumArgs && isArguments(object)) && length || 0;

                var Ctor = object.constructor,
                    index = -1,
                    isProto = typeof Ctor == 'function' && Ctor.prototype === object,
                    result = Array(length),
                    skipIndexes = length > 0;

                while (++index < length) {
                  result[index] = index + '';
                }
                for (var key in object) {
                  if (!(skipIndexes && isIndex(key, length)) && !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                    result.push(key);
                  }
                }
                return result;
              }

              var merge = createAssigner(baseMerge);

              function values(object) {
                return baseValues(object, keys(object));
              }

              function escapeRegExp(string) {
                string = baseToString(string);
                return string && reHasRegExpChars.test(string) ? string.replace(reRegExpChars, '\\$&') : string;
              }

              function callback(func, thisArg, guard) {
                if (guard && isIterateeCall(func, thisArg, guard)) {
                  thisArg = null;
                }
                return baseCallback(func, thisArg);
              }

              function constant(value) {
                return function () {
                  return value;
                };
              }

              function identity(value) {
                return value;
              }

              function property(path) {
                return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
              }
              lodash.assign = assign;
              lodash.callback = callback;
              lodash.constant = constant;
              lodash.forEach = forEach;
              lodash.keys = keys;
              lodash.keysIn = keysIn;
              lodash.merge = merge;
              lodash.property = property;
              lodash.reject = reject;
              lodash.restParam = restParam;
              lodash.slice = slice;
              lodash.toPlainObject = toPlainObject;
              lodash.unzip = unzip;
              lodash.values = values;
              lodash.zip = zip;

              lodash.each = forEach;
              lodash.extend = assign;
              lodash.iteratee = callback;
              lodash.clone = clone;
              lodash.escapeRegExp = escapeRegExp;
              lodash.findLastIndex = findLastIndex;
              lodash.has = has;
              lodash.identity = identity;
              lodash.includes = includes;
              lodash.indexOf = indexOf;
              lodash.isArguments = isArguments;
              lodash.isArray = isArray;
              lodash.isEmpty = isEmpty;
              lodash.isFunction = isFunction;
              lodash.isNative = isNative;
              lodash.isNumber = isNumber;
              lodash.isObject = isObject;
              lodash.isPlainObject = isPlainObject;
              lodash.isString = isString;
              lodash.isTypedArray = isTypedArray;
              lodash.last = last;
              lodash.some = some;

              lodash.any = some;
              lodash.contains = includes;
              lodash.include = includes;

              lodash.VERSION = VERSION;
              if (freeExports && freeModule) {
                if (moduleExports) {
                  (freeModule.exports = lodash)._ = lodash;
                } else {
                  freeExports._ = lodash;
                }
              } else {
                root._ = lodash;
              }
            }).call(this);
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {}], "/node_modules/jshint/src/jshint.js": [function (_dereq_, module, exports) {

          var _ = _dereq_("../lodash");
          var events = _dereq_("events");
          var vars = _dereq_("./vars.js");
          var messages = _dereq_("./messages.js");
          var Lexer = _dereq_("./lex.js").Lexer;
          var reg = _dereq_("./reg.js");
          var state = _dereq_("./state.js").state;
          var style = _dereq_("./style.js");
          var options = _dereq_("./options.js");
          var scopeManager = _dereq_("./scope-manager.js");

          var JSHINT = function () {
            "use strict";

            var api,
                // Extension API
            bang = {
              "<": true,
              "<=": true,
              "==": true,
              "===": true,
              "!==": true,
              "!=": true,
              ">": true,
              ">=": true,
              "+": true,
              "-": true,
              "*": true,
              "/": true,
              "%": true
            },
                declared,
                // Globals that were declared using /*global ... */ syntax.

            functionicity = ["closure", "exception", "global", "label", "outer", "unused", "var"],
                functions,
                // All of the functions

            inblock,
                indent,
                lookahead,
                lex,
                member,
                membersOnly,
                predefined,
                // Global variables defined by option

            stack,
                urls,
                extraModules = [],
                emitter = new events.EventEmitter();

            function checkOption(name, t) {
              name = name.trim();

              if (/^[+-]W\d{3}$/g.test(name)) {
                return true;
              }

              if (options.validNames.indexOf(name) === -1) {
                if (t.type !== "jslint" && !_.has(options.removed, name)) {
                  error("E001", t, name);
                  return false;
                }
              }

              return true;
            }

            function isString(obj) {
              return Object.prototype.toString.call(obj) === "[object String]";
            }

            function isIdentifier(tkn, value) {
              if (!tkn) return false;

              if (!tkn.identifier || tkn.value !== value) return false;

              return true;
            }

            function isReserved(token) {
              if (!token.reserved) {
                return false;
              }
              var meta = token.meta;

              if (meta && meta.isFutureReservedWord && state.inES5()) {
                if (!meta.es5) {
                  return false;
                }
                if (meta.strictOnly) {
                  if (!state.option.strict && !state.isStrict()) {
                    return false;
                  }
                }

                if (token.isProperty) {
                  return false;
                }
              }

              return true;
            }

            function supplant(str, data) {
              return str.replace(/\{([^{}]*)\}/g, function (a, b) {
                var r = data[b];
                return typeof r === "string" || typeof r === "number" ? r : a;
              });
            }

            function combine(dest, src) {
              Object.keys(src).forEach(function (name) {
                if (_.has(JSHINT.blacklist, name)) return;
                dest[name] = src[name];
              });
            }

            function processenforceall() {
              if (state.option.enforceall) {
                for (var enforceopt in options.bool.enforcing) {
                  if (state.option[enforceopt] === undefined && !options.noenforceall[enforceopt]) {
                    state.option[enforceopt] = true;
                  }
                }
                for (var relaxopt in options.bool.relaxing) {
                  if (state.option[relaxopt] === undefined) {
                    state.option[relaxopt] = false;
                  }
                }
              }
            }

            function assume() {
              processenforceall();
              if (!state.option.esversion && !state.option.moz) {
                if (state.option.es3) {
                  state.option.esversion = 3;
                } else if (state.option.esnext) {
                  state.option.esversion = 6;
                } else {
                  state.option.esversion = 5;
                }
              }

              if (state.inES5()) {
                combine(predefined, vars.ecmaIdentifiers[5]);
              }

              if (state.inES6()) {
                combine(predefined, vars.ecmaIdentifiers[6]);
              }

              if (state.option.module) {
                if (state.option.strict === true) {
                  state.option.strict = "global";
                }
                if (!state.inES6()) {
                  warning("W134", state.tokens.next, "module", 6);
                }
              }

              if (state.option.couch) {
                combine(predefined, vars.couch);
              }

              if (state.option.qunit) {
                combine(predefined, vars.qunit);
              }

              if (state.option.rhino) {
                combine(predefined, vars.rhino);
              }

              if (state.option.shelljs) {
                combine(predefined, vars.shelljs);
                combine(predefined, vars.node);
              }
              if (state.option.typed) {
                combine(predefined, vars.typed);
              }

              if (state.option.phantom) {
                combine(predefined, vars.phantom);
                if (state.option.strict === true) {
                  state.option.strict = "global";
                }
              }

              if (state.option.prototypejs) {
                combine(predefined, vars.prototypejs);
              }

              if (state.option.node) {
                combine(predefined, vars.node);
                combine(predefined, vars.typed);
                if (state.option.strict === true) {
                  state.option.strict = "global";
                }
              }

              if (state.option.devel) {
                combine(predefined, vars.devel);
              }

              if (state.option.dojo) {
                combine(predefined, vars.dojo);
              }

              if (state.option.browser) {
                combine(predefined, vars.browser);
                combine(predefined, vars.typed);
              }

              if (state.option.browserify) {
                combine(predefined, vars.browser);
                combine(predefined, vars.typed);
                combine(predefined, vars.browserify);
                if (state.option.strict === true) {
                  state.option.strict = "global";
                }
              }

              if (state.option.nonstandard) {
                combine(predefined, vars.nonstandard);
              }

              if (state.option.jasmine) {
                combine(predefined, vars.jasmine);
              }

              if (state.option.jquery) {
                combine(predefined, vars.jquery);
              }

              if (state.option.mootools) {
                combine(predefined, vars.mootools);
              }

              if (state.option.worker) {
                combine(predefined, vars.worker);
              }

              if (state.option.wsh) {
                combine(predefined, vars.wsh);
              }

              if (state.option.globalstrict && state.option.strict !== false) {
                state.option.strict = "global";
              }

              if (state.option.yui) {
                combine(predefined, vars.yui);
              }

              if (state.option.mocha) {
                combine(predefined, vars.mocha);
              }
            }
            function quit(code, line, chr) {
              var percentage = Math.floor(line / state.lines.length * 100);
              var message = messages.errors[code].desc;

              throw {
                name: "JSHintError",
                line: line,
                character: chr,
                message: message + " (" + percentage + "% scanned).",
                raw: message,
                code: code
              };
            }

            function removeIgnoredMessages() {
              var ignored = state.ignoredLines;

              if (_.isEmpty(ignored)) return;
              JSHINT.errors = _.reject(JSHINT.errors, function (err) {
                return ignored[err.line];
              });
            }

            function warning(code, t, a, b, c, d) {
              var ch, l, w, msg;

              if (/^W\d{3}$/.test(code)) {
                if (state.ignored[code]) return;

                msg = messages.warnings[code];
              } else if (/E\d{3}/.test(code)) {
                msg = messages.errors[code];
              } else if (/I\d{3}/.test(code)) {
                msg = messages.info[code];
              }

              t = t || state.tokens.next || {};
              if (t.id === "(end)") {
                // `~
                t = state.tokens.curr;
              }

              l = t.line || 0;
              ch = t.from || 0;

              w = {
                id: "(error)",
                raw: msg.desc,
                code: msg.code,
                evidence: state.lines[l - 1] || "",
                line: l,
                character: ch,
                scope: JSHINT.scope,
                a: a,
                b: b,
                c: c,
                d: d
              };

              w.reason = supplant(msg.desc, w);
              JSHINT.errors.push(w);

              removeIgnoredMessages();

              if (JSHINT.errors.length >= state.option.maxerr) quit("E043", l, ch);

              return w;
            }

            function warningAt(m, l, ch, a, b, c, d) {
              return warning(m, {
                line: l,
                from: ch
              }, a, b, c, d);
            }

            function error(m, t, a, b, c, d) {
              warning(m, t, a, b, c, d);
            }

            function errorAt(m, l, ch, a, b, c, d) {
              return error(m, {
                line: l,
                from: ch
              }, a, b, c, d);
            }
            function addInternalSrc(elem, src) {
              var i;
              i = {
                id: "(internal)",
                elem: elem,
                value: src
              };
              JSHINT.internals.push(i);
              return i;
            }

            function doOption() {
              var nt = state.tokens.next;
              var body = nt.body.match(/(-\s+)?[^\s,:]+(?:\s*:\s*(-\s+)?[^\s,]+)?/g) || [];

              var predef = {};
              if (nt.type === "globals") {
                body.forEach(function (g, idx) {
                  g = g.split(":");
                  var key = (g[0] || "").trim();
                  var val = (g[1] || "").trim();

                  if (key === "-" || !key.length) {
                    if (idx > 0 && idx === body.length - 1) {
                      return;
                    }
                    error("E002", nt);
                    return;
                  }

                  if (key.charAt(0) === "-") {
                    key = key.slice(1);
                    val = false;

                    JSHINT.blacklist[key] = key;
                    delete predefined[key];
                  } else {
                    predef[key] = val === "true";
                  }
                });

                combine(predefined, predef);

                for (var key in predef) {
                  if (_.has(predef, key)) {
                    declared[key] = nt;
                  }
                }
              }

              if (nt.type === "exported") {
                body.forEach(function (e, idx) {
                  if (!e.length) {
                    if (idx > 0 && idx === body.length - 1) {
                      return;
                    }
                    error("E002", nt);
                    return;
                  }

                  state.funct["(scope)"].addExported(e);
                });
              }

              if (nt.type === "members") {
                membersOnly = membersOnly || {};

                body.forEach(function (m) {
                  var ch1 = m.charAt(0);
                  var ch2 = m.charAt(m.length - 1);

                  if (ch1 === ch2 && (ch1 === "\"" || ch1 === "'")) {
                    m = m.substr(1, m.length - 2).replace("\\\"", "\"");
                  }

                  membersOnly[m] = false;
                });
              }

              var numvals = ["maxstatements", "maxparams", "maxdepth", "maxcomplexity", "maxerr", "maxlen", "indent"];

              if (nt.type === "jshint" || nt.type === "jslint") {
                body.forEach(function (g) {
                  g = g.split(":");
                  var key = (g[0] || "").trim();
                  var val = (g[1] || "").trim();

                  if (!checkOption(key, nt)) {
                    return;
                  }

                  if (numvals.indexOf(key) >= 0) {
                    if (val !== "false") {
                      val = +val;

                      if (typeof val !== "number" || !isFinite(val) || val <= 0 || Math.floor(val) !== val) {
                        error("E032", nt, g[1].trim());
                        return;
                      }

                      state.option[key] = val;
                    } else {
                      state.option[key] = key === "indent" ? 4 : false;
                    }

                    return;
                  }

                  if (key === "validthis") {

                    if (state.funct["(global)"]) return void error("E009");

                    if (val !== "true" && val !== "false") return void error("E002", nt);

                    state.option.validthis = val === "true";
                    return;
                  }

                  if (key === "quotmark") {
                    switch (val) {
                      case "true":
                      case "false":
                        state.option.quotmark = val === "true";
                        break;
                      case "double":
                      case "single":
                        state.option.quotmark = val;
                        break;
                      default:
                        error("E002", nt);
                    }
                    return;
                  }

                  if (key === "shadow") {
                    switch (val) {
                      case "true":
                        state.option.shadow = true;
                        break;
                      case "outer":
                        state.option.shadow = "outer";
                        break;
                      case "false":
                      case "inner":
                        state.option.shadow = "inner";
                        break;
                      default:
                        error("E002", nt);
                    }
                    return;
                  }

                  if (key === "unused") {
                    switch (val) {
                      case "true":
                        state.option.unused = true;
                        break;
                      case "false":
                        state.option.unused = false;
                        break;
                      case "vars":
                      case "strict":
                        state.option.unused = val;
                        break;
                      default:
                        error("E002", nt);
                    }
                    return;
                  }

                  if (key === "latedef") {
                    switch (val) {
                      case "true":
                        state.option.latedef = true;
                        break;
                      case "false":
                        state.option.latedef = false;
                        break;
                      case "nofunc":
                        state.option.latedef = "nofunc";
                        break;
                      default:
                        error("E002", nt);
                    }
                    return;
                  }

                  if (key === "ignore") {
                    switch (val) {
                      case "line":
                        state.ignoredLines[nt.line] = true;
                        removeIgnoredMessages();
                        break;
                      default:
                        error("E002", nt);
                    }
                    return;
                  }

                  if (key === "strict") {
                    switch (val) {
                      case "true":
                        state.option.strict = true;
                        break;
                      case "false":
                        state.option.strict = false;
                        break;
                      case "func":
                      case "global":
                      case "implied":
                        state.option.strict = val;
                        break;
                      default:
                        error("E002", nt);
                    }
                    return;
                  }

                  if (key === "module") {
                    if (!hasParsedCode(state.funct)) {
                      error("E055", state.tokens.next, "module");
                    }
                  }
                  var esversions = {
                    es3: 3,
                    es5: 5,
                    esnext: 6
                  };
                  if (_.has(esversions, key)) {
                    switch (val) {
                      case "true":
                        state.option.moz = false;
                        state.option.esversion = esversions[key];
                        break;
                      case "false":
                        if (!state.option.moz) {
                          state.option.esversion = 5;
                        }
                        break;
                      default:
                        error("E002", nt);
                    }
                    return;
                  }

                  if (key === "esversion") {
                    switch (val) {
                      case "5":
                        if (state.inES5(true)) {
                          warning("I003");
                        }
                      case "3":
                      case "6":
                        state.option.moz = false;
                        state.option.esversion = +val;
                        break;
                      case "2015":
                        state.option.moz = false;
                        state.option.esversion = 6;
                        break;
                      default:
                        error("E002", nt);
                    }
                    if (!hasParsedCode(state.funct)) {
                      error("E055", state.tokens.next, "esversion");
                    }
                    return;
                  }

                  var match = /^([+-])(W\d{3})$/g.exec(key);
                  if (match) {
                    state.ignored[match[2]] = match[1] === "-";
                    return;
                  }

                  var tn;
                  if (val === "true" || val === "false") {
                    if (nt.type === "jslint") {
                      tn = options.renamed[key] || key;
                      state.option[tn] = val === "true";

                      if (options.inverted[tn] !== undefined) {
                        state.option[tn] = !state.option[tn];
                      }
                    } else {
                      state.option[key] = val === "true";
                    }

                    if (key === "newcap") {
                      state.option["(explicitNewcap)"] = true;
                    }
                    return;
                  }

                  error("E002", nt);
                });

                assume();
              }
            }

            function peek(p) {
              var i = p || 0,
                  j = lookahead.length,
                  t;

              if (i < j) {
                return lookahead[i];
              }

              while (j <= i) {
                t = lookahead[j];
                if (!t) {
                  t = lookahead[j] = lex.token();
                }
                j += 1;
              }
              if (!t && state.tokens.next.id === "(end)") {
                return state.tokens.next;
              }

              return t;
            }

            function peekIgnoreEOL() {
              var i = 0;
              var t;
              do {
                t = peek(i++);
              } while (t.id === "(endline)");
              return t;
            }

            function advance(id, t) {

              switch (state.tokens.curr.id) {
                case "(number)":
                  if (state.tokens.next.id === ".") {
                    warning("W005", state.tokens.curr);
                  }
                  break;
                case "-":
                  if (state.tokens.next.id === "-" || state.tokens.next.id === "--") {
                    warning("W006");
                  }
                  break;
                case "+":
                  if (state.tokens.next.id === "+" || state.tokens.next.id === "++") {
                    warning("W007");
                  }
                  break;
              }

              if (id && state.tokens.next.id !== id) {
                if (t) {
                  if (state.tokens.next.id === "(end)") {
                    error("E019", t, t.id);
                  } else {
                    error("E020", state.tokens.next, id, t.id, t.line, state.tokens.next.value);
                  }
                } else if (state.tokens.next.type !== "(identifier)" || state.tokens.next.value !== id) {
                  warning("W116", state.tokens.next, id, state.tokens.next.value);
                }
              }

              state.tokens.prev = state.tokens.curr;
              state.tokens.curr = state.tokens.next;
              for (;;) {
                state.tokens.next = lookahead.shift() || lex.token();

                if (!state.tokens.next) {
                  // No more tokens left, give up
                  quit("E041", state.tokens.curr.line);
                }

                if (state.tokens.next.id === "(end)" || state.tokens.next.id === "(error)") {
                  return;
                }

                if (state.tokens.next.check) {
                  state.tokens.next.check();
                }

                if (state.tokens.next.isSpecial) {
                  if (state.tokens.next.type === "falls through") {
                    state.tokens.curr.caseFallsThrough = true;
                  } else {
                    doOption();
                  }
                } else {
                  if (state.tokens.next.id !== "(endline)") {
                    break;
                  }
                }
              }
            }

            function isInfix(token) {
              return token.infix || !token.identifier && !token.template && !!token.led;
            }

            function isEndOfExpr() {
              var curr = state.tokens.curr;
              var next = state.tokens.next;
              if (next.id === ";" || next.id === "}" || next.id === ":") {
                return true;
              }
              if (isInfix(next) === isInfix(curr) || curr.id === "yield" && state.inMoz()) {
                return curr.line !== startLine(next);
              }
              return false;
            }

            function isBeginOfExpr(prev) {
              return !prev.left && prev.arity !== "unary";
            }

            function expression(rbp, initial) {
              var left,
                  isArray = false,
                  isObject = false,
                  isLetExpr = false;

              state.nameStack.push();
              if (!initial && state.tokens.next.value === "let" && peek(0).value === "(") {
                if (!state.inMoz()) {
                  warning("W118", state.tokens.next, "let expressions");
                }
                isLetExpr = true;
                state.funct["(scope)"].stack();
                advance("let");
                advance("(");
                state.tokens.prev.fud();
                advance(")");
              }

              if (state.tokens.next.id === "(end)") error("E006", state.tokens.curr);

              var isDangerous = state.option.asi && state.tokens.prev.line !== startLine(state.tokens.curr) && _.contains(["]", ")"], state.tokens.prev.id) && _.contains(["[", "("], state.tokens.curr.id);

              if (isDangerous) warning("W014", state.tokens.curr, state.tokens.curr.id);

              advance();

              if (initial) {
                state.funct["(verb)"] = state.tokens.curr.value;
                state.tokens.curr.beginsStmt = true;
              }

              if (initial === true && state.tokens.curr.fud) {
                left = state.tokens.curr.fud();
              } else {
                if (state.tokens.curr.nud) {
                  left = state.tokens.curr.nud();
                } else {
                  error("E030", state.tokens.curr, state.tokens.curr.id);
                }
                while ((rbp < state.tokens.next.lbp || state.tokens.next.type === "(template)") && !isEndOfExpr()) {
                  isArray = state.tokens.curr.value === "Array";
                  isObject = state.tokens.curr.value === "Object";
                  if (left && (left.value || left.first && left.first.value)) {
                    if (left.value !== "new" || left.first && left.first.value && left.first.value === ".") {
                      isArray = false;
                      if (left.value !== state.tokens.curr.value) {
                        isObject = false;
                      }
                    }
                  }

                  advance();

                  if (isArray && state.tokens.curr.id === "(" && state.tokens.next.id === ")") {
                    warning("W009", state.tokens.curr);
                  }

                  if (isObject && state.tokens.curr.id === "(" && state.tokens.next.id === ")") {
                    warning("W010", state.tokens.curr);
                  }

                  if (left && state.tokens.curr.led) {
                    left = state.tokens.curr.led(left);
                  } else {
                    error("E033", state.tokens.curr, state.tokens.curr.id);
                  }
                }
              }
              if (isLetExpr) {
                state.funct["(scope)"].unstack();
              }

              state.nameStack.pop();

              return left;
            }

            function startLine(token) {
              return token.startLine || token.line;
            }

            function nobreaknonadjacent(left, right) {
              left = left || state.tokens.curr;
              right = right || state.tokens.next;
              if (!state.option.laxbreak && left.line !== startLine(right)) {
                warning("W014", right, right.value);
              }
            }

            function nolinebreak(t) {
              t = t || state.tokens.curr;
              if (t.line !== startLine(state.tokens.next)) {
                warning("E022", t, t.value);
              }
            }

            function nobreakcomma(left, right) {
              if (left.line !== startLine(right)) {
                if (!state.option.laxcomma) {
                  if (comma.first) {
                    warning("I001");
                    comma.first = false;
                  }
                  warning("W014", left, right.value);
                }
              }
            }

            function comma(opts) {
              opts = opts || {};

              if (!opts.peek) {
                nobreakcomma(state.tokens.curr, state.tokens.next);
                advance(",");
              } else {
                nobreakcomma(state.tokens.prev, state.tokens.curr);
              }

              if (state.tokens.next.identifier && !(opts.property && state.inES5())) {
                switch (state.tokens.next.value) {
                  case "break":
                  case "case":
                  case "catch":
                  case "continue":
                  case "default":
                  case "do":
                  case "else":
                  case "finally":
                  case "for":
                  case "if":
                  case "in":
                  case "instanceof":
                  case "return":
                  case "switch":
                  case "throw":
                  case "try":
                  case "var":
                  case "let":
                  case "while":
                  case "with":
                    error("E024", state.tokens.next, state.tokens.next.value);
                    return false;
                }
              }

              if (state.tokens.next.type === "(punctuator)") {
                switch (state.tokens.next.value) {
                  case "}":
                  case "]":
                  case ",":
                    if (opts.allowTrailing) {
                      return true;
                    }
                  case ")":
                    error("E024", state.tokens.next, state.tokens.next.value);
                    return false;
                }
              }
              return true;
            }

            function symbol(s, p) {
              var x = state.syntax[s];
              if (!x || typeof x !== "object") {
                state.syntax[s] = x = {
                  id: s,
                  lbp: p,
                  value: s
                };
              }
              return x;
            }

            function delim(s) {
              var x = symbol(s, 0);
              x.delim = true;
              return x;
            }

            function stmt(s, f) {
              var x = delim(s);
              x.identifier = x.reserved = true;
              x.fud = f;
              return x;
            }

            function blockstmt(s, f) {
              var x = stmt(s, f);
              x.block = true;
              return x;
            }

            function reserveName(x) {
              var c = x.id.charAt(0);
              if (c >= "a" && c <= "z" || c >= "A" && c <= "Z") {
                x.identifier = x.reserved = true;
              }
              return x;
            }

            function prefix(s, f) {
              var x = symbol(s, 150);
              reserveName(x);

              x.nud = typeof f === "function" ? f : function () {
                this.arity = "unary";
                this.right = expression(150);

                if (this.id === "++" || this.id === "--") {
                  if (state.option.plusplus) {
                    warning("W016", this, this.id);
                  } else if (this.right && (!this.right.identifier || isReserved(this.right)) && this.right.id !== "." && this.right.id !== "[") {
                    warning("W017", this);
                  }

                  if (this.right && this.right.isMetaProperty) {
                    error("E031", this);
                  } else if (this.right && this.right.identifier) {
                    state.funct["(scope)"].block.modify(this.right.value, this);
                  }
                }

                return this;
              };

              return x;
            }

            function type(s, f) {
              var x = delim(s);
              x.type = s;
              x.nud = f;
              return x;
            }

            function reserve(name, func) {
              var x = type(name, func);
              x.identifier = true;
              x.reserved = true;
              return x;
            }

            function FutureReservedWord(name, meta) {
              var x = type(name, meta && meta.nud || function () {
                return this;
              });

              meta = meta || {};
              meta.isFutureReservedWord = true;

              x.value = name;
              x.identifier = true;
              x.reserved = true;
              x.meta = meta;

              return x;
            }

            function reservevar(s, v) {
              return reserve(s, function () {
                if (typeof v === "function") {
                  v(this);
                }
                return this;
              });
            }

            function infix(s, f, p, w) {
              var x = symbol(s, p);
              reserveName(x);
              x.infix = true;
              x.led = function (left) {
                if (!w) {
                  nobreaknonadjacent(state.tokens.prev, state.tokens.curr);
                }
                if ((s === "in" || s === "instanceof") && left.id === "!") {
                  warning("W018", left, "!");
                }
                if (typeof f === "function") {
                  return f(left, this);
                } else {
                  this.left = left;
                  this.right = expression(p);
                  return this;
                }
              };
              return x;
            }

            function application(s) {
              var x = symbol(s, 42);

              x.led = function (left) {
                nobreaknonadjacent(state.tokens.prev, state.tokens.curr);

                this.left = left;
                this.right = doFunction({ type: "arrow", loneArg: left });
                return this;
              };
              return x;
            }

            function relation(s, f) {
              var x = symbol(s, 100);

              x.led = function (left) {
                nobreaknonadjacent(state.tokens.prev, state.tokens.curr);
                this.left = left;
                var right = this.right = expression(100);

                if (isIdentifier(left, "NaN") || isIdentifier(right, "NaN")) {
                  warning("W019", this);
                } else if (f) {
                  f.apply(this, [left, right]);
                }

                if (!left || !right) {
                  quit("E041", state.tokens.curr.line);
                }

                if (left.id === "!") {
                  warning("W018", left, "!");
                }

                if (right.id === "!") {
                  warning("W018", right, "!");
                }

                return this;
              };
              return x;
            }

            function isPoorRelation(node) {
              return node && (node.type === "(number)" && +node.value === 0 || node.type === "(string)" && node.value === "" || node.type === "null" && !state.option.eqnull || node.type === "true" || node.type === "false" || node.type === "undefined");
            }

            var typeofValues = {};
            typeofValues.legacy = ["xml", "unknown"];
            typeofValues.es3 = ["undefined", "boolean", "number", "string", "function", "object"];
            typeofValues.es3 = typeofValues.es3.concat(typeofValues.legacy);
            typeofValues.es6 = typeofValues.es3.concat("symbol");
            function isTypoTypeof(left, right, state) {
              var values;

              if (state.option.notypeof) return false;

              if (!left || !right) return false;

              values = state.inES6() ? typeofValues.es6 : typeofValues.es3;

              if (right.type === "(identifier)" && right.value === "typeof" && left.type === "(string)") return !_.contains(values, left.value);

              return false;
            }

            function isGlobalEval(left, state) {
              var isGlobal = false;
              if (left.type === "this" && state.funct["(context)"] === null) {
                isGlobal = true;
              } else if (left.type === "(identifier)") {
                if (state.option.node && left.value === "global") {
                  isGlobal = true;
                } else if (state.option.browser && (left.value === "window" || left.value === "document")) {
                  isGlobal = true;
                }
              }

              return isGlobal;
            }

            function findNativePrototype(left) {
              var natives = ["Array", "ArrayBuffer", "Boolean", "Collator", "DataView", "Date", "DateTimeFormat", "Error", "EvalError", "Float32Array", "Float64Array", "Function", "Infinity", "Intl", "Int16Array", "Int32Array", "Int8Array", "Iterator", "Number", "NumberFormat", "Object", "RangeError", "ReferenceError", "RegExp", "StopIteration", "String", "SyntaxError", "TypeError", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray", "URIError"];

              function walkPrototype(obj) {
                if (typeof obj !== "object") return;
                return obj.right === "prototype" ? obj : walkPrototype(obj.left);
              }

              function walkNative(obj) {
                while (!obj.identifier && typeof obj.left === "object") obj = obj.left;

                if (obj.identifier && natives.indexOf(obj.value) >= 0) return obj.value;
              }

              var prototype = walkPrototype(left);
              if (prototype) return walkNative(prototype);
            }
            function checkLeftSideAssign(left, assignToken, options) {

              var allowDestructuring = options && options.allowDestructuring;

              assignToken = assignToken || left;

              if (state.option.freeze) {
                var nativeObject = findNativePrototype(left);
                if (nativeObject) warning("W121", left, nativeObject);
              }

              if (left.identifier && !left.isMetaProperty) {
                state.funct["(scope)"].block.reassign(left.value, left);
              }

              if (left.id === ".") {
                if (!left.left || left.left.value === "arguments" && !state.isStrict()) {
                  warning("E031", assignToken);
                }

                state.nameStack.set(state.tokens.prev);
                return true;
              } else if (left.id === "{" || left.id === "[") {
                if (allowDestructuring && state.tokens.curr.left.destructAssign) {
                  state.tokens.curr.left.destructAssign.forEach(function (t) {
                    if (t.id) {
                      state.funct["(scope)"].block.modify(t.id, t.token);
                    }
                  });
                } else {
                  if (left.id === "{" || !left.left) {
                    warning("E031", assignToken);
                  } else if (left.left.value === "arguments" && !state.isStrict()) {
                    warning("E031", assignToken);
                  }
                }

                if (left.id === "[") {
                  state.nameStack.set(left.right);
                }

                return true;
              } else if (left.isMetaProperty) {
                error("E031", assignToken);
                return true;
              } else if (left.identifier && !isReserved(left)) {
                if (state.funct["(scope)"].labeltype(left.value) === "exception") {
                  warning("W022", left);
                }
                state.nameStack.set(left);
                return true;
              }

              if (left === state.syntax["function"]) {
                warning("W023", state.tokens.curr);
              }

              return false;
            }

            function assignop(s, f, p) {
              var x = infix(s, typeof f === "function" ? f : function (left, that) {
                that.left = left;

                if (left && checkLeftSideAssign(left, that, { allowDestructuring: true })) {
                  that.right = expression(10);
                  return that;
                }

                error("E031", that);
              }, p);

              x.exps = true;
              x.assign = true;
              return x;
            }

            function bitwise(s, f, p) {
              var x = symbol(s, p);
              reserveName(x);
              x.led = typeof f === "function" ? f : function (left) {
                if (state.option.bitwise) {
                  warning("W016", this, this.id);
                }
                this.left = left;
                this.right = expression(p);
                return this;
              };
              return x;
            }

            function bitwiseassignop(s) {
              return assignop(s, function (left, that) {
                if (state.option.bitwise) {
                  warning("W016", that, that.id);
                }

                if (left && checkLeftSideAssign(left, that)) {
                  that.right = expression(10);
                  return that;
                }
                error("E031", that);
              }, 20);
            }

            function suffix(s) {
              var x = symbol(s, 150);

              x.led = function (left) {
                if (state.option.plusplus) {
                  warning("W016", this, this.id);
                } else if ((!left.identifier || isReserved(left)) && left.id !== "." && left.id !== "[") {
                  warning("W017", this);
                }

                if (left.isMetaProperty) {
                  error("E031", this);
                } else if (left && left.identifier) {
                  state.funct["(scope)"].block.modify(left.value, left);
                }

                this.left = left;
                return this;
              };
              return x;
            }

            function optionalidentifier(fnparam, prop, preserve) {
              if (!state.tokens.next.identifier) {
                return;
              }

              if (!preserve) {
                advance();
              }

              var curr = state.tokens.curr;
              var val = state.tokens.curr.value;

              if (!isReserved(curr)) {
                return val;
              }

              if (prop) {
                if (state.inES5()) {
                  return val;
                }
              }

              if (fnparam && val === "undefined") {
                return val;
              }

              warning("W024", state.tokens.curr, state.tokens.curr.id);
              return val;
            }
            function identifier(fnparam, prop) {
              var i = optionalidentifier(fnparam, prop, false);
              if (i) {
                return i;
              }
              if (state.tokens.next.value === "...") {
                if (!state.inES6(true)) {
                  warning("W119", state.tokens.next, "spread/rest operator", "6");
                }
                advance();

                if (checkPunctuator(state.tokens.next, "...")) {
                  warning("E024", state.tokens.next, "...");
                  while (checkPunctuator(state.tokens.next, "...")) {
                    advance();
                  }
                }

                if (!state.tokens.next.identifier) {
                  warning("E024", state.tokens.curr, "...");
                  return;
                }

                return identifier(fnparam, prop);
              } else {
                error("E030", state.tokens.next, state.tokens.next.value);
                if (state.tokens.next.id !== ";") {
                  advance();
                }
              }
            }

            function reachable(controlToken) {
              var i = 0,
                  t;
              if (state.tokens.next.id !== ";" || controlToken.inBracelessBlock) {
                return;
              }
              for (;;) {
                do {
                  t = peek(i);
                  i += 1;
                } while (t.id !== "(end)" && t.id === "(comment)");

                if (t.reach) {
                  return;
                }
                if (t.id !== "(endline)") {
                  if (t.id === "function") {
                    if (state.option.latedef === true) {
                      warning("W026", t);
                    }
                    break;
                  }

                  warning("W027", t, t.value, controlToken.value);
                  break;
                }
              }
            }

            function parseFinalSemicolon() {
              if (state.tokens.next.id !== ";") {
                if (state.tokens.next.isUnclosed) return advance();

                var sameLine = startLine(state.tokens.next) === state.tokens.curr.line && state.tokens.next.id !== "(end)";
                var blockEnd = checkPunctuator(state.tokens.next, "}");

                if (sameLine && !blockEnd) {
                  errorAt("E058", state.tokens.curr.line, state.tokens.curr.character);
                } else if (!state.option.asi) {
                  if (blockEnd && !state.option.lastsemic || !sameLine) {
                    warningAt("W033", state.tokens.curr.line, state.tokens.curr.character);
                  }
                }
              } else {
                advance(";");
              }
            }

            function statement() {
              var i = indent,
                  r,
                  t = state.tokens.next,
                  hasOwnScope = false;

              if (t.id === ";") {
                advance(";");
                return;
              }
              var res = isReserved(t);

              if (res && t.meta && t.meta.isFutureReservedWord && peek().id === ":") {
                warning("W024", t, t.id);
                res = false;
              }

              if (t.identifier && !res && peek().id === ":") {
                advance();
                advance(":");

                hasOwnScope = true;
                state.funct["(scope)"].stack();
                state.funct["(scope)"].block.addBreakLabel(t.value, { token: state.tokens.curr });

                if (!state.tokens.next.labelled && state.tokens.next.value !== "{") {
                  warning("W028", state.tokens.next, t.value, state.tokens.next.value);
                }

                state.tokens.next.label = t.value;
                t = state.tokens.next;
              }

              if (t.id === "{") {
                var iscase = state.funct["(verb)"] === "case" && state.tokens.curr.value === ":";
                block(true, true, false, false, iscase);
                return;
              }

              r = expression(0, true);

              if (r && !(r.identifier && r.value === "function") && !(r.type === "(punctuator)" && r.left && r.left.identifier && r.left.value === "function")) {
                if (!state.isStrict() && state.option.strict === "global") {
                  warning("E007");
                }
              }

              if (!t.block) {
                if (!state.option.expr && (!r || !r.exps)) {
                  warning("W030", state.tokens.curr);
                } else if (state.option.nonew && r && r.left && r.id === "(" && r.left.id === "new") {
                  warning("W031", t);
                }
                parseFinalSemicolon();
              }

              indent = i;
              if (hasOwnScope) {
                state.funct["(scope)"].unstack();
              }
              return r;
            }

            function statements() {
              var a = [],
                  p;

              while (!state.tokens.next.reach && state.tokens.next.id !== "(end)") {
                if (state.tokens.next.id === ";") {
                  p = peek();

                  if (!p || p.id !== "(" && p.id !== "[") {
                    warning("W032");
                  }

                  advance(";");
                } else {
                  a.push(statement());
                }
              }
              return a;
            }
            function directives() {
              var i, p, pn;

              while (state.tokens.next.id === "(string)") {
                p = peek(0);
                if (p.id === "(endline)") {
                  i = 1;
                  do {
                    pn = peek(i++);
                  } while (pn.id === "(endline)");
                  if (pn.id === ";") {
                    p = pn;
                  } else if (pn.value === "[" || pn.value === ".") {
                    break;
                  } else if (!state.option.asi || pn.value === "(") {
                    warning("W033", state.tokens.next);
                  }
                } else if (p.id === "." || p.id === "[") {
                  break;
                } else if (p.id !== ";") {
                  warning("W033", p);
                }

                advance();
                var directive = state.tokens.curr.value;
                if (state.directive[directive] || directive === "use strict" && state.option.strict === "implied") {
                  warning("W034", state.tokens.curr, directive);
                }
                state.directive[directive] = true;

                if (p.id === ";") {
                  advance(";");
                }
              }

              if (state.isStrict()) {
                if (!state.option["(explicitNewcap)"]) {
                  state.option.newcap = true;
                }
                state.option.undef = true;
              }
            }
            function block(ordinary, stmt, isfunc, isfatarrow, iscase) {
              var a,
                  b = inblock,
                  old_indent = indent,
                  m,
                  t,
                  line,
                  d;

              inblock = ordinary;

              t = state.tokens.next;

              var metrics = state.funct["(metrics)"];
              metrics.nestedBlockDepth += 1;
              metrics.verifyMaxNestedBlockDepthPerFunction();

              if (state.tokens.next.id === "{") {
                advance("{");
                state.funct["(scope)"].stack();

                line = state.tokens.curr.line;
                if (state.tokens.next.id !== "}") {
                  indent += state.option.indent;
                  while (!ordinary && state.tokens.next.from > indent) {
                    indent += state.option.indent;
                  }

                  if (isfunc) {
                    m = {};
                    for (d in state.directive) {
                      if (_.has(state.directive, d)) {
                        m[d] = state.directive[d];
                      }
                    }
                    directives();

                    if (state.option.strict && state.funct["(context)"]["(global)"]) {
                      if (!m["use strict"] && !state.isStrict()) {
                        warning("E007");
                      }
                    }
                  }

                  a = statements();

                  metrics.statementCount += a.length;

                  indent -= state.option.indent;
                }

                advance("}", t);

                if (isfunc) {
                  state.funct["(scope)"].validateParams();
                  if (m) {
                    state.directive = m;
                  }
                }

                state.funct["(scope)"].unstack();

                indent = old_indent;
              } else if (!ordinary) {
                if (isfunc) {
                  state.funct["(scope)"].stack();

                  m = {};
                  if (stmt && !isfatarrow && !state.inMoz()) {
                    error("W118", state.tokens.curr, "function closure expressions");
                  }

                  if (!stmt) {
                    for (d in state.directive) {
                      if (_.has(state.directive, d)) {
                        m[d] = state.directive[d];
                      }
                    }
                  }
                  expression(10);

                  if (state.option.strict && state.funct["(context)"]["(global)"]) {
                    if (!m["use strict"] && !state.isStrict()) {
                      warning("E007");
                    }
                  }

                  state.funct["(scope)"].unstack();
                } else {
                  error("E021", state.tokens.next, "{", state.tokens.next.value);
                }
              } else {
                state.funct["(noblockscopedvar)"] = state.tokens.next.id !== "for";
                state.funct["(scope)"].stack();

                if (!stmt || state.option.curly) {
                  warning("W116", state.tokens.next, "{", state.tokens.next.value);
                }

                state.tokens.next.inBracelessBlock = true;
                indent += state.option.indent;
                a = [statement()];
                indent -= state.option.indent;

                state.funct["(scope)"].unstack();
                delete state.funct["(noblockscopedvar)"];
              }
              switch (state.funct["(verb)"]) {
                case "break":
                case "continue":
                case "return":
                case "throw":
                  if (iscase) {
                    break;
                  }
                default:
                  state.funct["(verb)"] = null;
              }

              inblock = b;
              if (ordinary && state.option.noempty && (!a || a.length === 0)) {
                warning("W035", state.tokens.prev);
              }
              metrics.nestedBlockDepth -= 1;
              return a;
            }

            function countMember(m) {
              if (membersOnly && typeof membersOnly[m] !== "boolean") {
                warning("W036", state.tokens.curr, m);
              }
              if (typeof member[m] === "number") {
                member[m] += 1;
              } else {
                member[m] = 1;
              }
            }

            type("(number)", function () {
              return this;
            });

            type("(string)", function () {
              return this;
            });

            state.syntax["(identifier)"] = {
              type: "(identifier)",
              lbp: 0,
              identifier: true,

              nud: function () {
                var v = this.value;
                if (state.tokens.next.id === "=>") {
                  return this;
                }

                if (!state.funct["(comparray)"].check(v)) {
                  state.funct["(scope)"].block.use(v, state.tokens.curr);
                }
                return this;
              },

              led: function () {
                error("E033", state.tokens.next, state.tokens.next.value);
              }
            };

            var baseTemplateSyntax = {
              lbp: 0,
              identifier: false,
              template: true
            };
            state.syntax["(template)"] = _.extend({
              type: "(template)",
              nud: doTemplateLiteral,
              led: doTemplateLiteral,
              noSubst: false
            }, baseTemplateSyntax);

            state.syntax["(template middle)"] = _.extend({
              type: "(template middle)",
              middle: true,
              noSubst: false
            }, baseTemplateSyntax);

            state.syntax["(template tail)"] = _.extend({
              type: "(template tail)",
              tail: true,
              noSubst: false
            }, baseTemplateSyntax);

            state.syntax["(no subst template)"] = _.extend({
              type: "(template)",
              nud: doTemplateLiteral,
              led: doTemplateLiteral,
              noSubst: true,
              tail: true // mark as tail, since it's always the last component
            }, baseTemplateSyntax);

            type("(regexp)", function () {
              return this;
            });

            delim("(endline)");
            delim("(begin)");
            delim("(end)").reach = true;
            delim("(error)").reach = true;
            delim("}").reach = true;
            delim(")");
            delim("]");
            delim("\"").reach = true;
            delim("'").reach = true;
            delim(";");
            delim(":").reach = true;
            delim("#");

            reserve("else");
            reserve("case").reach = true;
            reserve("catch");
            reserve("default").reach = true;
            reserve("finally");
            reservevar("arguments", function (x) {
              if (state.isStrict() && state.funct["(global)"]) {
                warning("E008", x);
              }
            });
            reservevar("eval");
            reservevar("false");
            reservevar("Infinity");
            reservevar("null");
            reservevar("this", function (x) {
              if (state.isStrict() && !isMethod() && !state.option.validthis && (state.funct["(statement)"] && state.funct["(name)"].charAt(0) > "Z" || state.funct["(global)"])) {
                warning("W040", x);
              }
            });
            reservevar("true");
            reservevar("undefined");

            assignop("=", "assign", 20);
            assignop("+=", "assignadd", 20);
            assignop("-=", "assignsub", 20);
            assignop("*=", "assignmult", 20);
            assignop("/=", "assigndiv", 20).nud = function () {
              error("E014");
            };
            assignop("%=", "assignmod", 20);

            bitwiseassignop("&=");
            bitwiseassignop("|=");
            bitwiseassignop("^=");
            bitwiseassignop("<<=");
            bitwiseassignop(">>=");
            bitwiseassignop(">>>=");
            infix(",", function (left, that) {
              var expr;
              that.exprs = [left];

              if (state.option.nocomma) {
                warning("W127");
              }

              if (!comma({ peek: true })) {
                return that;
              }
              while (true) {
                if (!(expr = expression(10))) {
                  break;
                }
                that.exprs.push(expr);
                if (state.tokens.next.value !== "," || !comma()) {
                  break;
                }
              }
              return that;
            }, 10, true);

            infix("?", function (left, that) {
              increaseComplexityCount();
              that.left = left;
              that.right = expression(10);
              advance(":");
              that["else"] = expression(10);
              return that;
            }, 30);

            var orPrecendence = 40;
            infix("||", function (left, that) {
              increaseComplexityCount();
              that.left = left;
              that.right = expression(orPrecendence);
              return that;
            }, orPrecendence);
            infix("&&", "and", 50);
            bitwise("|", "bitor", 70);
            bitwise("^", "bitxor", 80);
            bitwise("&", "bitand", 90);
            relation("==", function (left, right) {
              var eqnull = state.option.eqnull && ((left && left.value) === "null" || (right && right.value) === "null");

              switch (true) {
                case !eqnull && state.option.eqeqeq:
                  this.from = this.character;
                  warning("W116", this, "===", "==");
                  break;
                case isPoorRelation(left):
                  warning("W041", this, "===", left.value);
                  break;
                case isPoorRelation(right):
                  warning("W041", this, "===", right.value);
                  break;
                case isTypoTypeof(right, left, state):
                  warning("W122", this, right.value);
                  break;
                case isTypoTypeof(left, right, state):
                  warning("W122", this, left.value);
                  break;
              }

              return this;
            });
            relation("===", function (left, right) {
              if (isTypoTypeof(right, left, state)) {
                warning("W122", this, right.value);
              } else if (isTypoTypeof(left, right, state)) {
                warning("W122", this, left.value);
              }
              return this;
            });
            relation("!=", function (left, right) {
              var eqnull = state.option.eqnull && ((left && left.value) === "null" || (right && right.value) === "null");

              if (!eqnull && state.option.eqeqeq) {
                this.from = this.character;
                warning("W116", this, "!==", "!=");
              } else if (isPoorRelation(left)) {
                warning("W041", this, "!==", left.value);
              } else if (isPoorRelation(right)) {
                warning("W041", this, "!==", right.value);
              } else if (isTypoTypeof(right, left, state)) {
                warning("W122", this, right.value);
              } else if (isTypoTypeof(left, right, state)) {
                warning("W122", this, left.value);
              }
              return this;
            });
            relation("!==", function (left, right) {
              if (isTypoTypeof(right, left, state)) {
                warning("W122", this, right.value);
              } else if (isTypoTypeof(left, right, state)) {
                warning("W122", this, left.value);
              }
              return this;
            });
            relation("<");
            relation(">");
            relation("<=");
            relation(">=");
            bitwise("<<", "shiftleft", 120);
            bitwise(">>", "shiftright", 120);
            bitwise(">>>", "shiftrightunsigned", 120);
            infix("in", "in", 120);
            infix("instanceof", "instanceof", 120);
            infix("+", function (left, that) {
              var right;
              that.left = left;
              that.right = right = expression(130);

              if (left && right && left.id === "(string)" && right.id === "(string)") {
                left.value += right.value;
                left.character = right.character;
                if (!state.option.scripturl && reg.javascriptURL.test(left.value)) {
                  warning("W050", left);
                }
                return left;
              }

              return that;
            }, 130);
            prefix("+", "num");
            prefix("+++", function () {
              warning("W007");
              this.arity = "unary";
              this.right = expression(150);
              return this;
            });
            infix("+++", function (left) {
              warning("W007");
              this.left = left;
              this.right = expression(130);
              return this;
            }, 130);
            infix("-", "sub", 130);
            prefix("-", "neg");
            prefix("---", function () {
              warning("W006");
              this.arity = "unary";
              this.right = expression(150);
              return this;
            });
            infix("---", function (left) {
              warning("W006");
              this.left = left;
              this.right = expression(130);
              return this;
            }, 130);
            infix("*", "mult", 140);
            infix("/", "div", 140);
            infix("%", "mod", 140);

            suffix("++");
            prefix("++", "preinc");
            state.syntax["++"].exps = true;

            suffix("--");
            prefix("--", "predec");
            state.syntax["--"].exps = true;
            prefix("delete", function () {
              var p = expression(10);
              if (!p) {
                return this;
              }

              if (p.id !== "." && p.id !== "[") {
                warning("W051");
              }
              this.first = p;
              if (p.identifier && !state.isStrict()) {
                p.forgiveUndef = true;
              }
              return this;
            }).exps = true;

            prefix("~", function () {
              if (state.option.bitwise) {
                warning("W016", this, "~");
              }
              this.arity = "unary";
              this.right = expression(150);
              return this;
            });

            prefix("...", function () {
              if (!state.inES6(true)) {
                warning("W119", this, "spread/rest operator", "6");
              }
              if (!state.tokens.next.identifier && state.tokens.next.type !== "(string)" && !checkPunctuators(state.tokens.next, ["[", "("])) {

                error("E030", state.tokens.next, state.tokens.next.value);
              }
              expression(150);
              return this;
            });

            prefix("!", function () {
              this.arity = "unary";
              this.right = expression(150);

              if (!this.right) {
                // '!' followed by nothing? Give up.
                quit("E041", this.line || 0);
              }

              if (bang[this.right.id] === true) {
                warning("W018", this, "!");
              }
              return this;
            });

            prefix("typeof", function () {
              var p = expression(150);
              this.first = this.right = p;

              if (!p) {
                // 'typeof' followed by nothing? Give up.
                quit("E041", this.line || 0, this.character || 0);
              }
              if (p.identifier) {
                p.forgiveUndef = true;
              }
              return this;
            });
            prefix("new", function () {
              var mp = metaProperty("target", function () {
                if (!state.inES6(true)) {
                  warning("W119", state.tokens.prev, "new.target", "6");
                }
                var inFunction,
                    c = state.funct;
                while (c) {
                  inFunction = !c["(global)"];
                  if (!c["(arrow)"]) {
                    break;
                  }
                  c = c["(context)"];
                }
                if (!inFunction) {
                  warning("W136", state.tokens.prev, "new.target");
                }
              });
              if (mp) {
                return mp;
              }

              var c = expression(155),
                  i;
              if (c && c.id !== "function") {
                if (c.identifier) {
                  c["new"] = true;
                  switch (c.value) {
                    case "Number":
                    case "String":
                    case "Boolean":
                    case "Math":
                    case "JSON":
                      warning("W053", state.tokens.prev, c.value);
                      break;
                    case "Symbol":
                      if (state.inES6()) {
                        warning("W053", state.tokens.prev, c.value);
                      }
                      break;
                    case "Function":
                      if (!state.option.evil) {
                        warning("W054");
                      }
                      break;
                    case "Date":
                    case "RegExp":
                    case "this":
                      break;
                    default:
                      if (c.id !== "function") {
                        i = c.value.substr(0, 1);
                        if (state.option.newcap && (i < "A" || i > "Z") && !state.funct["(scope)"].isPredefined(c.value)) {
                          warning("W055", state.tokens.curr);
                        }
                      }
                  }
                } else {
                  if (c.id !== "." && c.id !== "[" && c.id !== "(") {
                    warning("W056", state.tokens.curr);
                  }
                }
              } else {
                if (!state.option.supernew) warning("W057", this);
              }
              if (state.tokens.next.id !== "(" && !state.option.supernew) {
                warning("W058", state.tokens.curr, state.tokens.curr.value);
              }
              this.first = this.right = c;
              return this;
            });
            state.syntax["new"].exps = true;

            prefix("void").exps = true;

            infix(".", function (left, that) {
              var m = identifier(false, true);

              if (typeof m === "string") {
                countMember(m);
              }

              that.left = left;
              that.right = m;

              if (m && m === "hasOwnProperty" && state.tokens.next.value === "=") {
                warning("W001");
              }

              if (left && left.value === "arguments" && (m === "callee" || m === "caller")) {
                if (state.option.noarg) warning("W059", left, m);else if (state.isStrict()) error("E008");
              } else if (!state.option.evil && left && left.value === "document" && (m === "write" || m === "writeln")) {
                warning("W060", left);
              }

              if (!state.option.evil && (m === "eval" || m === "execScript")) {
                if (isGlobalEval(left, state)) {
                  warning("W061");
                }
              }

              return that;
            }, 160, true);

            infix("(", function (left, that) {
              if (state.option.immed && left && !left.immed && left.id === "function") {
                warning("W062");
              }

              var n = 0;
              var p = [];

              if (left) {
                if (left.type === "(identifier)") {
                  if (left.value.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)) {
                    if ("Array Number String Boolean Date Object Error Symbol".indexOf(left.value) === -1) {
                      if (left.value === "Math") {
                        warning("W063", left);
                      } else if (state.option.newcap) {
                        warning("W064", left);
                      }
                    }
                  }
                }
              }

              if (state.tokens.next.id !== ")") {
                for (;;) {
                  p[p.length] = expression(10);
                  n += 1;
                  if (state.tokens.next.id !== ",") {
                    break;
                  }
                  comma();
                }
              }

              advance(")");

              if (typeof left === "object") {
                if (!state.inES5() && left.value === "parseInt" && n === 1) {
                  warning("W065", state.tokens.curr);
                }
                if (!state.option.evil) {
                  if (left.value === "eval" || left.value === "Function" || left.value === "execScript") {
                    warning("W061", left);

                    if (p[0] && [0].id === "(string)") {
                      addInternalSrc(left, p[0].value);
                    }
                  } else if (p[0] && p[0].id === "(string)" && (left.value === "setTimeout" || left.value === "setInterval")) {
                    warning("W066", left);
                    addInternalSrc(left, p[0].value);
                  } else if (p[0] && p[0].id === "(string)" && left.value === "." && left.left.value === "window" && (left.right === "setTimeout" || left.right === "setInterval")) {
                    warning("W066", left);
                    addInternalSrc(left, p[0].value);
                  }
                }
                if (!left.identifier && left.id !== "." && left.id !== "[" && left.id !== "=>" && left.id !== "(" && left.id !== "&&" && left.id !== "||" && left.id !== "?" && !(state.inES6() && left["(name)"])) {
                  warning("W067", that);
                }
              }

              that.left = left;
              return that;
            }, 155, true).exps = true;

            prefix("(", function () {
              var pn = state.tokens.next,
                  pn1,
                  i = -1;
              var ret, triggerFnExpr, first, last;
              var parens = 1;
              var opening = state.tokens.curr;
              var preceeding = state.tokens.prev;
              var isNecessary = !state.option.singleGroups;

              do {
                if (pn.value === "(") {
                  parens += 1;
                } else if (pn.value === ")") {
                  parens -= 1;
                }

                i += 1;
                pn1 = pn;
                pn = peek(i);
              } while (!(parens === 0 && pn1.value === ")") && pn.value !== ";" && pn.type !== "(end)");

              if (state.tokens.next.id === "function") {
                triggerFnExpr = state.tokens.next.immed = true;
              }
              if (pn.value === "=>") {
                return doFunction({ type: "arrow", parsedOpening: true });
              }

              var exprs = [];

              if (state.tokens.next.id !== ")") {
                for (;;) {
                  exprs.push(expression(10));

                  if (state.tokens.next.id !== ",") {
                    break;
                  }

                  if (state.option.nocomma) {
                    warning("W127");
                  }

                  comma();
                }
              }

              advance(")", this);
              if (state.option.immed && exprs[0] && exprs[0].id === "function") {
                if (state.tokens.next.id !== "(" && state.tokens.next.id !== "." && state.tokens.next.id !== "[") {
                  warning("W068", this);
                }
              }

              if (!exprs.length) {
                return;
              }
              if (exprs.length > 1) {
                ret = Object.create(state.syntax[","]);
                ret.exprs = exprs;

                first = exprs[0];
                last = exprs[exprs.length - 1];

                if (!isNecessary) {
                  isNecessary = preceeding.assign || preceeding.delim;
                }
              } else {
                ret = first = last = exprs[0];

                if (!isNecessary) {
                  isNecessary = opening.beginsStmt && (ret.id === "{" || triggerFnExpr || isFunctor(ret)) || triggerFnExpr && (!isEndOfExpr() || state.tokens.prev.id !== "}") || isFunctor(ret) && !isEndOfExpr() || ret.id === "{" && preceeding.id === "=>" || ret.type === "(number)" && checkPunctuator(pn, ".") && /^\d+$/.test(ret.value);
                }
              }

              if (ret) {
                if (!isNecessary && (first.left || first.right || ret.exprs)) {
                  isNecessary = !isBeginOfExpr(preceeding) && first.lbp <= preceeding.lbp || !isEndOfExpr() && last.lbp < state.tokens.next.lbp;
                }

                if (!isNecessary) {
                  warning("W126", opening);
                }

                ret.paren = true;
              }

              return ret;
            });

            application("=>");

            infix("[", function (left, that) {
              var e = expression(10),
                  s;
              if (e && e.type === "(string)") {
                if (!state.option.evil && (e.value === "eval" || e.value === "execScript")) {
                  if (isGlobalEval(left, state)) {
                    warning("W061");
                  }
                }

                countMember(e.value);
                if (!state.option.sub && reg.identifier.test(e.value)) {
                  s = state.syntax[e.value];
                  if (!s || !isReserved(s)) {
                    warning("W069", state.tokens.prev, e.value);
                  }
                }
              }
              advance("]", that);

              if (e && e.value === "hasOwnProperty" && state.tokens.next.value === "=") {
                warning("W001");
              }

              that.left = left;
              that.right = e;
              return that;
            }, 160, true);

            function comprehensiveArrayExpression() {
              var res = {};
              res.exps = true;
              state.funct["(comparray)"].stack();
              var reversed = false;
              if (state.tokens.next.value !== "for") {
                reversed = true;
                if (!state.inMoz()) {
                  warning("W116", state.tokens.next, "for", state.tokens.next.value);
                }
                state.funct["(comparray)"].setState("use");
                res.right = expression(10);
              }

              advance("for");
              if (state.tokens.next.value === "each") {
                advance("each");
                if (!state.inMoz()) {
                  warning("W118", state.tokens.curr, "for each");
                }
              }
              advance("(");
              state.funct["(comparray)"].setState("define");
              res.left = expression(130);
              if (_.contains(["in", "of"], state.tokens.next.value)) {
                advance();
              } else {
                error("E045", state.tokens.curr);
              }
              state.funct["(comparray)"].setState("generate");
              expression(10);

              advance(")");
              if (state.tokens.next.value === "if") {
                advance("if");
                advance("(");
                state.funct["(comparray)"].setState("filter");
                res.filter = expression(10);
                advance(")");
              }

              if (!reversed) {
                state.funct["(comparray)"].setState("use");
                res.right = expression(10);
              }

              advance("]");
              state.funct["(comparray)"].unstack();
              return res;
            }

            prefix("[", function () {
              var blocktype = lookupBlockType();
              if (blocktype.isCompArray) {
                if (!state.option.esnext && !state.inMoz()) {
                  warning("W118", state.tokens.curr, "array comprehension");
                }
                return comprehensiveArrayExpression();
              } else if (blocktype.isDestAssign) {
                this.destructAssign = destructuringPattern({ openingParsed: true, assignment: true });
                return this;
              }
              var b = state.tokens.curr.line !== startLine(state.tokens.next);
              this.first = [];
              if (b) {
                indent += state.option.indent;
                if (state.tokens.next.from === indent + state.option.indent) {
                  indent += state.option.indent;
                }
              }
              while (state.tokens.next.id !== "(end)") {
                while (state.tokens.next.id === ",") {
                  if (!state.option.elision) {
                    if (!state.inES5()) {
                      warning("W070");
                    } else {
                      warning("W128");
                      do {
                        advance(",");
                      } while (state.tokens.next.id === ",");
                      continue;
                    }
                  }
                  advance(",");
                }

                if (state.tokens.next.id === "]") {
                  break;
                }

                this.first.push(expression(10));
                if (state.tokens.next.id === ",") {
                  comma({ allowTrailing: true });
                  if (state.tokens.next.id === "]" && !state.inES5()) {
                    warning("W070", state.tokens.curr);
                    break;
                  }
                } else {
                  break;
                }
              }
              if (b) {
                indent -= state.option.indent;
              }
              advance("]", this);
              return this;
            });

            function isMethod() {
              return state.funct["(statement)"] && state.funct["(statement)"].type === "class" || state.funct["(context)"] && state.funct["(context)"]["(verb)"] === "class";
            }

            function isPropertyName(token) {
              return token.identifier || token.id === "(string)" || token.id === "(number)";
            }

            function propertyName(preserveOrToken) {
              var id;
              var preserve = true;
              if (typeof preserveOrToken === "object") {
                id = preserveOrToken;
              } else {
                preserve = preserveOrToken;
                id = optionalidentifier(false, true, preserve);
              }

              if (!id) {
                if (state.tokens.next.id === "(string)") {
                  id = state.tokens.next.value;
                  if (!preserve) {
                    advance();
                  }
                } else if (state.tokens.next.id === "(number)") {
                  id = state.tokens.next.value.toString();
                  if (!preserve) {
                    advance();
                  }
                }
              } else if (typeof id === "object") {
                if (id.id === "(string)" || id.id === "(identifier)") id = id.value;else if (id.id === "(number)") id = id.value.toString();
              }

              if (id === "hasOwnProperty") {
                warning("W001");
              }

              return id;
            }
            function functionparams(options) {
              var next;
              var paramsIds = [];
              var ident;
              var tokens = [];
              var t;
              var pastDefault = false;
              var pastRest = false;
              var arity = 0;
              var loneArg = options && options.loneArg;

              if (loneArg && loneArg.identifier === true) {
                state.funct["(scope)"].addParam(loneArg.value, loneArg);
                return { arity: 1, params: [loneArg.value] };
              }

              next = state.tokens.next;

              if (!options || !options.parsedOpening) {
                advance("(");
              }

              if (state.tokens.next.id === ")") {
                advance(")");
                return;
              }

              function addParam(addParamArgs) {
                state.funct["(scope)"].addParam.apply(state.funct["(scope)"], addParamArgs);
              }

              for (;;) {
                arity++;
                var currentParams = [];

                if (_.contains(["{", "["], state.tokens.next.id)) {
                  tokens = destructuringPattern();
                  for (t in tokens) {
                    t = tokens[t];
                    if (t.id) {
                      paramsIds.push(t.id);
                      currentParams.push([t.id, t.token]);
                    }
                  }
                } else {
                  if (checkPunctuator(state.tokens.next, "...")) pastRest = true;
                  ident = identifier(true);
                  if (ident) {
                    paramsIds.push(ident);
                    currentParams.push([ident, state.tokens.curr]);
                  } else {
                    while (!checkPunctuators(state.tokens.next, [",", ")"])) advance();
                  }
                }
                if (pastDefault) {
                  if (state.tokens.next.id !== "=") {
                    error("W138", state.tokens.current);
                  }
                }
                if (state.tokens.next.id === "=") {
                  if (!state.inES6()) {
                    warning("W119", state.tokens.next, "default parameters", "6");
                  }
                  advance("=");
                  pastDefault = true;
                  expression(10);
                }
                currentParams.forEach(addParam);

                if (state.tokens.next.id === ",") {
                  if (pastRest) {
                    warning("W131", state.tokens.next);
                  }
                  comma();
                } else {
                  advance(")", next);
                  return { arity: arity, params: paramsIds };
                }
              }
            }

            function functor(name, token, overwrites) {
              var funct = {
                "(name)": name,
                "(breakage)": 0,
                "(loopage)": 0,
                "(tokens)": {},
                "(properties)": {},

                "(catch)": false,
                "(global)": false,

                "(line)": null,
                "(character)": null,
                "(metrics)": null,
                "(statement)": null,
                "(context)": null,
                "(scope)": null,
                "(comparray)": null,
                "(generator)": null,
                "(arrow)": null,
                "(params)": null
              };

              if (token) {
                _.extend(funct, {
                  "(line)": token.line,
                  "(character)": token.character,
                  "(metrics)": createMetrics(token)
                });
              }

              _.extend(funct, overwrites);

              if (funct["(context)"]) {
                funct["(scope)"] = funct["(context)"]["(scope)"];
                funct["(comparray)"] = funct["(context)"]["(comparray)"];
              }

              return funct;
            }

            function isFunctor(token) {
              return "(scope)" in token;
            }
            function hasParsedCode(funct) {
              return funct["(global)"] && !funct["(verb)"];
            }

            function doTemplateLiteral(left) {
              var ctx = this.context;
              var noSubst = this.noSubst;
              var depth = this.depth;

              if (!noSubst) {
                while (!end()) {
                  if (!state.tokens.next.template || state.tokens.next.depth > depth) {
                    expression(0); // should probably have different rbp?
                  } else {
                    advance();
                  }
                }
              }

              return {
                id: "(template)",
                type: "(template)",
                tag: left
              };

              function end() {
                if (state.tokens.curr.template && state.tokens.curr.tail && state.tokens.curr.context === ctx) return true;
                var complete = state.tokens.next.template && state.tokens.next.tail && state.tokens.next.context === ctx;
                if (complete) advance();
                return complete || state.tokens.next.isUnclosed;
              }
            }
            function doFunction(options) {
              var f, token, name, statement, classExprBinding, isGenerator, isArrow, ignoreLoopFunc;
              var oldOption = state.option;
              var oldIgnored = state.ignored;

              if (options) {
                name = options.name;
                statement = options.statement;
                classExprBinding = options.classExprBinding;
                isGenerator = options.type === "generator";
                isArrow = options.type === "arrow";
                ignoreLoopFunc = options.ignoreLoopFunc;
              }

              state.option = Object.create(state.option);
              state.ignored = Object.create(state.ignored);

              state.funct = functor(name || state.nameStack.infer(), state.tokens.next, {
                "(statement)": statement,
                "(context)": state.funct,
                "(arrow)": isArrow,
                "(generator)": isGenerator
              });

              f = state.funct;
              token = state.tokens.curr;
              token.funct = state.funct;

              functions.push(state.funct);
              state.funct["(scope)"].stack("functionouter");
              var internallyAccessibleName = name || classExprBinding;
              if (internallyAccessibleName) {
                state.funct["(scope)"].block.add(internallyAccessibleName, classExprBinding ? "class" : "function", state.tokens.curr, false);
              }
              state.funct["(scope)"].stack("functionparams");

              var paramsInfo = functionparams(options);

              if (paramsInfo) {
                state.funct["(params)"] = paramsInfo.params;
                state.funct["(metrics)"].arity = paramsInfo.arity;
                state.funct["(metrics)"].verifyMaxParametersPerFunction();
              } else {
                state.funct["(metrics)"].arity = 0;
              }

              if (isArrow) {
                if (!state.inES6(true)) {
                  warning("W119", state.tokens.curr, "arrow function syntax (=>)", "6");
                }

                if (!options.loneArg) {
                  advance("=>");
                }
              }

              block(false, true, true, isArrow);

              if (!state.option.noyield && isGenerator && state.funct["(generator)"] !== "yielded") {
                warning("W124", state.tokens.curr);
              }

              state.funct["(metrics)"].verifyMaxStatementsPerFunction();
              state.funct["(metrics)"].verifyMaxComplexityPerFunction();
              state.funct["(unusedOption)"] = state.option.unused;
              state.option = oldOption;
              state.ignored = oldIgnored;
              state.funct["(last)"] = state.tokens.curr.line;
              state.funct["(lastcharacter)"] = state.tokens.curr.character;
              state.funct["(scope)"].unstack(); // also does usage and label checks
              state.funct["(scope)"].unstack();

              state.funct = state.funct["(context)"];

              if (!ignoreLoopFunc && !state.option.loopfunc && state.funct["(loopage)"]) {
                if (f["(isCapturing)"]) {
                  warning("W083", token);
                }
              }

              return f;
            }

            function createMetrics(functionStartToken) {
              return {
                statementCount: 0,
                nestedBlockDepth: -1,
                ComplexityCount: 1,
                arity: 0,

                verifyMaxStatementsPerFunction: function () {
                  if (state.option.maxstatements && this.statementCount > state.option.maxstatements) {
                    warning("W071", functionStartToken, this.statementCount);
                  }
                },

                verifyMaxParametersPerFunction: function () {
                  if (_.isNumber(state.option.maxparams) && this.arity > state.option.maxparams) {
                    warning("W072", functionStartToken, this.arity);
                  }
                },

                verifyMaxNestedBlockDepthPerFunction: function () {
                  if (state.option.maxdepth && this.nestedBlockDepth > 0 && this.nestedBlockDepth === state.option.maxdepth + 1) {
                    warning("W073", null, this.nestedBlockDepth);
                  }
                },

                verifyMaxComplexityPerFunction: function () {
                  var max = state.option.maxcomplexity;
                  var cc = this.ComplexityCount;
                  if (max && cc > max) {
                    warning("W074", functionStartToken, cc);
                  }
                }
              };
            }

            function increaseComplexityCount() {
              state.funct["(metrics)"].ComplexityCount += 1;
            }

            function checkCondAssignment(expr) {
              var id, paren;
              if (expr) {
                id = expr.id;
                paren = expr.paren;
                if (id === "," && (expr = expr.exprs[expr.exprs.length - 1])) {
                  id = expr.id;
                  paren = paren || expr.paren;
                }
              }
              switch (id) {
                case "=":
                case "+=":
                case "-=":
                case "*=":
                case "%=":
                case "&=":
                case "|=":
                case "^=":
                case "/=":
                  if (!paren && !state.option.boss) {
                    warning("W084");
                  }
              }
            }
            function checkProperties(props) {
              if (state.inES5()) {
                for (var name in props) {
                  if (props[name] && props[name].setterToken && !props[name].getterToken) {
                    warning("W078", props[name].setterToken);
                  }
                }
              }
            }

            function metaProperty(name, c) {
              if (checkPunctuator(state.tokens.next, ".")) {
                var left = state.tokens.curr.id;
                advance(".");
                var id = identifier();
                state.tokens.curr.isMetaProperty = true;
                if (name !== id) {
                  error("E057", state.tokens.prev, left, id);
                } else {
                  c();
                }
                return state.tokens.curr;
              }
            }

            (function (x) {
              x.nud = function () {
                var b,
                    f,
                    i,
                    p,
                    t,
                    isGeneratorMethod = false,
                    nextVal;
                var props = Object.create(null); // All properties, including accessors

                b = state.tokens.curr.line !== startLine(state.tokens.next);
                if (b) {
                  indent += state.option.indent;
                  if (state.tokens.next.from === indent + state.option.indent) {
                    indent += state.option.indent;
                  }
                }

                var blocktype = lookupBlockType();
                if (blocktype.isDestAssign) {
                  this.destructAssign = destructuringPattern({ openingParsed: true, assignment: true });
                  return this;
                }

                for (;;) {
                  if (state.tokens.next.id === "}") {
                    break;
                  }

                  nextVal = state.tokens.next.value;
                  if (state.tokens.next.identifier && (peekIgnoreEOL().id === "," || peekIgnoreEOL().id === "}")) {
                    if (!state.inES6()) {
                      warning("W104", state.tokens.next, "object short notation", "6");
                    }
                    i = propertyName(true);
                    saveProperty(props, i, state.tokens.next);

                    expression(10);
                  } else if (peek().id !== ":" && (nextVal === "get" || nextVal === "set")) {
                    advance(nextVal);

                    if (!state.inES5()) {
                      error("E034");
                    }

                    i = propertyName();
                    if (!i && !state.inES6()) {
                      error("E035");
                    }
                    if (i) {
                      saveAccessor(nextVal, props, i, state.tokens.curr);
                    }

                    t = state.tokens.next;
                    f = doFunction();
                    p = f["(params)"];
                    if (nextVal === "get" && i && p) {
                      warning("W076", t, p[0], i);
                    } else if (nextVal === "set" && i && (!p || p.length !== 1)) {
                      warning("W077", t, i);
                    }
                  } else {
                    if (state.tokens.next.value === "*" && state.tokens.next.type === "(punctuator)") {
                      if (!state.inES6()) {
                        warning("W104", state.tokens.next, "generator functions", "6");
                      }
                      advance("*");
                      isGeneratorMethod = true;
                    } else {
                      isGeneratorMethod = false;
                    }

                    if (state.tokens.next.id === "[") {
                      i = computedPropertyName();
                      state.nameStack.set(i);
                    } else {
                      state.nameStack.set(state.tokens.next);
                      i = propertyName();
                      saveProperty(props, i, state.tokens.next);

                      if (typeof i !== "string") {
                        break;
                      }
                    }

                    if (state.tokens.next.value === "(") {
                      if (!state.inES6()) {
                        warning("W104", state.tokens.curr, "concise methods", "6");
                      }
                      doFunction({ type: isGeneratorMethod ? "generator" : null });
                    } else {
                      advance(":");
                      expression(10);
                    }
                  }

                  countMember(i);

                  if (state.tokens.next.id === ",") {
                    comma({ allowTrailing: true, property: true });
                    if (state.tokens.next.id === ",") {
                      warning("W070", state.tokens.curr);
                    } else if (state.tokens.next.id === "}" && !state.inES5()) {
                      warning("W070", state.tokens.curr);
                    }
                  } else {
                    break;
                  }
                }
                if (b) {
                  indent -= state.option.indent;
                }
                advance("}", this);

                checkProperties(props);

                return this;
              };
              x.fud = function () {
                error("E036", state.tokens.curr);
              };
            })(delim("{"));

            function destructuringPattern(options) {
              var isAssignment = options && options.assignment;

              if (!state.inES6()) {
                warning("W104", state.tokens.curr, isAssignment ? "destructuring assignment" : "destructuring binding", "6");
              }

              return destructuringPatternRecursive(options);
            }

            function destructuringPatternRecursive(options) {
              var ids;
              var identifiers = [];
              var openingParsed = options && options.openingParsed;
              var isAssignment = options && options.assignment;
              var recursiveOptions = isAssignment ? { assignment: isAssignment } : null;
              var firstToken = openingParsed ? state.tokens.curr : state.tokens.next;

              var nextInnerDE = function () {
                var ident;
                if (checkPunctuators(state.tokens.next, ["[", "{"])) {
                  ids = destructuringPatternRecursive(recursiveOptions);
                  for (var id in ids) {
                    id = ids[id];
                    identifiers.push({ id: id.id, token: id.token });
                  }
                } else if (checkPunctuator(state.tokens.next, ",")) {
                  identifiers.push({ id: null, token: state.tokens.curr });
                } else if (checkPunctuator(state.tokens.next, "(")) {
                  advance("(");
                  nextInnerDE();
                  advance(")");
                } else {
                  var is_rest = checkPunctuator(state.tokens.next, "...");

                  if (isAssignment) {
                    var identifierToken = is_rest ? peek(0) : state.tokens.next;
                    if (!identifierToken.identifier) {
                      warning("E030", identifierToken, identifierToken.value);
                    }
                    var assignTarget = expression(155);
                    if (assignTarget) {
                      checkLeftSideAssign(assignTarget);
                      if (assignTarget.identifier) {
                        ident = assignTarget.value;
                      }
                    }
                  } else {
                    ident = identifier();
                  }
                  if (ident) {
                    identifiers.push({ id: ident, token: state.tokens.curr });
                  }
                  return is_rest;
                }
                return false;
              };
              var assignmentProperty = function () {
                var id;
                if (checkPunctuator(state.tokens.next, "[")) {
                  advance("[");
                  expression(10);
                  advance("]");
                  advance(":");
                  nextInnerDE();
                } else if (state.tokens.next.id === "(string)" || state.tokens.next.id === "(number)") {
                  advance();
                  advance(":");
                  nextInnerDE();
                } else {
                  id = identifier();
                  if (checkPunctuator(state.tokens.next, ":")) {
                    advance(":");
                    nextInnerDE();
                  } else if (id) {
                    if (isAssignment) {
                      checkLeftSideAssign(state.tokens.curr);
                    }
                    identifiers.push({ id: id, token: state.tokens.curr });
                  }
                }
              };
              if (checkPunctuator(firstToken, "[")) {
                if (!openingParsed) {
                  advance("[");
                }
                if (checkPunctuator(state.tokens.next, "]")) {
                  warning("W137", state.tokens.curr);
                }
                var element_after_rest = false;
                while (!checkPunctuator(state.tokens.next, "]")) {
                  if (nextInnerDE() && !element_after_rest && checkPunctuator(state.tokens.next, ",")) {
                    warning("W130", state.tokens.next);
                    element_after_rest = true;
                  }
                  if (checkPunctuator(state.tokens.next, "=")) {
                    if (checkPunctuator(state.tokens.prev, "...")) {
                      advance("]");
                    } else {
                      advance("=");
                    }
                    if (state.tokens.next.id === "undefined") {
                      warning("W080", state.tokens.prev, state.tokens.prev.value);
                    }
                    expression(10);
                  }
                  if (!checkPunctuator(state.tokens.next, "]")) {
                    advance(",");
                  }
                }
                advance("]");
              } else if (checkPunctuator(firstToken, "{")) {

                if (!openingParsed) {
                  advance("{");
                }
                if (checkPunctuator(state.tokens.next, "}")) {
                  warning("W137", state.tokens.curr);
                }
                while (!checkPunctuator(state.tokens.next, "}")) {
                  assignmentProperty();
                  if (checkPunctuator(state.tokens.next, "=")) {
                    advance("=");
                    if (state.tokens.next.id === "undefined") {
                      warning("W080", state.tokens.prev, state.tokens.prev.value);
                    }
                    expression(10);
                  }
                  if (!checkPunctuator(state.tokens.next, "}")) {
                    advance(",");
                    if (checkPunctuator(state.tokens.next, "}")) {
                      break;
                    }
                  }
                }
                advance("}");
              }
              return identifiers;
            }

            function destructuringPatternMatch(tokens, value) {
              var first = value.first;

              if (!first) return;

              _.zip(tokens, Array.isArray(first) ? first : [first]).forEach(function (val) {
                var token = val[0];
                var value = val[1];

                if (token && value) token.first = value;else if (token && token.first && !value) warning("W080", token.first, token.first.value);
              });
            }

            function blockVariableStatement(type, statement, context) {

              var prefix = context && context.prefix;
              var inexport = context && context.inexport;
              var isLet = type === "let";
              var isConst = type === "const";
              var tokens, lone, value, letblock;

              if (!state.inES6()) {
                warning("W104", state.tokens.curr, type, "6");
              }

              if (isLet && state.tokens.next.value === "(") {
                if (!state.inMoz()) {
                  warning("W118", state.tokens.next, "let block");
                }
                advance("(");
                state.funct["(scope)"].stack();
                letblock = true;
              } else if (state.funct["(noblockscopedvar)"]) {
                error("E048", state.tokens.curr, isConst ? "Const" : "Let");
              }

              statement.first = [];
              for (;;) {
                var names = [];
                if (_.contains(["{", "["], state.tokens.next.value)) {
                  tokens = destructuringPattern();
                  lone = false;
                } else {
                  tokens = [{ id: identifier(), token: state.tokens.curr }];
                  lone = true;
                }

                if (!prefix && isConst && state.tokens.next.id !== "=") {
                  warning("E012", state.tokens.curr, state.tokens.curr.value);
                }

                for (var t in tokens) {
                  if (tokens.hasOwnProperty(t)) {
                    t = tokens[t];
                    if (state.funct["(scope)"].block.isGlobal()) {
                      if (predefined[t.id] === false) {
                        warning("W079", t.token, t.id);
                      }
                    }
                    if (t.id && !state.funct["(noblockscopedvar)"]) {
                      state.funct["(scope)"].addlabel(t.id, {
                        type: type,
                        token: t.token });
                      names.push(t.token);

                      if (lone && inexport) {
                        state.funct["(scope)"].setExported(t.token.value, t.token);
                      }
                    }
                  }
                }

                if (state.tokens.next.id === "=") {
                  advance("=");
                  if (!prefix && state.tokens.next.id === "undefined") {
                    warning("W080", state.tokens.prev, state.tokens.prev.value);
                  }
                  if (!prefix && peek(0).id === "=" && state.tokens.next.identifier) {
                    warning("W120", state.tokens.next, state.tokens.next.value);
                  }
                  value = expression(prefix ? 120 : 10);
                  if (lone) {
                    tokens[0].first = value;
                  } else {
                    destructuringPatternMatch(names, value);
                  }
                }

                statement.first = statement.first.concat(names);

                if (state.tokens.next.id !== ",") {
                  break;
                }
                comma();
              }
              if (letblock) {
                advance(")");
                block(true, true);
                statement.block = true;
                state.funct["(scope)"].unstack();
              }

              return statement;
            }

            var conststatement = stmt("const", function (context) {
              return blockVariableStatement("const", this, context);
            });
            conststatement.exps = true;

            var letstatement = stmt("let", function (context) {
              return blockVariableStatement("let", this, context);
            });
            letstatement.exps = true;

            var varstatement = stmt("var", function (context) {
              var prefix = context && context.prefix;
              var inexport = context && context.inexport;
              var tokens, lone, value;
              var implied = context && context.implied;
              var report = !(context && context.ignore);

              this.first = [];
              for (;;) {
                var names = [];
                if (_.contains(["{", "["], state.tokens.next.value)) {
                  tokens = destructuringPattern();
                  lone = false;
                } else {
                  tokens = [{ id: identifier(), token: state.tokens.curr }];
                  lone = true;
                }

                if (!(prefix && implied) && report && state.option.varstmt) {
                  warning("W132", this);
                }

                this.first = this.first.concat(names);

                for (var t in tokens) {
                  if (tokens.hasOwnProperty(t)) {
                    t = tokens[t];
                    if (!implied && state.funct["(global)"]) {
                      if (predefined[t.id] === false) {
                        warning("W079", t.token, t.id);
                      } else if (state.option.futurehostile === false) {
                        if (!state.inES5() && vars.ecmaIdentifiers[5][t.id] === false || !state.inES6() && vars.ecmaIdentifiers[6][t.id] === false) {
                          warning("W129", t.token, t.id);
                        }
                      }
                    }
                    if (t.id) {
                      if (implied === "for") {

                        if (!state.funct["(scope)"].has(t.id)) {
                          if (report) warning("W088", t.token, t.id);
                        }
                        state.funct["(scope)"].block.use(t.id, t.token);
                      } else {
                        state.funct["(scope)"].addlabel(t.id, {
                          type: "var",
                          token: t.token });

                        if (lone && inexport) {
                          state.funct["(scope)"].setExported(t.id, t.token);
                        }
                      }
                      names.push(t.token);
                    }
                  }
                }

                if (state.tokens.next.id === "=") {
                  state.nameStack.set(state.tokens.curr);

                  advance("=");
                  if (!prefix && report && !state.funct["(loopage)"] && state.tokens.next.id === "undefined") {
                    warning("W080", state.tokens.prev, state.tokens.prev.value);
                  }
                  if (peek(0).id === "=" && state.tokens.next.identifier) {
                    if (!prefix && report && !state.funct["(params)"] || state.funct["(params)"].indexOf(state.tokens.next.value) === -1) {
                      warning("W120", state.tokens.next, state.tokens.next.value);
                    }
                  }
                  value = expression(prefix ? 120 : 10);
                  if (lone) {
                    tokens[0].first = value;
                  } else {
                    destructuringPatternMatch(names, value);
                  }
                }

                if (state.tokens.next.id !== ",") {
                  break;
                }
                comma();
              }

              return this;
            });
            varstatement.exps = true;

            blockstmt("class", function () {
              return classdef.call(this, true);
            });

            function classdef(isStatement) {
              if (!state.inES6()) {
                warning("W104", state.tokens.curr, "class", "6");
              }
              if (isStatement) {
                this.name = identifier();

                state.funct["(scope)"].addlabel(this.name, {
                  type: "class",
                  token: state.tokens.curr });
              } else if (state.tokens.next.identifier && state.tokens.next.value !== "extends") {
                this.name = identifier();
                this.namedExpr = true;
              } else {
                this.name = state.nameStack.infer();
              }
              classtail(this);
              return this;
            }

            function classtail(c) {
              var wasInClassBody = state.inClassBody;
              if (state.tokens.next.value === "extends") {
                advance("extends");
                c.heritage = expression(10);
              }

              state.inClassBody = true;
              advance("{");
              c.body = classbody(c);
              advance("}");
              state.inClassBody = wasInClassBody;
            }

            function classbody(c) {
              var name;
              var isStatic;
              var isGenerator;
              var getset;
              var props = Object.create(null);
              var staticProps = Object.create(null);
              var computed;
              for (var i = 0; state.tokens.next.id !== "}"; ++i) {
                name = state.tokens.next;
                isStatic = false;
                isGenerator = false;
                getset = null;
                if (name.id === ";") {
                  warning("W032");
                  advance(";");
                  continue;
                }

                if (name.id === "*") {
                  isGenerator = true;
                  advance("*");
                  name = state.tokens.next;
                }
                if (name.id === "[") {
                  name = computedPropertyName();
                  computed = true;
                } else if (isPropertyName(name)) {
                  advance();
                  computed = false;
                  if (name.identifier && name.value === "static") {
                    if (checkPunctuator(state.tokens.next, "*")) {
                      isGenerator = true;
                      advance("*");
                    }
                    if (isPropertyName(state.tokens.next) || state.tokens.next.id === "[") {
                      computed = state.tokens.next.id === "[";
                      isStatic = true;
                      name = state.tokens.next;
                      if (state.tokens.next.id === "[") {
                        name = computedPropertyName();
                      } else advance();
                    }
                  }

                  if (name.identifier && (name.value === "get" || name.value === "set")) {
                    if (isPropertyName(state.tokens.next) || state.tokens.next.id === "[") {
                      computed = state.tokens.next.id === "[";
                      getset = name;
                      name = state.tokens.next;
                      if (state.tokens.next.id === "[") {
                        name = computedPropertyName();
                      } else advance();
                    }
                  }
                } else {
                  warning("W052", state.tokens.next, state.tokens.next.value || state.tokens.next.type);
                  advance();
                  continue;
                }

                if (!checkPunctuator(state.tokens.next, "(")) {
                  error("E054", state.tokens.next, state.tokens.next.value);
                  while (state.tokens.next.id !== "}" && !checkPunctuator(state.tokens.next, "(")) {
                    advance();
                  }
                  if (state.tokens.next.value !== "(") {
                    doFunction({ statement: c });
                  }
                }

                if (!computed) {
                  if (getset) {
                    saveAccessor(getset.value, isStatic ? staticProps : props, name.value, name, true, isStatic);
                  } else {
                    if (name.value === "constructor") {
                      state.nameStack.set(c);
                    } else {
                      state.nameStack.set(name);
                    }
                    saveProperty(isStatic ? staticProps : props, name.value, name, true, isStatic);
                  }
                }

                if (getset && name.value === "constructor") {
                  var propDesc = getset.value === "get" ? "class getter method" : "class setter method";
                  error("E049", name, propDesc, "constructor");
                } else if (name.value === "prototype") {
                  error("E049", name, "class method", "prototype");
                }

                propertyName(name);

                doFunction({
                  statement: c,
                  type: isGenerator ? "generator" : null,
                  classExprBinding: c.namedExpr ? c.name : null
                });
              }

              checkProperties(props);
            }

            blockstmt("function", function (context) {
              var inexport = context && context.inexport;
              var generator = false;
              if (state.tokens.next.value === "*") {
                advance("*");
                if (state.inES6({ strict: true })) {
                  generator = true;
                } else {
                  warning("W119", state.tokens.curr, "function*", "6");
                }
              }
              if (inblock) {
                warning("W082", state.tokens.curr);
              }
              var i = optionalidentifier();

              state.funct["(scope)"].addlabel(i, {
                type: "function",
                token: state.tokens.curr });

              if (i === undefined) {
                warning("W025");
              } else if (inexport) {
                state.funct["(scope)"].setExported(i, state.tokens.prev);
              }

              doFunction({
                name: i,
                statement: this,
                type: generator ? "generator" : null,
                ignoreLoopFunc: inblock // a declaration may already have warned
              });
              if (state.tokens.next.id === "(" && state.tokens.next.line === state.tokens.curr.line) {
                error("E039");
              }
              return this;
            });

            prefix("function", function () {
              var generator = false;

              if (state.tokens.next.value === "*") {
                if (!state.inES6()) {
                  warning("W119", state.tokens.curr, "function*", "6");
                }
                advance("*");
                generator = true;
              }

              var i = optionalidentifier();
              doFunction({ name: i, type: generator ? "generator" : null });
              return this;
            });

            blockstmt("if", function () {
              var t = state.tokens.next;
              increaseComplexityCount();
              state.condition = true;
              advance("(");
              var expr = expression(0);
              checkCondAssignment(expr);
              var forinifcheck = null;
              if (state.option.forin && state.forinifcheckneeded) {
                state.forinifcheckneeded = false; // We only need to analyze the first if inside the loop
                forinifcheck = state.forinifchecks[state.forinifchecks.length - 1];
                if (expr.type === "(punctuator)" && expr.value === "!") {
                  forinifcheck.type = "(negative)";
                } else {
                  forinifcheck.type = "(positive)";
                }
              }

              advance(")", t);
              state.condition = false;
              var s = block(true, true);
              if (forinifcheck && forinifcheck.type === "(negative)") {
                if (s && s[0] && s[0].type === "(identifier)" && s[0].value === "continue") {
                  forinifcheck.type = "(negative-with-continue)";
                }
              }

              if (state.tokens.next.id === "else") {
                advance("else");
                if (state.tokens.next.id === "if" || state.tokens.next.id === "switch") {
                  statement();
                } else {
                  block(true, true);
                }
              }
              return this;
            });

            blockstmt("try", function () {
              var b;

              function doCatch() {
                advance("catch");
                advance("(");

                state.funct["(scope)"].stack("catchparams");

                if (checkPunctuators(state.tokens.next, ["[", "{"])) {
                  var tokens = destructuringPattern();
                  _.each(tokens, function (token) {
                    if (token.id) {
                      state.funct["(scope)"].addParam(token.id, token, "exception");
                    }
                  });
                } else if (state.tokens.next.type !== "(identifier)") {
                  warning("E030", state.tokens.next, state.tokens.next.value);
                } else {
                  state.funct["(scope)"].addParam(identifier(), state.tokens.curr, "exception");
                }

                if (state.tokens.next.value === "if") {
                  if (!state.inMoz()) {
                    warning("W118", state.tokens.curr, "catch filter");
                  }
                  advance("if");
                  expression(0);
                }

                advance(")");

                block(false);

                state.funct["(scope)"].unstack();
              }

              block(true);

              while (state.tokens.next.id === "catch") {
                increaseComplexityCount();
                if (b && !state.inMoz()) {
                  warning("W118", state.tokens.next, "multiple catch blocks");
                }
                doCatch();
                b = true;
              }

              if (state.tokens.next.id === "finally") {
                advance("finally");
                block(true);
                return;
              }

              if (!b) {
                error("E021", state.tokens.next, "catch", state.tokens.next.value);
              }

              return this;
            });

            blockstmt("while", function () {
              var t = state.tokens.next;
              state.funct["(breakage)"] += 1;
              state.funct["(loopage)"] += 1;
              increaseComplexityCount();
              advance("(");
              checkCondAssignment(expression(0));
              advance(")", t);
              block(true, true);
              state.funct["(breakage)"] -= 1;
              state.funct["(loopage)"] -= 1;
              return this;
            }).labelled = true;

            blockstmt("with", function () {
              var t = state.tokens.next;
              if (state.isStrict()) {
                error("E010", state.tokens.curr);
              } else if (!state.option.withstmt) {
                warning("W085", state.tokens.curr);
              }

              advance("(");
              expression(0);
              advance(")", t);
              block(true, true);

              return this;
            });

            blockstmt("switch", function () {
              var t = state.tokens.next;
              var g = false;
              var noindent = false;

              state.funct["(breakage)"] += 1;
              advance("(");
              checkCondAssignment(expression(0));
              advance(")", t);
              t = state.tokens.next;
              advance("{");

              if (state.tokens.next.from === indent) noindent = true;

              if (!noindent) indent += state.option.indent;

              this.cases = [];

              for (;;) {
                switch (state.tokens.next.id) {
                  case "case":
                    switch (state.funct["(verb)"]) {
                      case "yield":
                      case "break":
                      case "case":
                      case "continue":
                      case "return":
                      case "switch":
                      case "throw":
                        break;
                      default:
                        if (!state.tokens.curr.caseFallsThrough) {
                          warning("W086", state.tokens.curr, "case");
                        }
                    }

                    advance("case");
                    this.cases.push(expression(0));
                    increaseComplexityCount();
                    g = true;
                    advance(":");
                    state.funct["(verb)"] = "case";
                    break;
                  case "default":
                    switch (state.funct["(verb)"]) {
                      case "yield":
                      case "break":
                      case "continue":
                      case "return":
                      case "throw":
                        break;
                      default:
                        if (this.cases.length) {
                          if (!state.tokens.curr.caseFallsThrough) {
                            warning("W086", state.tokens.curr, "default");
                          }
                        }
                    }

                    advance("default");
                    g = true;
                    advance(":");
                    break;
                  case "}":
                    if (!noindent) indent -= state.option.indent;

                    advance("}", t);
                    state.funct["(breakage)"] -= 1;
                    state.funct["(verb)"] = undefined;
                    return;
                  case "(end)":
                    error("E023", state.tokens.next, "}");
                    return;
                  default:
                    indent += state.option.indent;
                    if (g) {
                      switch (state.tokens.curr.id) {
                        case ",":
                          error("E040");
                          return;
                        case ":":
                          g = false;
                          statements();
                          break;
                        default:
                          error("E025", state.tokens.curr);
                          return;
                      }
                    } else {
                      if (state.tokens.curr.id === ":") {
                        advance(":");
                        error("E024", state.tokens.curr, ":");
                        statements();
                      } else {
                        error("E021", state.tokens.next, "case", state.tokens.next.value);
                        return;
                      }
                    }
                    indent -= state.option.indent;
                }
              }
              return this;
            }).labelled = true;

            stmt("debugger", function () {
              if (!state.option.debug) {
                warning("W087", this);
              }
              return this;
            }).exps = true;

            (function () {
              var x = stmt("do", function () {
                state.funct["(breakage)"] += 1;
                state.funct["(loopage)"] += 1;
                increaseComplexityCount();

                this.first = block(true, true);
                advance("while");
                var t = state.tokens.next;
                advance("(");
                checkCondAssignment(expression(0));
                advance(")", t);
                state.funct["(breakage)"] -= 1;
                state.funct["(loopage)"] -= 1;
                return this;
              });
              x.labelled = true;
              x.exps = true;
            })();

            blockstmt("for", function () {
              var s,
                  t = state.tokens.next;
              var letscope = false;
              var foreachtok = null;

              if (t.value === "each") {
                foreachtok = t;
                advance("each");
                if (!state.inMoz()) {
                  warning("W118", state.tokens.curr, "for each");
                }
              }

              increaseComplexityCount();
              advance("(");
              var nextop; // contains the token of the "in" or "of" operator
              var i = 0;
              var inof = ["in", "of"];
              var level = 0; // BindingPattern "level" --- level 0 === no BindingPattern
              var comma; // First comma punctuator at level 0
              var initializer; // First initializer at level 0
              if (checkPunctuators(state.tokens.next, ["{", "["])) ++level;
              do {
                nextop = peek(i);
                ++i;
                if (checkPunctuators(nextop, ["{", "["])) ++level;else if (checkPunctuators(nextop, ["}", "]"])) --level;
                if (level < 0) break;
                if (level === 0) {
                  if (!comma && checkPunctuator(nextop, ",")) comma = nextop;else if (!initializer && checkPunctuator(nextop, "=")) initializer = nextop;
                }
              } while (level > 0 || !_.contains(inof, nextop.value) && nextop.value !== ";" && nextop.type !== "(end)"); // Is this a JSCS bug? This looks really weird.
              if (_.contains(inof, nextop.value)) {
                if (!state.inES6() && nextop.value === "of") {
                  warning("W104", nextop, "for of", "6");
                }

                var ok = !(initializer || comma);
                if (initializer) {
                  error("W133", comma, nextop.value, "initializer is forbidden");
                }

                if (comma) {
                  error("W133", comma, nextop.value, "more than one ForBinding");
                }

                if (state.tokens.next.id === "var") {
                  advance("var");
                  state.tokens.curr.fud({ prefix: true });
                } else if (state.tokens.next.id === "let" || state.tokens.next.id === "const") {
                  advance(state.tokens.next.id);
                  letscope = true;
                  state.funct["(scope)"].stack();
                  state.tokens.curr.fud({ prefix: true });
                } else {
                  Object.create(varstatement).fud({ prefix: true, implied: "for", ignore: !ok });
                }
                advance(nextop.value);
                expression(20);
                advance(")", t);

                if (nextop.value === "in" && state.option.forin) {
                  state.forinifcheckneeded = true;

                  if (state.forinifchecks === undefined) {
                    state.forinifchecks = [];
                  }
                  state.forinifchecks.push({
                    type: "(none)"
                  });
                }

                state.funct["(breakage)"] += 1;
                state.funct["(loopage)"] += 1;

                s = block(true, true);

                if (nextop.value === "in" && state.option.forin) {
                  if (state.forinifchecks && state.forinifchecks.length > 0) {
                    var check = state.forinifchecks.pop();

                    if ( // No if statement or not the first statement in loop body
                    s && s.length > 0 && (typeof s[0] !== "object" || s[0].value !== "if") || check.type === "(positive)" && s.length > 1 || check.type === "(negative)") {
                      warning("W089", this);
                    }
                  }
                  state.forinifcheckneeded = false;
                }

                state.funct["(breakage)"] -= 1;
                state.funct["(loopage)"] -= 1;
              } else {
                if (foreachtok) {
                  error("E045", foreachtok);
                }
                if (state.tokens.next.id !== ";") {
                  if (state.tokens.next.id === "var") {
                    advance("var");
                    state.tokens.curr.fud();
                  } else if (state.tokens.next.id === "let") {
                    advance("let");
                    letscope = true;
                    state.funct["(scope)"].stack();
                    state.tokens.curr.fud();
                  } else {
                    for (;;) {
                      expression(0, "for");
                      if (state.tokens.next.id !== ",") {
                        break;
                      }
                      comma();
                    }
                  }
                }
                nolinebreak(state.tokens.curr);
                advance(";");
                state.funct["(loopage)"] += 1;
                if (state.tokens.next.id !== ";") {
                  checkCondAssignment(expression(0));
                }
                nolinebreak(state.tokens.curr);
                advance(";");
                if (state.tokens.next.id === ";") {
                  error("E021", state.tokens.next, ")", ";");
                }
                if (state.tokens.next.id !== ")") {
                  for (;;) {
                    expression(0, "for");
                    if (state.tokens.next.id !== ",") {
                      break;
                    }
                    comma();
                  }
                }
                advance(")", t);
                state.funct["(breakage)"] += 1;
                block(true, true);
                state.funct["(breakage)"] -= 1;
                state.funct["(loopage)"] -= 1;
              }
              if (letscope) {
                state.funct["(scope)"].unstack();
              }
              return this;
            }).labelled = true;

            stmt("break", function () {
              var v = state.tokens.next.value;

              if (!state.option.asi) nolinebreak(this);

              if (state.tokens.next.id !== ";" && !state.tokens.next.reach && state.tokens.curr.line === startLine(state.tokens.next)) {
                if (!state.funct["(scope)"].funct.hasBreakLabel(v)) {
                  warning("W090", state.tokens.next, v);
                }
                this.first = state.tokens.next;
                advance();
              } else {
                if (state.funct["(breakage)"] === 0) warning("W052", state.tokens.next, this.value);
              }

              reachable(this);

              return this;
            }).exps = true;

            stmt("continue", function () {
              var v = state.tokens.next.value;

              if (state.funct["(breakage)"] === 0) warning("W052", state.tokens.next, this.value);
              if (!state.funct["(loopage)"]) warning("W052", state.tokens.next, this.value);

              if (!state.option.asi) nolinebreak(this);

              if (state.tokens.next.id !== ";" && !state.tokens.next.reach) {
                if (state.tokens.curr.line === startLine(state.tokens.next)) {
                  if (!state.funct["(scope)"].funct.hasBreakLabel(v)) {
                    warning("W090", state.tokens.next, v);
                  }
                  this.first = state.tokens.next;
                  advance();
                }
              }

              reachable(this);

              return this;
            }).exps = true;

            stmt("return", function () {
              if (this.line === startLine(state.tokens.next)) {
                if (state.tokens.next.id !== ";" && !state.tokens.next.reach) {
                  this.first = expression(0);

                  if (this.first && this.first.type === "(punctuator)" && this.first.value === "=" && !this.first.paren && !state.option.boss) {
                    warningAt("W093", this.first.line, this.first.character);
                  }
                }
              } else {
                if (state.tokens.next.type === "(punctuator)" && ["[", "{", "+", "-"].indexOf(state.tokens.next.value) > -1) {
                  nolinebreak(this); // always warn (Line breaking error)
                }
              }

              reachable(this);

              return this;
            }).exps = true;

            (function (x) {
              x.exps = true;
              x.lbp = 25;
            })(prefix("yield", function () {
              var prev = state.tokens.prev;
              if (state.inES6(true) && !state.funct["(generator)"]) {
                if (!("(catch)" === state.funct["(name)"] && state.funct["(context)"]["(generator)"])) {
                  error("E046", state.tokens.curr, "yield");
                }
              } else if (!state.inES6()) {
                warning("W104", state.tokens.curr, "yield", "6");
              }
              state.funct["(generator)"] = "yielded";
              var delegatingYield = false;

              if (state.tokens.next.value === "*") {
                delegatingYield = true;
                advance("*");
              }

              if (this.line === startLine(state.tokens.next) || !state.inMoz()) {
                if (delegatingYield || state.tokens.next.id !== ";" && !state.option.asi && !state.tokens.next.reach && state.tokens.next.nud) {

                  nobreaknonadjacent(state.tokens.curr, state.tokens.next);
                  this.first = expression(10);

                  if (this.first.type === "(punctuator)" && this.first.value === "=" && !this.first.paren && !state.option.boss) {
                    warningAt("W093", this.first.line, this.first.character);
                  }
                }

                if (state.inMoz() && state.tokens.next.id !== ")" && (prev.lbp > 30 || !prev.assign && !isEndOfExpr() || prev.id === "yield")) {
                  error("E050", this);
                }
              } else if (!state.option.asi) {
                nolinebreak(this); // always warn (Line breaking error)
              }
              return this;
            }));

            stmt("throw", function () {
              nolinebreak(this);
              this.first = expression(20);

              reachable(this);

              return this;
            }).exps = true;

            stmt("import", function () {
              if (!state.inES6()) {
                warning("W119", state.tokens.curr, "import", "6");
              }

              if (state.tokens.next.type === "(string)") {
                advance("(string)");
                return this;
              }

              if (state.tokens.next.identifier) {
                this.name = identifier();
                state.funct["(scope)"].addlabel(this.name, {
                  type: "const",
                  token: state.tokens.curr });

                if (state.tokens.next.value === ",") {
                  advance(",");
                } else {
                  advance("from");
                  advance("(string)");
                  return this;
                }
              }

              if (state.tokens.next.id === "*") {
                advance("*");
                advance("as");
                if (state.tokens.next.identifier) {
                  this.name = identifier();
                  state.funct["(scope)"].addlabel(this.name, {
                    type: "const",
                    token: state.tokens.curr });
                }
              } else {
                advance("{");
                for (;;) {
                  if (state.tokens.next.value === "}") {
                    advance("}");
                    break;
                  }
                  var importName;
                  if (state.tokens.next.type === "default") {
                    importName = "default";
                    advance("default");
                  } else {
                    importName = identifier();
                  }
                  if (state.tokens.next.value === "as") {
                    advance("as");
                    importName = identifier();
                  }
                  state.funct["(scope)"].addlabel(importName, {
                    type: "const",
                    token: state.tokens.curr });

                  if (state.tokens.next.value === ",") {
                    advance(",");
                  } else if (state.tokens.next.value === "}") {
                    advance("}");
                    break;
                  } else {
                    error("E024", state.tokens.next, state.tokens.next.value);
                    break;
                  }
                }
              }
              advance("from");
              advance("(string)");
              return this;
            }).exps = true;

            stmt("export", function () {
              var ok = true;
              var token;
              var identifier;

              if (!state.inES6()) {
                warning("W119", state.tokens.curr, "export", "6");
                ok = false;
              }

              if (!state.funct["(scope)"].block.isGlobal()) {
                error("E053", state.tokens.curr);
                ok = false;
              }

              if (state.tokens.next.value === "*") {
                advance("*");
                advance("from");
                advance("(string)");
                return this;
              }

              if (state.tokens.next.type === "default") {
                state.nameStack.set(state.tokens.next);
                advance("default");
                var exportType = state.tokens.next.id;
                if (exportType === "function" || exportType === "class") {
                  this.block = true;
                }

                token = peek();

                expression(10);

                identifier = token.value;

                if (this.block) {
                  state.funct["(scope)"].addlabel(identifier, {
                    type: exportType,
                    token: token });

                  state.funct["(scope)"].setExported(identifier, token);
                }

                return this;
              }

              if (state.tokens.next.value === "{") {
                advance("{");
                var exportedTokens = [];
                for (;;) {
                  if (!state.tokens.next.identifier) {
                    error("E030", state.tokens.next, state.tokens.next.value);
                  }
                  advance();

                  exportedTokens.push(state.tokens.curr);

                  if (state.tokens.next.value === "as") {
                    advance("as");
                    if (!state.tokens.next.identifier) {
                      error("E030", state.tokens.next, state.tokens.next.value);
                    }
                    advance();
                  }

                  if (state.tokens.next.value === ",") {
                    advance(",");
                  } else if (state.tokens.next.value === "}") {
                    advance("}");
                    break;
                  } else {
                    error("E024", state.tokens.next, state.tokens.next.value);
                    break;
                  }
                }
                if (state.tokens.next.value === "from") {
                  advance("from");
                  advance("(string)");
                } else if (ok) {
                  exportedTokens.forEach(function (token) {
                    state.funct["(scope)"].setExported(token.value, token);
                  });
                }
                return this;
              }

              if (state.tokens.next.id === "var") {
                advance("var");
                state.tokens.curr.fud({ inexport: true });
              } else if (state.tokens.next.id === "let") {
                advance("let");
                state.tokens.curr.fud({ inexport: true });
              } else if (state.tokens.next.id === "const") {
                advance("const");
                state.tokens.curr.fud({ inexport: true });
              } else if (state.tokens.next.id === "function") {
                this.block = true;
                advance("function");
                state.syntax["function"].fud({ inexport: true });
              } else if (state.tokens.next.id === "class") {
                this.block = true;
                advance("class");
                var classNameToken = state.tokens.next;
                state.syntax["class"].fud();
                state.funct["(scope)"].setExported(classNameToken.value, classNameToken);
              } else {
                error("E024", state.tokens.next, state.tokens.next.value);
              }

              return this;
            }).exps = true;

            FutureReservedWord("abstract");
            FutureReservedWord("boolean");
            FutureReservedWord("byte");
            FutureReservedWord("char");
            FutureReservedWord("class", { es5: true, nud: classdef });
            FutureReservedWord("double");
            FutureReservedWord("enum", { es5: true });
            FutureReservedWord("export", { es5: true });
            FutureReservedWord("extends", { es5: true });
            FutureReservedWord("final");
            FutureReservedWord("float");
            FutureReservedWord("goto");
            FutureReservedWord("implements", { es5: true, strictOnly: true });
            FutureReservedWord("import", { es5: true });
            FutureReservedWord("int");
            FutureReservedWord("interface", { es5: true, strictOnly: true });
            FutureReservedWord("long");
            FutureReservedWord("native");
            FutureReservedWord("package", { es5: true, strictOnly: true });
            FutureReservedWord("private", { es5: true, strictOnly: true });
            FutureReservedWord("protected", { es5: true, strictOnly: true });
            FutureReservedWord("public", { es5: true, strictOnly: true });
            FutureReservedWord("short");
            FutureReservedWord("static", { es5: true, strictOnly: true });
            FutureReservedWord("super", { es5: true });
            FutureReservedWord("synchronized");
            FutureReservedWord("transient");
            FutureReservedWord("volatile");

            var lookupBlockType = function () {
              var pn, pn1, prev;
              var i = -1;
              var bracketStack = 0;
              var ret = {};
              if (checkPunctuators(state.tokens.curr, ["[", "{"])) {
                bracketStack += 1;
              }
              do {
                prev = i === -1 ? state.tokens.curr : pn;
                pn = i === -1 ? state.tokens.next : peek(i);
                pn1 = peek(i + 1);
                i = i + 1;
                if (checkPunctuators(pn, ["[", "{"])) {
                  bracketStack += 1;
                } else if (checkPunctuators(pn, ["]", "}"])) {
                  bracketStack -= 1;
                }
                if (bracketStack === 1 && pn.identifier && pn.value === "for" && !checkPunctuator(prev, ".")) {
                  ret.isCompArray = true;
                  ret.notJson = true;
                  break;
                }
                if (bracketStack === 0 && checkPunctuators(pn, ["}", "]"])) {
                  if (pn1.value === "=") {
                    ret.isDestAssign = true;
                    ret.notJson = true;
                    break;
                  } else if (pn1.value === ".") {
                    ret.notJson = true;
                    break;
                  }
                }
                if (checkPunctuator(pn, ";")) {
                  ret.isBlock = true;
                  ret.notJson = true;
                }
              } while (bracketStack > 0 && pn.id !== "(end)");
              return ret;
            };

            function saveProperty(props, name, tkn, isClass, isStatic) {
              var msg = ["key", "class method", "static class method"];
              msg = msg[(isClass || false) + (isStatic || false)];
              if (tkn.identifier) {
                name = tkn.value;
              }

              if (props[name] && name !== "__proto__") {
                warning("W075", state.tokens.next, msg, name);
              } else {
                props[name] = Object.create(null);
              }

              props[name].basic = true;
              props[name].basictkn = tkn;
            }
            function saveAccessor(accessorType, props, name, tkn, isClass, isStatic) {
              var flagName = accessorType === "get" ? "getterToken" : "setterToken";
              var msg = "";

              if (isClass) {
                if (isStatic) {
                  msg += "static ";
                }
                msg += accessorType + "ter method";
              } else {
                msg = "key";
              }

              state.tokens.curr.accessorType = accessorType;
              state.nameStack.set(tkn);

              if (props[name]) {
                if ((props[name].basic || props[name][flagName]) && name !== "__proto__") {
                  warning("W075", state.tokens.next, msg, name);
                }
              } else {
                props[name] = Object.create(null);
              }

              props[name][flagName] = tkn;
            }

            function computedPropertyName() {
              advance("[");
              if (!state.inES6()) {
                warning("W119", state.tokens.curr, "computed property names", "6");
              }
              var value = expression(10);
              advance("]");
              return value;
            }
            function checkPunctuators(token, values) {
              if (token.type === "(punctuator)") {
                return _.contains(values, token.value);
              }
              return false;
            }
            function checkPunctuator(token, value) {
              return token.type === "(punctuator)" && token.value === value;
            }
            function destructuringAssignOrJsonValue() {

              var block = lookupBlockType();
              if (block.notJson) {
                if (!state.inES6() && block.isDestAssign) {
                  warning("W104", state.tokens.curr, "destructuring assignment", "6");
                }
                statements();
              } else {
                state.option.laxbreak = true;
                state.jsonMode = true;
                jsonValue();
              }
            }

            var arrayComprehension = function () {
              var CompArray = function () {
                this.mode = "use";
                this.variables = [];
              };
              var _carrays = [];
              var _current;
              function declare(v) {
                var l = _current.variables.filter(function (elt) {
                  if (elt.value === v) {
                    elt.undef = false;
                    return v;
                  }
                }).length;
                return l !== 0;
              }
              function use(v) {
                var l = _current.variables.filter(function (elt) {
                  if (elt.value === v && !elt.undef) {
                    if (elt.unused === true) {
                      elt.unused = false;
                    }
                    return v;
                  }
                }).length;
                return l === 0;
              }
              return { stack: function () {
                  _current = new CompArray();
                  _carrays.push(_current);
                },
                unstack: function () {
                  _current.variables.filter(function (v) {
                    if (v.unused) warning("W098", v.token, v.raw_text || v.value);
                    if (v.undef) state.funct["(scope)"].block.use(v.value, v.token);
                  });
                  _carrays.splice(-1, 1);
                  _current = _carrays[_carrays.length - 1];
                },
                setState: function (s) {
                  if (_.contains(["use", "define", "generate", "filter"], s)) _current.mode = s;
                },
                check: function (v) {
                  if (!_current) {
                    return;
                  }
                  if (_current && _current.mode === "use") {
                    if (use(v)) {
                      _current.variables.push({
                        funct: state.funct,
                        token: state.tokens.curr,
                        value: v,
                        undef: true,
                        unused: false
                      });
                    }
                    return true;
                  } else if (_current && _current.mode === "define") {
                    if (!declare(v)) {
                      _current.variables.push({
                        funct: state.funct,
                        token: state.tokens.curr,
                        value: v,
                        undef: false,
                        unused: true
                      });
                    }
                    return true;
                  } else if (_current && _current.mode === "generate") {
                    state.funct["(scope)"].block.use(v, state.tokens.curr);
                    return true;
                  } else if (_current && _current.mode === "filter") {
                    if (use(v)) {
                      state.funct["(scope)"].block.use(v, state.tokens.curr);
                    }
                    return true;
                  }
                  return false;
                }
              };
            };

            function jsonValue() {
              function jsonObject() {
                var o = {},
                    t = state.tokens.next;
                advance("{");
                if (state.tokens.next.id !== "}") {
                  for (;;) {
                    if (state.tokens.next.id === "(end)") {
                      error("E026", state.tokens.next, t.line);
                    } else if (state.tokens.next.id === "}") {
                      warning("W094", state.tokens.curr);
                      break;
                    } else if (state.tokens.next.id === ",") {
                      error("E028", state.tokens.next);
                    } else if (state.tokens.next.id !== "(string)") {
                      warning("W095", state.tokens.next, state.tokens.next.value);
                    }
                    if (o[state.tokens.next.value] === true) {
                      warning("W075", state.tokens.next, "key", state.tokens.next.value);
                    } else if (state.tokens.next.value === "__proto__" && !state.option.proto || state.tokens.next.value === "__iterator__" && !state.option.iterator) {
                      warning("W096", state.tokens.next, state.tokens.next.value);
                    } else {
                      o[state.tokens.next.value] = true;
                    }
                    advance();
                    advance(":");
                    jsonValue();
                    if (state.tokens.next.id !== ",") {
                      break;
                    }
                    advance(",");
                  }
                }
                advance("}");
              }

              function jsonArray() {
                var t = state.tokens.next;
                advance("[");
                if (state.tokens.next.id !== "]") {
                  for (;;) {
                    if (state.tokens.next.id === "(end)") {
                      error("E027", state.tokens.next, t.line);
                    } else if (state.tokens.next.id === "]") {
                      warning("W094", state.tokens.curr);
                      break;
                    } else if (state.tokens.next.id === ",") {
                      error("E028", state.tokens.next);
                    }
                    jsonValue();
                    if (state.tokens.next.id !== ",") {
                      break;
                    }
                    advance(",");
                  }
                }
                advance("]");
              }

              switch (state.tokens.next.id) {
                case "{":
                  jsonObject();
                  break;
                case "[":
                  jsonArray();
                  break;
                case "true":
                case "false":
                case "null":
                case "(number)":
                case "(string)":
                  advance();
                  break;
                case "-":
                  advance("-");
                  advance("(number)");
                  break;
                default:
                  error("E003", state.tokens.next);
              }
            }

            var escapeRegex = function (str) {
              return str.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
            };
            var itself = function (s, o, g) {
              var i, k, x, reIgnoreStr, reIgnore;
              var optionKeys;
              var newOptionObj = {};
              var newIgnoredObj = {};

              o = _.clone(o);
              state.reset();

              if (o && o.scope) {
                JSHINT.scope = o.scope;
              } else {
                JSHINT.errors = [];
                JSHINT.undefs = [];
                JSHINT.internals = [];
                JSHINT.blacklist = {};
                JSHINT.scope = "(main)";
              }

              predefined = Object.create(null);
              combine(predefined, vars.ecmaIdentifiers[3]);
              combine(predefined, vars.reservedVars);

              combine(predefined, g || {});

              declared = Object.create(null);
              var exported = Object.create(null); // Variables that live outside the current file

              function each(obj, cb) {
                if (!obj) return;

                if (!Array.isArray(obj) && typeof obj === "object") obj = Object.keys(obj);

                obj.forEach(cb);
              }

              if (o) {
                each(o.predef || null, function (item) {
                  var slice, prop;

                  if (item[0] === "-") {
                    slice = item.slice(1);
                    JSHINT.blacklist[slice] = slice;
                    delete predefined[slice];
                  } else {
                    prop = Object.getOwnPropertyDescriptor(o.predef, item);
                    predefined[item] = prop ? prop.value : false;
                  }
                });

                each(o.exported || null, function (item) {
                  exported[item] = true;
                });

                delete o.predef;
                delete o.exported;

                optionKeys = Object.keys(o);
                for (x = 0; x < optionKeys.length; x++) {
                  if (/^-W\d{3}$/g.test(optionKeys[x])) {
                    newIgnoredObj[optionKeys[x].slice(1)] = true;
                  } else {
                    var optionKey = optionKeys[x];
                    newOptionObj[optionKey] = o[optionKey];
                    if (optionKey === "esversion" && o[optionKey] === 5 || optionKey === "es5" && o[optionKey]) {
                      warning("I003");
                    }

                    if (optionKeys[x] === "newcap" && o[optionKey] === false) newOptionObj["(explicitNewcap)"] = true;
                  }
                }
              }

              state.option = newOptionObj;
              state.ignored = newIgnoredObj;

              state.option.indent = state.option.indent || 4;
              state.option.maxerr = state.option.maxerr || 50;

              indent = 1;

              var scopeManagerInst = scopeManager(state, predefined, exported, declared);
              scopeManagerInst.on("warning", function (ev) {
                warning.apply(null, [ev.code, ev.token].concat(ev.data));
              });

              scopeManagerInst.on("error", function (ev) {
                error.apply(null, [ev.code, ev.token].concat(ev.data));
              });

              state.funct = functor("(global)", null, {
                "(global)": true,
                "(scope)": scopeManagerInst,
                "(comparray)": arrayComprehension(),
                "(metrics)": createMetrics(state.tokens.next)
              });

              functions = [state.funct];
              urls = [];
              stack = null;
              member = {};
              membersOnly = null;
              inblock = false;
              lookahead = [];

              if (!isString(s) && !Array.isArray(s)) {
                errorAt("E004", 0);
                return false;
              }

              api = {
                get isJSON() {
                  return state.jsonMode;
                },

                getOption: function (name) {
                  return state.option[name] || null;
                },

                getCache: function (name) {
                  return state.cache[name];
                },

                setCache: function (name, value) {
                  state.cache[name] = value;
                },

                warn: function (code, data) {
                  warningAt.apply(null, [code, data.line, data.char].concat(data.data));
                },

                on: function (names, listener) {
                  names.split(" ").forEach(function (name) {
                    emitter.on(name, listener);
                  }.bind(this));
                }
              };

              emitter.removeAllListeners();
              (extraModules || []).forEach(function (func) {
                func(api);
              });

              state.tokens.prev = state.tokens.curr = state.tokens.next = state.syntax["(begin)"];

              if (o && o.ignoreDelimiters) {

                if (!Array.isArray(o.ignoreDelimiters)) {
                  o.ignoreDelimiters = [o.ignoreDelimiters];
                }

                o.ignoreDelimiters.forEach(function (delimiterPair) {
                  if (!delimiterPair.start || !delimiterPair.end) return;

                  reIgnoreStr = escapeRegex(delimiterPair.start) + "[\\s\\S]*?" + escapeRegex(delimiterPair.end);

                  reIgnore = new RegExp(reIgnoreStr, "ig");

                  s = s.replace(reIgnore, function (match) {
                    return match.replace(/./g, " ");
                  });
                });
              }

              lex = new Lexer(s);

              lex.on("warning", function (ev) {
                warningAt.apply(null, [ev.code, ev.line, ev.character].concat(ev.data));
              });

              lex.on("error", function (ev) {
                errorAt.apply(null, [ev.code, ev.line, ev.character].concat(ev.data));
              });

              lex.on("fatal", function (ev) {
                quit("E041", ev.line, ev.from);
              });

              lex.on("Identifier", function (ev) {
                emitter.emit("Identifier", ev);
              });

              lex.on("String", function (ev) {
                emitter.emit("String", ev);
              });

              lex.on("Number", function (ev) {
                emitter.emit("Number", ev);
              });

              lex.start();
              for (var name in o) {
                if (_.has(o, name)) {
                  checkOption(name, state.tokens.curr);
                }
              }

              assume();
              combine(predefined, g || {});
              comma.first = true;

              try {
                advance();
                switch (state.tokens.next.id) {
                  case "{":
                  case "[":
                    destructuringAssignOrJsonValue();
                    break;
                  default:
                    directives();

                    if (state.directive["use strict"]) {
                      if (state.option.strict !== "global") {
                        warning("W097", state.tokens.prev);
                      }
                    }

                    statements();
                }

                if (state.tokens.next.id !== "(end)") {
                  quit("E041", state.tokens.curr.line);
                }

                state.funct["(scope)"].unstack();
              } catch (err) {
                if (err && err.name === "JSHintError") {
                  var nt = state.tokens.next || {};
                  JSHINT.errors.push({
                    scope: "(main)",
                    raw: err.raw,
                    code: err.code,
                    reason: err.message,
                    line: err.line || nt.line,
                    character: err.character || nt.from
                  }, null);
                } else {
                  throw err;
                }
              }

              if (JSHINT.scope === "(main)") {
                o = o || {};

                for (i = 0; i < JSHINT.internals.length; i += 1) {
                  k = JSHINT.internals[i];
                  o.scope = k.elem;
                  itself(k.value, o, g);
                }
              }

              return JSHINT.errors.length === 0;
            };
            itself.addModule = function (func) {
              extraModules.push(func);
            };

            itself.addModule(style.register);
            itself.data = function () {
              var data = {
                functions: [],
                options: state.option
              };

              var fu, f, i, j, n, globals;

              if (itself.errors.length) {
                data.errors = itself.errors;
              }

              if (state.jsonMode) {
                data.json = true;
              }

              var impliedGlobals = state.funct["(scope)"].getImpliedGlobals();
              if (impliedGlobals.length > 0) {
                data.implieds = impliedGlobals;
              }

              if (urls.length > 0) {
                data.urls = urls;
              }

              globals = state.funct["(scope)"].getUsedOrDefinedGlobals();
              if (globals.length > 0) {
                data.globals = globals;
              }

              for (i = 1; i < functions.length; i += 1) {
                f = functions[i];
                fu = {};

                for (j = 0; j < functionicity.length; j += 1) {
                  fu[functionicity[j]] = [];
                }

                for (j = 0; j < functionicity.length; j += 1) {
                  if (fu[functionicity[j]].length === 0) {
                    delete fu[functionicity[j]];
                  }
                }

                fu.name = f["(name)"];
                fu.param = f["(params)"];
                fu.line = f["(line)"];
                fu.character = f["(character)"];
                fu.last = f["(last)"];
                fu.lastcharacter = f["(lastcharacter)"];

                fu.metrics = {
                  complexity: f["(metrics)"].ComplexityCount,
                  parameters: f["(metrics)"].arity,
                  statements: f["(metrics)"].statementCount
                };

                data.functions.push(fu);
              }

              var unuseds = state.funct["(scope)"].getUnuseds();
              if (unuseds.length > 0) {
                data.unused = unuseds;
              }

              for (n in member) {
                if (typeof member[n] === "number") {
                  data.member = member;
                  break;
                }
              }

              return data;
            };

            itself.jshint = itself;

            return itself;
          }();
          if (typeof exports === "object" && exports) {
            exports.JSHINT = JSHINT;
          }
        }, { "../lodash": "/node_modules/jshint/lodash.js", "./lex.js": "/node_modules/jshint/src/lex.js", "./messages.js": "/node_modules/jshint/src/messages.js", "./options.js": "/node_modules/jshint/src/options.js", "./reg.js": "/node_modules/jshint/src/reg.js", "./scope-manager.js": "/node_modules/jshint/src/scope-manager.js", "./state.js": "/node_modules/jshint/src/state.js", "./style.js": "/node_modules/jshint/src/style.js", "./vars.js": "/node_modules/jshint/src/vars.js", "events": "/node_modules/browserify/node_modules/events/events.js" }], "/node_modules/jshint/src/lex.js": [function (_dereq_, module, exports) {

          "use strict";

          var _ = _dereq_("../lodash");
          var events = _dereq_("events");
          var reg = _dereq_("./reg.js");
          var state = _dereq_("./state.js").state;

          var unicodeData = _dereq_("../data/ascii-identifier-data.js");
          var asciiIdentifierStartTable = unicodeData.asciiIdentifierStartTable;
          var asciiIdentifierPartTable = unicodeData.asciiIdentifierPartTable;

          var Token = {
            Identifier: 1,
            Punctuator: 2,
            NumericLiteral: 3,
            StringLiteral: 4,
            Comment: 5,
            Keyword: 6,
            NullLiteral: 7,
            BooleanLiteral: 8,
            RegExp: 9,
            TemplateHead: 10,
            TemplateMiddle: 11,
            TemplateTail: 12,
            NoSubstTemplate: 13
          };

          var Context = {
            Block: 1,
            Template: 2
          };

          function asyncTrigger() {
            var _checks = [];

            return {
              push: function (fn) {
                _checks.push(fn);
              },

              check: function () {
                for (var check = 0; check < _checks.length; ++check) {
                  _checks[check]();
                }

                _checks.splice(0, _checks.length);
              }
            };
          }
          function Lexer(source) {
            var lines = source;

            if (typeof lines === "string") {
              lines = lines.replace(/\r\n/g, "\n").replace(/\r/g, "\n").split("\n");
            }

            if (lines[0] && lines[0].substr(0, 2) === "#!") {
              if (lines[0].indexOf("node") !== -1) {
                state.option.node = true;
              }
              lines[0] = "";
            }

            this.emitter = new events.EventEmitter();
            this.source = source;
            this.setLines(lines);
            this.prereg = true;

            this.line = 0;
            this.char = 1;
            this.from = 1;
            this.input = "";
            this.inComment = false;
            this.context = [];
            this.templateStarts = [];

            for (var i = 0; i < state.option.indent; i += 1) {
              state.tab += " ";
            }
            this.ignoreLinterErrors = false;
          }

          Lexer.prototype = {
            _lines: [],

            inContext: function (ctxType) {
              return this.context.length > 0 && this.context[this.context.length - 1].type === ctxType;
            },

            pushContext: function (ctxType) {
              this.context.push({ type: ctxType });
            },

            popContext: function () {
              return this.context.pop();
            },

            isContext: function (context) {
              return this.context.length > 0 && this.context[this.context.length - 1] === context;
            },

            currentContext: function () {
              return this.context.length > 0 && this.context[this.context.length - 1];
            },

            getLines: function () {
              this._lines = state.lines;
              return this._lines;
            },

            setLines: function (val) {
              this._lines = val;
              state.lines = this._lines;
            },
            peek: function (i) {
              return this.input.charAt(i || 0);
            },
            skip: function (i) {
              i = i || 1;
              this.char += i;
              this.input = this.input.slice(i);
            },
            on: function (names, listener) {
              names.split(" ").forEach(function (name) {
                this.emitter.on(name, listener);
              }.bind(this));
            },
            trigger: function () {
              this.emitter.emit.apply(this.emitter, Array.prototype.slice.call(arguments));
            },
            triggerAsync: function (type, args, checks, fn) {
              checks.push(function () {
                if (fn()) {
                  this.trigger(type, args);
                }
              }.bind(this));
            },
            scanPunctuator: function () {
              var ch1 = this.peek();
              var ch2, ch3, ch4;

              switch (ch1) {
                case ".":
                  if (/^[0-9]$/.test(this.peek(1))) {
                    return null;
                  }
                  if (this.peek(1) === "." && this.peek(2) === ".") {
                    return {
                      type: Token.Punctuator,
                      value: "..."
                    };
                  }
                case "(":
                case ")":
                case ";":
                case ",":
                case "[":
                case "]":
                case ":":
                case "~":
                case "?":
                  return {
                    type: Token.Punctuator,
                    value: ch1
                  };
                case "{":
                  this.pushContext(Context.Block);
                  return {
                    type: Token.Punctuator,
                    value: ch1
                  };
                case "}":
                  if (this.inContext(Context.Block)) {
                    this.popContext();
                  }
                  return {
                    type: Token.Punctuator,
                    value: ch1
                  };
                case "#":
                  return {
                    type: Token.Punctuator,
                    value: ch1
                  };
                case "":
                  return null;
              }

              ch2 = this.peek(1);
              ch3 = this.peek(2);
              ch4 = this.peek(3);

              if (ch1 === ">" && ch2 === ">" && ch3 === ">" && ch4 === "=") {
                return {
                  type: Token.Punctuator,
                  value: ">>>="
                };
              }

              if (ch1 === "=" && ch2 === "=" && ch3 === "=") {
                return {
                  type: Token.Punctuator,
                  value: "==="
                };
              }

              if (ch1 === "!" && ch2 === "=" && ch3 === "=") {
                return {
                  type: Token.Punctuator,
                  value: "!=="
                };
              }

              if (ch1 === ">" && ch2 === ">" && ch3 === ">") {
                return {
                  type: Token.Punctuator,
                  value: ">>>"
                };
              }

              if (ch1 === "<" && ch2 === "<" && ch3 === "=") {
                return {
                  type: Token.Punctuator,
                  value: "<<="
                };
              }

              if (ch1 === ">" && ch2 === ">" && ch3 === "=") {
                return {
                  type: Token.Punctuator,
                  value: ">>="
                };
              }
              if (ch1 === "=" && ch2 === ">") {
                return {
                  type: Token.Punctuator,
                  value: ch1 + ch2
                };
              }
              if (ch1 === ch2 && "+-<>&|".indexOf(ch1) >= 0) {
                return {
                  type: Token.Punctuator,
                  value: ch1 + ch2
                };
              }

              if ("<>=!+-*%&|^".indexOf(ch1) >= 0) {
                if (ch2 === "=") {
                  return {
                    type: Token.Punctuator,
                    value: ch1 + ch2
                  };
                }

                return {
                  type: Token.Punctuator,
                  value: ch1
                };
              }

              if (ch1 === "/") {
                if (ch2 === "=") {
                  return {
                    type: Token.Punctuator,
                    value: "/="
                  };
                }

                return {
                  type: Token.Punctuator,
                  value: "/"
                };
              }

              return null;
            },
            scanComments: function () {
              var ch1 = this.peek();
              var ch2 = this.peek(1);
              var rest = this.input.substr(2);
              var startLine = this.line;
              var startChar = this.char;
              var self = this;

              function commentToken(label, body, opt) {
                var special = ["jshint", "jslint", "members", "member", "globals", "global", "exported"];
                var isSpecial = false;
                var value = label + body;
                var commentType = "plain";
                opt = opt || {};

                if (opt.isMultiline) {
                  value += "*/";
                }

                body = body.replace(/\n/g, " ");

                if (label === "/*" && reg.fallsThrough.test(body)) {
                  isSpecial = true;
                  commentType = "falls through";
                }

                special.forEach(function (str) {
                  if (isSpecial) {
                    return;
                  }
                  if (label === "//" && str !== "jshint") {
                    return;
                  }

                  if (body.charAt(str.length) === " " && body.substr(0, str.length) === str) {
                    isSpecial = true;
                    label = label + str;
                    body = body.substr(str.length);
                  }

                  if (!isSpecial && body.charAt(0) === " " && body.charAt(str.length + 1) === " " && body.substr(1, str.length) === str) {
                    isSpecial = true;
                    label = label + " " + str;
                    body = body.substr(str.length + 1);
                  }

                  if (!isSpecial) {
                    return;
                  }

                  switch (str) {
                    case "member":
                      commentType = "members";
                      break;
                    case "global":
                      commentType = "globals";
                      break;
                    default:
                      var options = body.split(":").map(function (v) {
                        return v.replace(/^\s+/, "").replace(/\s+$/, "");
                      });

                      if (options.length === 2) {
                        switch (options[0]) {
                          case "ignore":
                            switch (options[1]) {
                              case "start":
                                self.ignoringLinterErrors = true;
                                isSpecial = false;
                                break;
                              case "end":
                                self.ignoringLinterErrors = false;
                                isSpecial = false;
                                break;
                            }
                        }
                      }

                      commentType = str;
                  }
                });

                return {
                  type: Token.Comment,
                  commentType: commentType,
                  value: value,
                  body: body,
                  isSpecial: isSpecial,
                  isMultiline: opt.isMultiline || false,
                  isMalformed: opt.isMalformed || false
                };
              }
              if (ch1 === "*" && ch2 === "/") {
                this.trigger("error", {
                  code: "E018",
                  line: startLine,
                  character: startChar
                });

                this.skip(2);
                return null;
              }
              if (ch1 !== "/" || ch2 !== "*" && ch2 !== "/") {
                return null;
              }
              if (ch2 === "/") {
                this.skip(this.input.length); // Skip to the EOL.
                return commentToken("//", rest);
              }

              var body = "";
              if (ch2 === "*") {
                this.inComment = true;
                this.skip(2);

                while (this.peek() !== "*" || this.peek(1) !== "/") {
                  if (this.peek() === "") {
                    // End of Line
                    body += "\n";
                    if (!this.nextLine()) {
                      this.trigger("error", {
                        code: "E017",
                        line: startLine,
                        character: startChar
                      });

                      this.inComment = false;
                      return commentToken("/*", body, {
                        isMultiline: true,
                        isMalformed: true
                      });
                    }
                  } else {
                    body += this.peek();
                    this.skip();
                  }
                }

                this.skip(2);
                this.inComment = false;
                return commentToken("/*", body, { isMultiline: true });
              }
            },
            scanKeyword: function () {
              var result = /^[a-zA-Z_$][a-zA-Z0-9_$]*/.exec(this.input);
              var keywords = ["if", "in", "do", "var", "for", "new", "try", "let", "this", "else", "case", "void", "with", "enum", "while", "break", "catch", "throw", "const", "yield", "class", "super", "return", "typeof", "delete", "switch", "export", "import", "default", "finally", "extends", "function", "continue", "debugger", "instanceof"];

              if (result && keywords.indexOf(result[0]) >= 0) {
                return {
                  type: Token.Keyword,
                  value: result[0]
                };
              }

              return null;
            },
            scanIdentifier: function () {
              var id = "";
              var index = 0;
              var type, char;

              function isNonAsciiIdentifierStart(code) {
                return code > 256;
              }

              function isNonAsciiIdentifierPart(code) {
                return code > 256;
              }

              function isHexDigit(str) {
                return (/^[0-9a-fA-F]$/.test(str)
                );
              }

              var readUnicodeEscapeSequence = function () {
                index += 1;

                if (this.peek(index) !== "u") {
                  return null;
                }

                var ch1 = this.peek(index + 1);
                var ch2 = this.peek(index + 2);
                var ch3 = this.peek(index + 3);
                var ch4 = this.peek(index + 4);
                var code;

                if (isHexDigit(ch1) && isHexDigit(ch2) && isHexDigit(ch3) && isHexDigit(ch4)) {
                  code = parseInt(ch1 + ch2 + ch3 + ch4, 16);

                  if (asciiIdentifierPartTable[code] || isNonAsciiIdentifierPart(code)) {
                    index += 5;
                    return "\\u" + ch1 + ch2 + ch3 + ch4;
                  }

                  return null;
                }

                return null;
              }.bind(this);

              var getIdentifierStart = function () {
                var chr = this.peek(index);
                var code = chr.charCodeAt(0);

                if (code === 92) {
                  return readUnicodeEscapeSequence();
                }

                if (code < 128) {
                  if (asciiIdentifierStartTable[code]) {
                    index += 1;
                    return chr;
                  }

                  return null;
                }

                if (isNonAsciiIdentifierStart(code)) {
                  index += 1;
                  return chr;
                }

                return null;
              }.bind(this);

              var getIdentifierPart = function () {
                var chr = this.peek(index);
                var code = chr.charCodeAt(0);

                if (code === 92) {
                  return readUnicodeEscapeSequence();
                }

                if (code < 128) {
                  if (asciiIdentifierPartTable[code]) {
                    index += 1;
                    return chr;
                  }

                  return null;
                }

                if (isNonAsciiIdentifierPart(code)) {
                  index += 1;
                  return chr;
                }

                return null;
              }.bind(this);

              function removeEscapeSequences(id) {
                return id.replace(/\\u([0-9a-fA-F]{4})/g, function (m0, codepoint) {
                  return String.fromCharCode(parseInt(codepoint, 16));
                });
              }

              char = getIdentifierStart();
              if (char === null) {
                return null;
              }

              id = char;
              for (;;) {
                char = getIdentifierPart();

                if (char === null) {
                  break;
                }

                id += char;
              }

              switch (id) {
                case "true":
                case "false":
                  type = Token.BooleanLiteral;
                  break;
                case "null":
                  type = Token.NullLiteral;
                  break;
                default:
                  type = Token.Identifier;
              }

              return {
                type: type,
                value: removeEscapeSequences(id),
                text: id,
                tokenLength: id.length
              };
            },
            scanNumericLiteral: function () {
              var index = 0;
              var value = "";
              var length = this.input.length;
              var char = this.peek(index);
              var bad;
              var isAllowedDigit = isDecimalDigit;
              var base = 10;
              var isLegacy = false;

              function isDecimalDigit(str) {
                return (/^[0-9]$/.test(str)
                );
              }

              function isOctalDigit(str) {
                return (/^[0-7]$/.test(str)
                );
              }

              function isBinaryDigit(str) {
                return (/^[01]$/.test(str)
                );
              }

              function isHexDigit(str) {
                return (/^[0-9a-fA-F]$/.test(str)
                );
              }

              function isIdentifierStart(ch) {
                return ch === "$" || ch === "_" || ch === "\\" || ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z";
              }

              if (char !== "." && !isDecimalDigit(char)) {
                return null;
              }

              if (char !== ".") {
                value = this.peek(index);
                index += 1;
                char = this.peek(index);

                if (value === "0") {
                  if (char === "x" || char === "X") {
                    isAllowedDigit = isHexDigit;
                    base = 16;

                    index += 1;
                    value += char;
                  }
                  if (char === "o" || char === "O") {
                    isAllowedDigit = isOctalDigit;
                    base = 8;

                    if (!state.inES6(true)) {
                      this.trigger("warning", {
                        code: "W119",
                        line: this.line,
                        character: this.char,
                        data: ["Octal integer literal", "6"]
                      });
                    }

                    index += 1;
                    value += char;
                  }
                  if (char === "b" || char === "B") {
                    isAllowedDigit = isBinaryDigit;
                    base = 2;

                    if (!state.inES6(true)) {
                      this.trigger("warning", {
                        code: "W119",
                        line: this.line,
                        character: this.char,
                        data: ["Binary integer literal", "6"]
                      });
                    }

                    index += 1;
                    value += char;
                  }
                  if (isOctalDigit(char)) {
                    isAllowedDigit = isOctalDigit;
                    base = 8;
                    isLegacy = true;
                    bad = false;

                    index += 1;
                    value += char;
                  }

                  if (!isOctalDigit(char) && isDecimalDigit(char)) {
                    index += 1;
                    value += char;
                  }
                }

                while (index < length) {
                  char = this.peek(index);

                  if (isLegacy && isDecimalDigit(char)) {
                    bad = true;
                  } else if (!isAllowedDigit(char)) {
                    break;
                  }
                  value += char;
                  index += 1;
                }

                if (isAllowedDigit !== isDecimalDigit) {
                  if (!isLegacy && value.length <= 2) {
                    // 0x
                    return {
                      type: Token.NumericLiteral,
                      value: value,
                      isMalformed: true
                    };
                  }

                  if (index < length) {
                    char = this.peek(index);
                    if (isIdentifierStart(char)) {
                      return null;
                    }
                  }

                  return {
                    type: Token.NumericLiteral,
                    value: value,
                    base: base,
                    isLegacy: isLegacy,
                    isMalformed: false
                  };
                }
              }

              if (char === ".") {
                value += char;
                index += 1;

                while (index < length) {
                  char = this.peek(index);
                  if (!isDecimalDigit(char)) {
                    break;
                  }
                  value += char;
                  index += 1;
                }
              }

              if (char === "e" || char === "E") {
                value += char;
                index += 1;
                char = this.peek(index);

                if (char === "+" || char === "-") {
                  value += this.peek(index);
                  index += 1;
                }

                char = this.peek(index);
                if (isDecimalDigit(char)) {
                  value += char;
                  index += 1;

                  while (index < length) {
                    char = this.peek(index);
                    if (!isDecimalDigit(char)) {
                      break;
                    }
                    value += char;
                    index += 1;
                  }
                } else {
                  return null;
                }
              }

              if (index < length) {
                char = this.peek(index);
                if (isIdentifierStart(char)) {
                  return null;
                }
              }

              return {
                type: Token.NumericLiteral,
                value: value,
                base: base,
                isMalformed: !isFinite(value)
              };
            },
            scanEscapeSequence: function (checks) {
              var allowNewLine = false;
              var jump = 1;
              this.skip();
              var char = this.peek();

              switch (char) {
                case "'":
                  this.triggerAsync("warning", {
                    code: "W114",
                    line: this.line,
                    character: this.char,
                    data: ["\\'"]
                  }, checks, function () {
                    return state.jsonMode;
                  });
                  break;
                case "b":
                  char = "\\b";
                  break;
                case "f":
                  char = "\\f";
                  break;
                case "n":
                  char = "\\n";
                  break;
                case "r":
                  char = "\\r";
                  break;
                case "t":
                  char = "\\t";
                  break;
                case "0":
                  char = "\\0";
                  var n = parseInt(this.peek(1), 10);
                  this.triggerAsync("warning", {
                    code: "W115",
                    line: this.line,
                    character: this.char
                  }, checks, function () {
                    return n >= 0 && n <= 7 && state.isStrict();
                  });
                  break;
                case "u":
                  var hexCode = this.input.substr(1, 4);
                  var code = parseInt(hexCode, 16);
                  if (isNaN(code)) {
                    this.trigger("warning", {
                      code: "W052",
                      line: this.line,
                      character: this.char,
                      data: ["u" + hexCode]
                    });
                  }
                  char = String.fromCharCode(code);
                  jump = 5;
                  break;
                case "v":
                  this.triggerAsync("warning", {
                    code: "W114",
                    line: this.line,
                    character: this.char,
                    data: ["\\v"]
                  }, checks, function () {
                    return state.jsonMode;
                  });

                  char = "\v";
                  break;
                case "x":
                  var x = parseInt(this.input.substr(1, 2), 16);

                  this.triggerAsync("warning", {
                    code: "W114",
                    line: this.line,
                    character: this.char,
                    data: ["\\x-"]
                  }, checks, function () {
                    return state.jsonMode;
                  });

                  char = String.fromCharCode(x);
                  jump = 3;
                  break;
                case "\\":
                  char = "\\\\";
                  break;
                case "\"":
                  char = "\\\"";
                  break;
                case "/":
                  break;
                case "":
                  allowNewLine = true;
                  char = "";
                  break;
              }

              return { char: char, jump: jump, allowNewLine: allowNewLine };
            },
            scanTemplateLiteral: function (checks) {
              var tokenType;
              var value = "";
              var ch;
              var startLine = this.line;
              var startChar = this.char;
              var depth = this.templateStarts.length;

              if (!state.inES6(true)) {
                return null;
              } else if (this.peek() === "`") {
                tokenType = Token.TemplateHead;
                this.templateStarts.push({ line: this.line, char: this.char });
                depth = this.templateStarts.length;
                this.skip(1);
                this.pushContext(Context.Template);
              } else if (this.inContext(Context.Template) && this.peek() === "}") {
                tokenType = Token.TemplateMiddle;
              } else {
                return null;
              }

              while (this.peek() !== "`") {
                while ((ch = this.peek()) === "") {
                  value += "\n";
                  if (!this.nextLine()) {
                    var startPos = this.templateStarts.pop();
                    this.trigger("error", {
                      code: "E052",
                      line: startPos.line,
                      character: startPos.char
                    });
                    return {
                      type: tokenType,
                      value: value,
                      startLine: startLine,
                      startChar: startChar,
                      isUnclosed: true,
                      depth: depth,
                      context: this.popContext()
                    };
                  }
                }

                if (ch === '$' && this.peek(1) === '{') {
                  value += '${';
                  this.skip(2);
                  return {
                    type: tokenType,
                    value: value,
                    startLine: startLine,
                    startChar: startChar,
                    isUnclosed: false,
                    depth: depth,
                    context: this.currentContext()
                  };
                } else if (ch === '\\') {
                  var escape = this.scanEscapeSequence(checks);
                  value += escape.char;
                  this.skip(escape.jump);
                } else if (ch !== '`') {
                  value += ch;
                  this.skip(1);
                }
              }
              tokenType = tokenType === Token.TemplateHead ? Token.NoSubstTemplate : Token.TemplateTail;
              this.skip(1);
              this.templateStarts.pop();

              return {
                type: tokenType,
                value: value,
                startLine: startLine,
                startChar: startChar,
                isUnclosed: false,
                depth: depth,
                context: this.popContext()
              };
            },
            scanStringLiteral: function (checks) {
              var quote = this.peek();
              if (quote !== "\"" && quote !== "'") {
                return null;
              }
              this.triggerAsync("warning", {
                code: "W108",
                line: this.line,
                character: this.char // +1?
              }, checks, function () {
                return state.jsonMode && quote !== "\"";
              });

              var value = "";
              var startLine = this.line;
              var startChar = this.char;
              var allowNewLine = false;

              this.skip();

              while (this.peek() !== quote) {
                if (this.peek() === "") {
                  // End Of Line

                  if (!allowNewLine) {
                    this.trigger("warning", {
                      code: "W112",
                      line: this.line,
                      character: this.char
                    });
                  } else {
                    allowNewLine = false;

                    this.triggerAsync("warning", {
                      code: "W043",
                      line: this.line,
                      character: this.char
                    }, checks, function () {
                      return !state.option.multistr;
                    });

                    this.triggerAsync("warning", {
                      code: "W042",
                      line: this.line,
                      character: this.char
                    }, checks, function () {
                      return state.jsonMode && state.option.multistr;
                    });
                  }

                  if (!this.nextLine()) {
                    this.trigger("error", {
                      code: "E029",
                      line: startLine,
                      character: startChar
                    });

                    return {
                      type: Token.StringLiteral,
                      value: value,
                      startLine: startLine,
                      startChar: startChar,
                      isUnclosed: true,
                      quote: quote
                    };
                  }
                } else {
                  // Any character other than End Of Line

                  allowNewLine = false;
                  var char = this.peek();
                  var jump = 1; // A length of a jump, after we're done

                  if (char < " ") {
                    this.trigger("warning", {
                      code: "W113",
                      line: this.line,
                      character: this.char,
                      data: ["<non-printable>"]
                    });
                  }
                  if (char === "\\") {
                    var parsed = this.scanEscapeSequence(checks);
                    char = parsed.char;
                    jump = parsed.jump;
                    allowNewLine = parsed.allowNewLine;
                  }

                  value += char;
                  this.skip(jump);
                }
              }

              this.skip();
              return {
                type: Token.StringLiteral,
                value: value,
                startLine: startLine,
                startChar: startChar,
                isUnclosed: false,
                quote: quote
              };
            },
            scanRegExp: function () {
              var index = 0;
              var length = this.input.length;
              var char = this.peek();
              var value = char;
              var body = "";
              var flags = [];
              var malformed = false;
              var isCharSet = false;
              var terminated;

              var scanUnexpectedChars = function () {
                if (char < " ") {
                  malformed = true;
                  this.trigger("warning", {
                    code: "W048",
                    line: this.line,
                    character: this.char
                  });
                }
                if (char === "<") {
                  malformed = true;
                  this.trigger("warning", {
                    code: "W049",
                    line: this.line,
                    character: this.char,
                    data: [char]
                  });
                }
              }.bind(this);
              if (!this.prereg || char !== "/") {
                return null;
              }

              index += 1;
              terminated = false;

              while (index < length) {
                char = this.peek(index);
                value += char;
                body += char;

                if (isCharSet) {
                  if (char === "]") {
                    if (this.peek(index - 1) !== "\\" || this.peek(index - 2) === "\\") {
                      isCharSet = false;
                    }
                  }

                  if (char === "\\") {
                    index += 1;
                    char = this.peek(index);
                    body += char;
                    value += char;

                    scanUnexpectedChars();
                  }

                  index += 1;
                  continue;
                }

                if (char === "\\") {
                  index += 1;
                  char = this.peek(index);
                  body += char;
                  value += char;

                  scanUnexpectedChars();

                  if (char === "/") {
                    index += 1;
                    continue;
                  }

                  if (char === "[") {
                    index += 1;
                    continue;
                  }
                }

                if (char === "[") {
                  isCharSet = true;
                  index += 1;
                  continue;
                }

                if (char === "/") {
                  body = body.substr(0, body.length - 1);
                  terminated = true;
                  index += 1;
                  break;
                }

                index += 1;
              }

              if (!terminated) {
                this.trigger("error", {
                  code: "E015",
                  line: this.line,
                  character: this.from
                });

                return void this.trigger("fatal", {
                  line: this.line,
                  from: this.from
                });
              }

              while (index < length) {
                char = this.peek(index);
                if (!/[gim]/.test(char)) {
                  break;
                }
                flags.push(char);
                value += char;
                index += 1;
              }

              try {
                new RegExp(body, flags.join(""));
              } catch (err) {
                malformed = true;
                this.trigger("error", {
                  code: "E016",
                  line: this.line,
                  character: this.char,
                  data: [err.message] // Platform dependent!
                });
              }

              return {
                type: Token.RegExp,
                value: value,
                flags: flags,
                isMalformed: malformed
              };
            },
            scanNonBreakingSpaces: function () {
              return state.option.nonbsp ? this.input.search(/(\u00A0)/) : -1;
            },
            scanUnsafeChars: function () {
              return this.input.search(reg.unsafeChars);
            },
            next: function (checks) {
              this.from = this.char;
              var start;
              if (/\s/.test(this.peek())) {
                start = this.char;

                while (/\s/.test(this.peek())) {
                  this.from += 1;
                  this.skip();
                }
              }

              var match = this.scanComments() || this.scanStringLiteral(checks) || this.scanTemplateLiteral(checks);

              if (match) {
                return match;
              }

              match = this.scanRegExp() || this.scanPunctuator() || this.scanKeyword() || this.scanIdentifier() || this.scanNumericLiteral();

              if (match) {
                this.skip(match.tokenLength || match.value.length);
                return match;
              }

              return null;
            },
            nextLine: function () {
              var char;

              if (this.line >= this.getLines().length) {
                return false;
              }

              this.input = this.getLines()[this.line];
              this.line += 1;
              this.char = 1;
              this.from = 1;

              var inputTrimmed = this.input.trim();

              var startsWith = function () {
                return _.some(arguments, function (prefix) {
                  return inputTrimmed.indexOf(prefix) === 0;
                });
              };

              var endsWith = function () {
                return _.some(arguments, function (suffix) {
                  return inputTrimmed.indexOf(suffix, inputTrimmed.length - suffix.length) !== -1;
                });
              };
              if (this.ignoringLinterErrors === true) {
                if (!startsWith("/*", "//") && !(this.inComment && endsWith("*/"))) {
                  this.input = "";
                }
              }

              char = this.scanNonBreakingSpaces();
              if (char >= 0) {
                this.trigger("warning", { code: "W125", line: this.line, character: char + 1 });
              }

              this.input = this.input.replace(/\t/g, state.tab);
              char = this.scanUnsafeChars();

              if (char >= 0) {
                this.trigger("warning", { code: "W100", line: this.line, character: char });
              }

              if (!this.ignoringLinterErrors && state.option.maxlen && state.option.maxlen < this.input.length) {
                var inComment = this.inComment || startsWith.call(inputTrimmed, "//") || startsWith.call(inputTrimmed, "/*");

                var shouldTriggerError = !inComment || !reg.maxlenException.test(inputTrimmed);

                if (shouldTriggerError) {
                  this.trigger("warning", { code: "W101", line: this.line, character: this.input.length });
                }
              }

              return true;
            },
            start: function () {
              this.nextLine();
            },
            token: function () {
              var checks = asyncTrigger();
              var token;

              function isReserved(token, isProperty) {
                if (!token.reserved) {
                  return false;
                }
                var meta = token.meta;

                if (meta && meta.isFutureReservedWord && state.inES5()) {
                  if (!meta.es5) {
                    return false;
                  }
                  if (meta.strictOnly) {
                    if (!state.option.strict && !state.isStrict()) {
                      return false;
                    }
                  }

                  if (isProperty) {
                    return false;
                  }
                }

                return true;
              }
              var create = function (type, value, isProperty, token) {
                var obj;

                if (type !== "(endline)" && type !== "(end)") {
                  this.prereg = false;
                }

                if (type === "(punctuator)") {
                  switch (value) {
                    case ".":
                    case ")":
                    case "~":
                    case "#":
                    case "]":
                    case "++":
                    case "--":
                      this.prereg = false;
                      break;
                    default:
                      this.prereg = true;
                  }

                  obj = Object.create(state.syntax[value] || state.syntax["(error)"]);
                }

                if (type === "(identifier)") {
                  if (value === "return" || value === "case" || value === "typeof") {
                    this.prereg = true;
                  }

                  if (_.has(state.syntax, value)) {
                    obj = Object.create(state.syntax[value] || state.syntax["(error)"]);
                    if (!isReserved(obj, isProperty && type === "(identifier)")) {
                      obj = null;
                    }
                  }
                }

                if (!obj) {
                  obj = Object.create(state.syntax[type]);
                }

                obj.identifier = type === "(identifier)";
                obj.type = obj.type || type;
                obj.value = value;
                obj.line = this.line;
                obj.character = this.char;
                obj.from = this.from;
                if (obj.identifier && token) obj.raw_text = token.text || token.value;
                if (token && token.startLine && token.startLine !== this.line) {
                  obj.startLine = token.startLine;
                }
                if (token && token.context) {
                  obj.context = token.context;
                }
                if (token && token.depth) {
                  obj.depth = token.depth;
                }
                if (token && token.isUnclosed) {
                  obj.isUnclosed = token.isUnclosed;
                }

                if (isProperty && obj.identifier) {
                  obj.isProperty = isProperty;
                }

                obj.check = checks.check;

                return obj;
              }.bind(this);

              for (;;) {
                if (!this.input.length) {
                  if (this.nextLine()) {
                    return create("(endline)", "");
                  }

                  if (this.exhausted) {
                    return null;
                  }

                  this.exhausted = true;
                  return create("(end)", "");
                }

                token = this.next(checks);

                if (!token) {
                  if (this.input.length) {
                    this.trigger("error", {
                      code: "E024",
                      line: this.line,
                      character: this.char,
                      data: [this.peek()]
                    });

                    this.input = "";
                  }

                  continue;
                }

                switch (token.type) {
                  case Token.StringLiteral:
                    this.triggerAsync("String", {
                      line: this.line,
                      char: this.char,
                      from: this.from,
                      startLine: token.startLine,
                      startChar: token.startChar,
                      value: token.value,
                      quote: token.quote
                    }, checks, function () {
                      return true;
                    });

                    return create("(string)", token.value, null, token);

                  case Token.TemplateHead:
                    this.trigger("TemplateHead", {
                      line: this.line,
                      char: this.char,
                      from: this.from,
                      startLine: token.startLine,
                      startChar: token.startChar,
                      value: token.value
                    });
                    return create("(template)", token.value, null, token);

                  case Token.TemplateMiddle:
                    this.trigger("TemplateMiddle", {
                      line: this.line,
                      char: this.char,
                      from: this.from,
                      startLine: token.startLine,
                      startChar: token.startChar,
                      value: token.value
                    });
                    return create("(template middle)", token.value, null, token);

                  case Token.TemplateTail:
                    this.trigger("TemplateTail", {
                      line: this.line,
                      char: this.char,
                      from: this.from,
                      startLine: token.startLine,
                      startChar: token.startChar,
                      value: token.value
                    });
                    return create("(template tail)", token.value, null, token);

                  case Token.NoSubstTemplate:
                    this.trigger("NoSubstTemplate", {
                      line: this.line,
                      char: this.char,
                      from: this.from,
                      startLine: token.startLine,
                      startChar: token.startChar,
                      value: token.value
                    });
                    return create("(no subst template)", token.value, null, token);

                  case Token.Identifier:
                    this.triggerAsync("Identifier", {
                      line: this.line,
                      char: this.char,
                      from: this.form,
                      name: token.value,
                      raw_name: token.text,
                      isProperty: state.tokens.curr.id === "."
                    }, checks, function () {
                      return true;
                    });
                  case Token.Keyword:
                  case Token.NullLiteral:
                  case Token.BooleanLiteral:
                    return create("(identifier)", token.value, state.tokens.curr.id === ".", token);

                  case Token.NumericLiteral:
                    if (token.isMalformed) {
                      this.trigger("warning", {
                        code: "W045",
                        line: this.line,
                        character: this.char,
                        data: [token.value]
                      });
                    }

                    this.triggerAsync("warning", {
                      code: "W114",
                      line: this.line,
                      character: this.char,
                      data: ["0x-"]
                    }, checks, function () {
                      return token.base === 16 && state.jsonMode;
                    });

                    this.triggerAsync("warning", {
                      code: "W115",
                      line: this.line,
                      character: this.char
                    }, checks, function () {
                      return state.isStrict() && token.base === 8 && token.isLegacy;
                    });

                    this.trigger("Number", {
                      line: this.line,
                      char: this.char,
                      from: this.from,
                      value: token.value,
                      base: token.base,
                      isMalformed: token.malformed
                    });

                    return create("(number)", token.value);

                  case Token.RegExp:
                    return create("(regexp)", token.value);

                  case Token.Comment:
                    state.tokens.curr.comment = true;

                    if (token.isSpecial) {
                      return {
                        id: '(comment)',
                        value: token.value,
                        body: token.body,
                        type: token.commentType,
                        isSpecial: token.isSpecial,
                        line: this.line,
                        character: this.char,
                        from: this.from
                      };
                    }

                    break;

                  case "":
                    break;

                  default:
                    return create("(punctuator)", token.value);
                }
              }
            }
          };

          exports.Lexer = Lexer;
          exports.Context = Context;
        }, { "../data/ascii-identifier-data.js": "/node_modules/jshint/data/ascii-identifier-data.js", "../lodash": "/node_modules/jshint/lodash.js", "./reg.js": "/node_modules/jshint/src/reg.js", "./state.js": "/node_modules/jshint/src/state.js", "events": "/node_modules/browserify/node_modules/events/events.js" }], "/node_modules/jshint/src/messages.js": [function (_dereq_, module, exports) {
          "use strict";

          var _ = _dereq_("../lodash");

          var errors = {
            E001: "Bad option: '{a}'.",
            E002: "Bad option value.",
            E003: "Expected a JSON value.",
            E004: "Input is neither a string nor an array of strings.",
            E005: "Input is empty.",
            E006: "Unexpected early end of program.",
            E007: "Missing \"use strict\" statement.",
            E008: "Strict violation.",
            E009: "Option 'validthis' can't be used in a global scope.",
            E010: "'with' is not allowed in strict mode.",
            E011: "'{a}' has already been declared.",
            E012: "const '{a}' is initialized to 'undefined'.",
            E013: "Attempting to override '{a}' which is a constant.",
            E014: "A regular expression literal can be confused with '/='.",
            E015: "Unclosed regular expression.",
            E016: "Invalid regular expression.",
            E017: "Unclosed comment.",
            E018: "Unbegun comment.",
            E019: "Unmatched '{a}'.",
            E020: "Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'.",
            E021: "Expected '{a}' and instead saw '{b}'.",
            E022: "Line breaking error '{a}'.",
            E023: "Missing '{a}'.",
            E024: "Unexpected '{a}'.",
            E025: "Missing ':' on a case clause.",
            E026: "Missing '}' to match '{' from line {a}.",
            E027: "Missing ']' to match '[' from line {a}.",
            E028: "Illegal comma.",
            E029: "Unclosed string.",
            E030: "Expected an identifier and instead saw '{a}'.",
            E031: "Bad assignment.", // FIXME: Rephrase
            E032: "Expected a small integer or 'false' and instead saw '{a}'.",
            E033: "Expected an operator and instead saw '{a}'.",
            E034: "get/set are ES5 features.",
            E035: "Missing property name.",
            E036: "Expected to see a statement and instead saw a block.",
            E037: null,
            E038: null,
            E039: "Function declarations are not invocable. Wrap the whole function invocation in parens.",
            E040: "Each value should have its own case label.",
            E041: "Unrecoverable syntax error.",
            E042: "Stopping.",
            E043: "Too many errors.",
            E044: null,
            E045: "Invalid for each loop.",
            E046: "A yield statement shall be within a generator function (with syntax: `function*`)",
            E047: null,
            E048: "{a} declaration not directly within block.",
            E049: "A {a} cannot be named '{b}'.",
            E050: "Mozilla requires the yield expression to be parenthesized here.",
            E051: null,
            E052: "Unclosed template literal.",
            E053: "Export declaration must be in global scope.",
            E054: "Class properties must be methods. Expected '(' but instead saw '{a}'.",
            E055: "The '{a}' option cannot be set after any executable code.",
            E056: "'{a}' was used before it was declared, which is illegal for '{b}' variables.",
            E057: "Invalid meta property: '{a}.{b}'.",
            E058: "Missing semicolon."
          };

          var warnings = {
            W001: "'hasOwnProperty' is a really bad name.",
            W002: "Value of '{a}' may be overwritten in IE 8 and earlier.",
            W003: "'{a}' was used before it was defined.",
            W004: "'{a}' is already defined.",
            W005: "A dot following a number can be confused with a decimal point.",
            W006: "Confusing minuses.",
            W007: "Confusing plusses.",
            W008: "A leading decimal point can be confused with a dot: '{a}'.",
            W009: "The array literal notation [] is preferable.",
            W010: "The object literal notation {} is preferable.",
            W011: null,
            W012: null,
            W013: null,
            W014: "Bad line breaking before '{a}'.",
            W015: null,
            W016: "Unexpected use of '{a}'.",
            W017: "Bad operand.",
            W018: "Confusing use of '{a}'.",
            W019: "Use the isNaN function to compare with NaN.",
            W020: "Read only.",
            W021: "Reassignment of '{a}', which is is a {b}. " + "Use 'var' or 'let' to declare bindings that may change.",
            W022: "Do not assign to the exception parameter.",
            W023: "Expected an identifier in an assignment and instead saw a function invocation.",
            W024: "Expected an identifier and instead saw '{a}' (a reserved word).",
            W025: "Missing name in function declaration.",
            W026: "Inner functions should be listed at the top of the outer function.",
            W027: "Unreachable '{a}' after '{b}'.",
            W028: "Label '{a}' on {b} statement.",
            W030: "Expected an assignment or function call and instead saw an expression.",
            W031: "Do not use 'new' for side effects.",
            W032: "Unnecessary semicolon.",
            W033: "Missing semicolon.",
            W034: "Unnecessary directive \"{a}\".",
            W035: "Empty block.",
            W036: "Unexpected /*member '{a}'.",
            W037: "'{a}' is a statement label.",
            W038: "'{a}' used out of scope.",
            W039: "'{a}' is not allowed.",
            W040: "Possible strict violation.",
            W041: "Use '{a}' to compare with '{b}'.",
            W042: "Avoid EOL escaping.",
            W043: "Bad escaping of EOL. Use option multistr if needed.",
            W044: "Bad or unnecessary escaping.", /* TODO(caitp): remove W044 */
            W045: "Bad number '{a}'.",
            W046: "Don't use extra leading zeros '{a}'.",
            W047: "A trailing decimal point can be confused with a dot: '{a}'.",
            W048: "Unexpected control character in regular expression.",
            W049: "Unexpected escaped character '{a}' in regular expression.",
            W050: "JavaScript URL.",
            W051: "Variables should not be deleted.",
            W052: "Unexpected '{a}'.",
            W053: "Do not use {a} as a constructor.",
            W054: "The Function constructor is a form of eval.",
            W055: "A constructor name should start with an uppercase letter.",
            W056: "Bad constructor.",
            W057: "Weird construction. Is 'new' necessary?",
            W058: "Missing '()' invoking a constructor.",
            W059: "Avoid arguments.{a}.",
            W060: "document.write can be a form of eval.",
            W061: "eval can be harmful.",
            W062: "Wrap an immediate function invocation in parens " + "to assist the reader in understanding that the expression " + "is the result of a function, and not the function itself.",
            W063: "Math is not a function.",
            W064: "Missing 'new' prefix when invoking a constructor.",
            W065: "Missing radix parameter.",
            W066: "Implied eval. Consider passing a function instead of a string.",
            W067: "Bad invocation.",
            W068: "Wrapping non-IIFE function literals in parens is unnecessary.",
            W069: "['{a}'] is better written in dot notation.",
            W070: "Extra comma. (it breaks older versions of IE)",
            W071: "This function has too many statements. ({a})",
            W072: "This function has too many parameters. ({a})",
            W073: "Blocks are nested too deeply. ({a})",
            W074: "This function's cyclomatic complexity is too high. ({a})",
            W075: "Duplicate {a} '{b}'.",
            W076: "Unexpected parameter '{a}' in get {b} function.",
            W077: "Expected a single parameter in set {a} function.",
            W078: "Setter is defined without getter.",
            W079: "Redefinition of '{a}'.",
            W080: "It's not necessary to initialize '{a}' to 'undefined'.",
            W081: null,
            W082: "Function declarations should not be placed in blocks. " + "Use a function expression or move the statement to the top of " + "the outer function.",
            W083: "Don't make functions within a loop.",
            W084: "Assignment in conditional expression",
            W085: "Don't use 'with'.",
            W086: "Expected a 'break' statement before '{a}'.",
            W087: "Forgotten 'debugger' statement?",
            W088: "Creating global 'for' variable. Should be 'for (var {a} ...'.",
            W089: "The body of a for in should be wrapped in an if statement to filter " + "unwanted properties from the prototype.",
            W090: "'{a}' is not a statement label.",
            W091: null,
            W093: "Did you mean to return a conditional instead of an assignment?",
            W094: "Unexpected comma.",
            W095: "Expected a string and instead saw {a}.",
            W096: "The '{a}' key may produce unexpected results.",
            W097: "Use the function form of \"use strict\".",
            W098: "'{a}' is defined but never used.",
            W099: null,
            W100: "This character may get silently deleted by one or more browsers.",
            W101: "Line is too long.",
            W102: null,
            W103: "The '{a}' property is deprecated.",
            W104: "'{a}' is available in ES{b} (use 'esversion: {b}') or Mozilla JS extensions (use moz).",
            W105: "Unexpected {a} in '{b}'.",
            W106: "Identifier '{a}' is not in camel case.",
            W107: "Script URL.",
            W108: "Strings must use doublequote.",
            W109: "Strings must use singlequote.",
            W110: "Mixed double and single quotes.",
            W112: "Unclosed string.",
            W113: "Control character in string: {a}.",
            W114: "Avoid {a}.",
            W115: "Octal literals are not allowed in strict mode.",
            W116: "Expected '{a}' and instead saw '{b}'.",
            W117: "'{a}' is not defined.",
            W118: "'{a}' is only available in Mozilla JavaScript extensions (use moz option).",
            W119: "'{a}' is only available in ES{b} (use 'esversion: {b}').",
            W120: "You might be leaking a variable ({a}) here.",
            W121: "Extending prototype of native object: '{a}'.",
            W122: "Invalid typeof value '{a}'",
            W123: "'{a}' is already defined in outer scope.",
            W124: "A generator function shall contain a yield statement.",
            W125: "This line contains non-breaking spaces: http://jshint.com/doc/options/#nonbsp",
            W126: "Unnecessary grouping operator.",
            W127: "Unexpected use of a comma operator.",
            W128: "Empty array elements require elision=true.",
            W129: "'{a}' is defined in a future version of JavaScript. Use a " + "different variable name to avoid migration issues.",
            W130: "Invalid element after rest element.",
            W131: "Invalid parameter after rest parameter.",
            W132: "`var` declarations are forbidden. Use `let` or `const` instead.",
            W133: "Invalid for-{a} loop left-hand-side: {b}.",
            W134: "The '{a}' option is only available when linting ECMAScript {b} code.",
            W135: "{a} may not be supported by non-browser environments.",
            W136: "'{a}' must be in function scope.",
            W137: "Empty destructuring.",
            W138: "Regular parameters should not come after default parameters."
          };

          var info = {
            I001: "Comma warnings can be turned off with 'laxcomma'.",
            I002: null,
            I003: "ES5 option is now set per default"
          };

          exports.errors = {};
          exports.warnings = {};
          exports.info = {};

          _.each(errors, function (desc, code) {
            exports.errors[code] = { code: code, desc: desc };
          });

          _.each(warnings, function (desc, code) {
            exports.warnings[code] = { code: code, desc: desc };
          });

          _.each(info, function (desc, code) {
            exports.info[code] = { code: code, desc: desc };
          });
        }, { "../lodash": "/node_modules/jshint/lodash.js" }], "/node_modules/jshint/src/name-stack.js": [function (_dereq_, module, exports) {
          "use strict";

          function NameStack() {
            this._stack = [];
          }

          Object.defineProperty(NameStack.prototype, "length", {
            get: function () {
              return this._stack.length;
            }
          });
          NameStack.prototype.push = function () {
            this._stack.push(null);
          };
          NameStack.prototype.pop = function () {
            this._stack.pop();
          };
          NameStack.prototype.set = function (token) {
            this._stack[this.length - 1] = token;
          };
          NameStack.prototype.infer = function () {
            var nameToken = this._stack[this.length - 1];
            var prefix = "";
            var type;
            if (!nameToken || nameToken.type === "class") {
              nameToken = this._stack[this.length - 2];
            }

            if (!nameToken) {
              return "(empty)";
            }

            type = nameToken.type;

            if (type !== "(string)" && type !== "(number)" && type !== "(identifier)" && type !== "default") {
              return "(expression)";
            }

            if (nameToken.accessorType) {
              prefix = nameToken.accessorType + " ";
            }

            return prefix + nameToken.value;
          };

          module.exports = NameStack;
        }, {}], "/node_modules/jshint/src/options.js": [function (_dereq_, module, exports) {
          "use strict";

          exports.bool = {
            enforcing: {
              bitwise: true,
              freeze: true,
              camelcase: true,
              curly: true,
              eqeqeq: true,
              futurehostile: true,
              notypeof: true,
              es3: true,
              es5: true,
              forin: true,
              funcscope: true,
              immed: true,
              iterator: true,
              newcap: true,
              noarg: true,
              nocomma: true,
              noempty: true,
              nonbsp: true,
              nonew: true,
              undef: true,
              singleGroups: false,
              varstmt: false,
              enforceall: false
            },
            relaxing: {
              asi: true,
              multistr: true,
              debug: true,
              boss: true,
              evil: true,
              globalstrict: true,
              plusplus: true,
              proto: true,
              scripturl: true,
              sub: true,
              supernew: true,
              laxbreak: true,
              laxcomma: true,
              validthis: true,
              withstmt: true,
              moz: true,
              noyield: true,
              eqnull: true,
              lastsemic: true,
              loopfunc: true,
              expr: true,
              esnext: true,
              elision: true
            },
            environments: {
              mootools: true,
              couch: true,
              jasmine: true,
              jquery: true,
              node: true,
              qunit: true,
              rhino: true,
              shelljs: true,
              prototypejs: true,
              yui: true,
              mocha: true,
              module: true,
              wsh: true,
              worker: true,
              nonstandard: true,
              browser: true,
              browserify: true,
              devel: true,
              dojo: true,
              typed: true,
              phantom: true
            },
            obsolete: {
              onecase: true, // if one case switch statements should be allowed
              regexp: true, // if the . should not be allowed in regexp literals
              regexdash: true // if unescaped first/last dash (-) inside brackets
            }
          };
          exports.val = {
            maxlen: false,
            indent: false,
            maxerr: false,
            predef: false,
            globals: false,
            quotmark: false,

            scope: false,
            maxstatements: false,
            maxdepth: false,
            maxparams: false,
            maxcomplexity: false,
            shadow: false,
            strict: true,
            unused: true,
            latedef: false,

            ignore: false, // start/end ignoring lines of code, bypassing the lexer

            ignoreDelimiters: false, // array of start/end delimiters used to ignore
            esversion: 5
          };
          exports.inverted = {
            bitwise: true,
            forin: true,
            newcap: true,
            plusplus: true,
            regexp: true,
            undef: true,
            eqeqeq: true,
            strict: true
          };

          exports.validNames = Object.keys(exports.val).concat(Object.keys(exports.bool.relaxing)).concat(Object.keys(exports.bool.enforcing)).concat(Object.keys(exports.bool.obsolete)).concat(Object.keys(exports.bool.environments));
          exports.renamed = {
            eqeq: "eqeqeq",
            windows: "wsh",
            sloppy: "strict"
          };

          exports.removed = {
            nomen: true,
            onevar: true,
            passfail: true,
            white: true,
            gcl: true,
            smarttabs: true,
            trailing: true
          };
          exports.noenforceall = {
            varstmt: true,
            strict: true
          };
        }, {}], "/node_modules/jshint/src/reg.js": [function (_dereq_, module, exports) {

          "use strict";

          exports.unsafeString = /@cc|<\/?|script|\]\s*\]|<\s*!|&lt/i;
          exports.unsafeChars = /[\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/;
          exports.needEsc = /[\u0000-\u001f&<"\/\\\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/;

          exports.needEscGlobal = /[\u0000-\u001f&<"\/\\\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
          exports.starSlash = /\*\//;
          exports.identifier = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/;
          exports.javascriptURL = /^(?:javascript|jscript|ecmascript|vbscript|livescript)\s*:/i;
          exports.fallsThrough = /^\s*falls?\sthrough\s*$/;
          exports.maxlenException = /^(?:(?:\/\/|\/\*|\*) ?)?[^ ]+$/;
        }, {}], "/node_modules/jshint/src/scope-manager.js": [function (_dereq_, module, exports) {
          "use strict";

          var _ = _dereq_("../lodash");
          var events = _dereq_("events");
          var marker = {};
          var scopeManager = function (state, predefined, exported, declared) {

            var _current;
            var _scopeStack = [];

            function _newScope(type) {
              _current = {
                "(labels)": Object.create(null),
                "(usages)": Object.create(null),
                "(breakLabels)": Object.create(null),
                "(parent)": _current,
                "(type)": type,
                "(params)": type === "functionparams" || type === "catchparams" ? [] : null
              };
              _scopeStack.push(_current);
            }

            _newScope("global");
            _current["(predefined)"] = predefined;

            var _currentFunctBody = _current; // this is the block after the params = function

            var usedPredefinedAndGlobals = Object.create(null);
            var impliedGlobals = Object.create(null);
            var unuseds = [];
            var emitter = new events.EventEmitter();

            function warning(code, token) {
              emitter.emit("warning", {
                code: code,
                token: token,
                data: _.slice(arguments, 2)
              });
            }

            function error(code, token) {
              emitter.emit("warning", {
                code: code,
                token: token,
                data: _.slice(arguments, 2)
              });
            }

            function _setupUsages(labelName) {
              if (!_current["(usages)"][labelName]) {
                _current["(usages)"][labelName] = {
                  "(modified)": [],
                  "(reassigned)": [],
                  "(tokens)": []
                };
              }
            }

            var _getUnusedOption = function (unused_opt) {
              if (unused_opt === undefined) {
                unused_opt = state.option.unused;
              }

              if (unused_opt === true) {
                unused_opt = "last-param";
              }

              return unused_opt;
            };

            var _warnUnused = function (name, tkn, type, unused_opt) {
              var line = tkn.line;
              var chr = tkn.from;
              var raw_name = tkn.raw_text || name;

              unused_opt = _getUnusedOption(unused_opt);

              var warnable_types = {
                "vars": ["var"],
                "last-param": ["var", "param"],
                "strict": ["var", "param", "last-param"]
              };

              if (unused_opt) {
                if (warnable_types[unused_opt] && warnable_types[unused_opt].indexOf(type) !== -1) {
                  warning("W098", { line: line, from: chr }, raw_name);
                }
              }
              if (unused_opt || type === "var") {
                unuseds.push({
                  name: name,
                  line: line,
                  character: chr
                });
              }
            };
            function _checkForUnused() {
              if (_current["(type)"] === "functionparams") {
                _checkParams();
                return;
              }
              var curentLabels = _current["(labels)"];
              for (var labelName in curentLabels) {
                if (curentLabels[labelName]) {
                  if (curentLabels[labelName]["(type)"] !== "exception" && curentLabels[labelName]["(unused)"]) {
                    _warnUnused(labelName, curentLabels[labelName]["(token)"], "var");
                  }
                }
              }
            }
            function _checkParams() {
              var params = _current["(params)"];

              if (!params) {
                return;
              }

              var param = params.pop();
              var unused_opt;

              while (param) {
                var label = _current["(labels)"][param];

                unused_opt = _getUnusedOption(state.funct["(unusedOption)"]);
                if (param === "undefined") return;

                if (label["(unused)"]) {
                  _warnUnused(param, label["(token)"], "param", state.funct["(unusedOption)"]);
                } else if (unused_opt === "last-param") {
                  return;
                }

                param = params.pop();
              }
            }
            function _getLabel(labelName) {
              for (var i = _scopeStack.length - 1; i >= 0; --i) {
                var scopeLabels = _scopeStack[i]["(labels)"];
                if (scopeLabels[labelName]) {
                  return scopeLabels;
                }
              }
            }

            function usedSoFarInCurrentFunction(labelName) {
              for (var i = _scopeStack.length - 1; i >= 0; i--) {
                var current = _scopeStack[i];
                if (current["(usages)"][labelName]) {
                  return current["(usages)"][labelName];
                }
                if (current === _currentFunctBody) {
                  break;
                }
              }
              return false;
            }

            function _checkOuterShadow(labelName, token) {
              if (state.option.shadow !== "outer") {
                return;
              }

              var isGlobal = _currentFunctBody["(type)"] === "global",
                  isNewFunction = _current["(type)"] === "functionparams";

              var outsideCurrentFunction = !isGlobal;
              for (var i = 0; i < _scopeStack.length; i++) {
                var stackItem = _scopeStack[i];

                if (!isNewFunction && _scopeStack[i + 1] === _currentFunctBody) {
                  outsideCurrentFunction = false;
                }
                if (outsideCurrentFunction && stackItem["(labels)"][labelName]) {
                  warning("W123", token, labelName);
                }
                if (stackItem["(breakLabels)"][labelName]) {
                  warning("W123", token, labelName);
                }
              }
            }

            function _latedefWarning(type, labelName, token) {
              if (state.option.latedef) {
                if (state.option.latedef === true && type === "function" || type !== "function") {
                  warning("W003", token, labelName);
                }
              }
            }

            var scopeManagerInst = {

              on: function (names, listener) {
                names.split(" ").forEach(function (name) {
                  emitter.on(name, listener);
                });
              },

              isPredefined: function (labelName) {
                return !this.has(labelName) && _.has(_scopeStack[0]["(predefined)"], labelName);
              },
              stack: function (type) {
                var previousScope = _current;
                _newScope(type);

                if (!type && previousScope["(type)"] === "functionparams") {

                  _current["(isFuncBody)"] = true;
                  _current["(context)"] = _currentFunctBody;
                  _currentFunctBody = _current;
                }
              },

              unstack: function () {
                var subScope = _scopeStack.length > 1 ? _scopeStack[_scopeStack.length - 2] : null;
                var isUnstackingFunctionBody = _current === _currentFunctBody,
                    isUnstackingFunctionParams = _current["(type)"] === "functionparams",
                    isUnstackingFunctionOuter = _current["(type)"] === "functionouter";

                var i, j;
                var currentUsages = _current["(usages)"];
                var currentLabels = _current["(labels)"];
                var usedLabelNameList = Object.keys(currentUsages);

                if (currentUsages.__proto__ && usedLabelNameList.indexOf("__proto__") === -1) {
                  usedLabelNameList.push("__proto__");
                }

                for (i = 0; i < usedLabelNameList.length; i++) {
                  var usedLabelName = usedLabelNameList[i];

                  var usage = currentUsages[usedLabelName];
                  var usedLabel = currentLabels[usedLabelName];
                  if (usedLabel) {
                    var usedLabelType = usedLabel["(type)"];

                    if (usedLabel["(useOutsideOfScope)"] && !state.option.funcscope) {
                      var usedTokens = usage["(tokens)"];
                      if (usedTokens) {
                        for (j = 0; j < usedTokens.length; j++) {
                          if (usedLabel["(function)"] === usedTokens[j]["(function)"]) {
                            error("W038", usedTokens[j], usedLabelName);
                          }
                        }
                      }
                    }
                    _current["(labels)"][usedLabelName]["(unused)"] = false;
                    if (usedLabelType === "const" && usage["(modified)"]) {
                      for (j = 0; j < usage["(modified)"].length; j++) {
                        error("E013", usage["(modified)"][j], usedLabelName);
                      }
                    }
                    if ((usedLabelType === "function" || usedLabelType === "class") && usage["(reassigned)"]) {
                      for (j = 0; j < usage["(reassigned)"].length; j++) {
                        error("W021", usage["(reassigned)"][j], usedLabelName, usedLabelType);
                      }
                    }
                    continue;
                  }

                  if (isUnstackingFunctionOuter) {
                    state.funct["(isCapturing)"] = true;
                  }

                  if (subScope) {
                    if (!subScope["(usages)"][usedLabelName]) {
                      subScope["(usages)"][usedLabelName] = usage;
                      if (isUnstackingFunctionBody) {
                        subScope["(usages)"][usedLabelName]["(onlyUsedSubFunction)"] = true;
                      }
                    } else {
                      var subScopeUsage = subScope["(usages)"][usedLabelName];
                      subScopeUsage["(modified)"] = subScopeUsage["(modified)"].concat(usage["(modified)"]);
                      subScopeUsage["(tokens)"] = subScopeUsage["(tokens)"].concat(usage["(tokens)"]);
                      subScopeUsage["(reassigned)"] = subScopeUsage["(reassigned)"].concat(usage["(reassigned)"]);
                      subScopeUsage["(onlyUsedSubFunction)"] = false;
                    }
                  } else {
                    if (typeof _current["(predefined)"][usedLabelName] === "boolean") {
                      delete declared[usedLabelName];
                      usedPredefinedAndGlobals[usedLabelName] = marker;
                      if (_current["(predefined)"][usedLabelName] === false && usage["(reassigned)"]) {
                        for (j = 0; j < usage["(reassigned)"].length; j++) {
                          warning("W020", usage["(reassigned)"][j]);
                        }
                      }
                    } else {
                      if (usage["(tokens)"]) {
                        for (j = 0; j < usage["(tokens)"].length; j++) {
                          var undefinedToken = usage["(tokens)"][j];
                          if (!undefinedToken.forgiveUndef) {
                            if (state.option.undef && !undefinedToken.ignoreUndef) {
                              warning("W117", undefinedToken, usedLabelName);
                            }
                            if (impliedGlobals[usedLabelName]) {
                              impliedGlobals[usedLabelName].line.push(undefinedToken.line);
                            } else {
                              impliedGlobals[usedLabelName] = {
                                name: usedLabelName,
                                line: [undefinedToken.line]
                              };
                            }
                          }
                        }
                      }
                    }
                  }
                }
                if (!subScope) {
                  Object.keys(declared).forEach(function (labelNotUsed) {
                    _warnUnused(labelNotUsed, declared[labelNotUsed], "var");
                  });
                }
                if (subScope && !isUnstackingFunctionBody && !isUnstackingFunctionParams && !isUnstackingFunctionOuter) {
                  var labelNames = Object.keys(currentLabels);
                  for (i = 0; i < labelNames.length; i++) {

                    var defLabelName = labelNames[i];
                    if (!currentLabels[defLabelName]["(blockscoped)"] && currentLabels[defLabelName]["(type)"] !== "exception" && !this.funct.has(defLabelName, { excludeCurrent: true })) {
                      subScope["(labels)"][defLabelName] = currentLabels[defLabelName];
                      if (_currentFunctBody["(type)"] !== "global") {
                        subScope["(labels)"][defLabelName]["(useOutsideOfScope)"] = true;
                      }
                      delete currentLabels[defLabelName];
                    }
                  }
                }

                _checkForUnused();

                _scopeStack.pop();
                if (isUnstackingFunctionBody) {
                  _currentFunctBody = _scopeStack[_.findLastIndex(_scopeStack, function (scope) {
                    return scope["(isFuncBody)"] || scope["(type)"] === "global";
                  })];
                }

                _current = subScope;
              },
              addParam: function (labelName, token, type) {
                type = type || "param";

                if (type === "exception") {
                  var previouslyDefinedLabelType = this.funct.labeltype(labelName);
                  if (previouslyDefinedLabelType && previouslyDefinedLabelType !== "exception") {
                    if (!state.option.node) {
                      warning("W002", state.tokens.next, labelName);
                    }
                  }
                }
                if (_.has(_current["(labels)"], labelName)) {
                  _current["(labels)"][labelName].duplicated = true;
                } else {
                  _checkOuterShadow(labelName, token, type);

                  _current["(labels)"][labelName] = {
                    "(type)": type,
                    "(token)": token,
                    "(unused)": true };

                  _current["(params)"].push(labelName);
                }

                if (_.has(_current["(usages)"], labelName)) {
                  var usage = _current["(usages)"][labelName];
                  if (usage["(onlyUsedSubFunction)"]) {
                    _latedefWarning(type, labelName, token);
                  } else {
                    warning("E056", token, labelName, type);
                  }
                }
              },

              validateParams: function () {
                if (_currentFunctBody["(type)"] === "global") {
                  return;
                }

                var isStrict = state.isStrict();
                var currentFunctParamScope = _currentFunctBody["(parent)"];

                if (!currentFunctParamScope["(params)"]) {
                  return;
                }

                currentFunctParamScope["(params)"].forEach(function (labelName) {
                  var label = currentFunctParamScope["(labels)"][labelName];

                  if (label && label.duplicated) {
                    if (isStrict) {
                      warning("E011", label["(token)"], labelName);
                    } else if (state.option.shadow !== true) {
                      warning("W004", label["(token)"], labelName);
                    }
                  }
                });
              },

              getUsedOrDefinedGlobals: function () {
                var list = Object.keys(usedPredefinedAndGlobals);
                if (usedPredefinedAndGlobals.__proto__ === marker && list.indexOf("__proto__") === -1) {
                  list.push("__proto__");
                }

                return list;
              },
              getImpliedGlobals: function () {
                var values = _.values(impliedGlobals);
                var hasProto = false;
                if (impliedGlobals.__proto__) {
                  hasProto = values.some(function (value) {
                    return value.name === "__proto__";
                  });

                  if (!hasProto) {
                    values.push(impliedGlobals.__proto__);
                  }
                }

                return values;
              },
              getUnuseds: function () {
                return unuseds;
              },

              has: function (labelName) {
                return Boolean(_getLabel(labelName));
              },

              labeltype: function (labelName) {
                var scopeLabels = _getLabel(labelName);
                if (scopeLabels) {
                  return scopeLabels[labelName]["(type)"];
                }
                return null;
              },
              addExported: function (labelName) {
                var globalLabels = _scopeStack[0]["(labels)"];
                if (_.has(declared, labelName)) {
                  delete declared[labelName];
                } else if (_.has(globalLabels, labelName)) {
                  globalLabels[labelName]["(unused)"] = false;
                } else {
                  for (var i = 1; i < _scopeStack.length; i++) {
                    var scope = _scopeStack[i];
                    if (!scope["(type)"]) {
                      if (_.has(scope["(labels)"], labelName) && !scope["(labels)"][labelName]["(blockscoped)"]) {
                        scope["(labels)"][labelName]["(unused)"] = false;
                        return;
                      }
                    } else {
                      break;
                    }
                  }
                  exported[labelName] = true;
                }
              },
              setExported: function (labelName, token) {
                this.block.use(labelName, token);
              },
              addlabel: function (labelName, opts) {

                var type = opts.type;
                var token = opts.token;
                var isblockscoped = type === "let" || type === "const" || type === "class";
                var isexported = (isblockscoped ? _current : _currentFunctBody)["(type)"] === "global" && _.has(exported, labelName);
                _checkOuterShadow(labelName, token, type);
                if (isblockscoped) {

                  var declaredInCurrentScope = _current["(labels)"][labelName];
                  if (!declaredInCurrentScope && _current === _currentFunctBody && _current["(type)"] !== "global") {
                    declaredInCurrentScope = !!_currentFunctBody["(parent)"]["(labels)"][labelName];
                  }
                  if (!declaredInCurrentScope && _current["(usages)"][labelName]) {
                    var usage = _current["(usages)"][labelName];
                    if (usage["(onlyUsedSubFunction)"]) {
                      _latedefWarning(type, labelName, token);
                    } else {
                      warning("E056", token, labelName, type);
                    }
                  }
                  if (declaredInCurrentScope) {
                    warning("E011", token, labelName);
                  } else if (state.option.shadow === "outer") {
                    if (scopeManagerInst.funct.has(labelName)) {
                      warning("W004", token, labelName);
                    }
                  }

                  scopeManagerInst.block.add(labelName, type, token, !isexported);
                } else {

                  var declaredInCurrentFunctionScope = scopeManagerInst.funct.has(labelName);
                  if (!declaredInCurrentFunctionScope && usedSoFarInCurrentFunction(labelName)) {
                    _latedefWarning(type, labelName, token);
                  }
                  if (scopeManagerInst.funct.has(labelName, { onlyBlockscoped: true })) {
                    warning("E011", token, labelName);
                  } else if (state.option.shadow !== true) {
                    if (declaredInCurrentFunctionScope && labelName !== "__proto__") {
                      if (_currentFunctBody["(type)"] !== "global") {
                        warning("W004", token, labelName);
                      }
                    }
                  }

                  scopeManagerInst.funct.add(labelName, type, token, !isexported);

                  if (_currentFunctBody["(type)"] === "global") {
                    usedPredefinedAndGlobals[labelName] = marker;
                  }
                }
              },

              funct: {
                labeltype: function (labelName, options) {
                  var onlyBlockscoped = options && options.onlyBlockscoped;
                  var excludeParams = options && options.excludeParams;
                  var currentScopeIndex = _scopeStack.length - (options && options.excludeCurrent ? 2 : 1);
                  for (var i = currentScopeIndex; i >= 0; i--) {
                    var current = _scopeStack[i];
                    if (current["(labels)"][labelName] && (!onlyBlockscoped || current["(labels)"][labelName]["(blockscoped)"])) {
                      return current["(labels)"][labelName]["(type)"];
                    }
                    var scopeCheck = excludeParams ? _scopeStack[i - 1] : current;
                    if (scopeCheck && scopeCheck["(type)"] === "functionparams") {
                      return null;
                    }
                  }
                  return null;
                },
                hasBreakLabel: function (labelName) {
                  for (var i = _scopeStack.length - 1; i >= 0; i--) {
                    var current = _scopeStack[i];

                    if (current["(breakLabels)"][labelName]) {
                      return true;
                    }
                    if (current["(type)"] === "functionparams") {
                      return false;
                    }
                  }
                  return false;
                },
                has: function (labelName, options) {
                  return Boolean(this.labeltype(labelName, options));
                },
                add: function (labelName, type, tok, unused) {
                  _current["(labels)"][labelName] = {
                    "(type)": type,
                    "(token)": tok,
                    "(blockscoped)": false,
                    "(function)": _currentFunctBody,
                    "(unused)": unused };
                }
              },

              block: {
                isGlobal: function () {
                  return _current["(type)"] === "global";
                },

                use: function (labelName, token) {
                  var paramScope = _currentFunctBody["(parent)"];
                  if (paramScope && paramScope["(labels)"][labelName] && paramScope["(labels)"][labelName]["(type)"] === "param") {
                    if (!scopeManagerInst.funct.has(labelName, { excludeParams: true, onlyBlockscoped: true })) {
                      paramScope["(labels)"][labelName]["(unused)"] = false;
                    }
                  }

                  if (token && (state.ignored.W117 || state.option.undef === false)) {
                    token.ignoreUndef = true;
                  }

                  _setupUsages(labelName);

                  if (token) {
                    token["(function)"] = _currentFunctBody;
                    _current["(usages)"][labelName]["(tokens)"].push(token);
                  }
                },

                reassign: function (labelName, token) {

                  this.modify(labelName, token);

                  _current["(usages)"][labelName]["(reassigned)"].push(token);
                },

                modify: function (labelName, token) {

                  _setupUsages(labelName);

                  _current["(usages)"][labelName]["(modified)"].push(token);
                },
                add: function (labelName, type, tok, unused) {
                  _current["(labels)"][labelName] = {
                    "(type)": type,
                    "(token)": tok,
                    "(blockscoped)": true,
                    "(unused)": unused };
                },

                addBreakLabel: function (labelName, opts) {
                  var token = opts.token;
                  if (scopeManagerInst.funct.hasBreakLabel(labelName)) {
                    warning("E011", token, labelName);
                  } else if (state.option.shadow === "outer") {
                    if (scopeManagerInst.funct.has(labelName)) {
                      warning("W004", token, labelName);
                    } else {
                      _checkOuterShadow(labelName, token);
                    }
                  }
                  _current["(breakLabels)"][labelName] = token;
                }
              }
            };
            return scopeManagerInst;
          };

          module.exports = scopeManager;
        }, { "../lodash": "/node_modules/jshint/lodash.js", "events": "/node_modules/browserify/node_modules/events/events.js" }], "/node_modules/jshint/src/state.js": [function (_dereq_, module, exports) {
          "use strict";

          var NameStack = _dereq_("./name-stack.js");

          var state = {
            syntax: {},
            isStrict: function () {
              return this.directive["use strict"] || this.inClassBody || this.option.module || this.option.strict === "implied";
            },

            inMoz: function () {
              return this.option.moz;
            },
            inES6: function () {
              return this.option.moz || this.option.esversion >= 6;
            },
            inES5: function (strict) {
              if (strict) {
                return (!this.option.esversion || this.option.esversion === 5) && !this.option.moz;
              }
              return !this.option.esversion || this.option.esversion >= 5 || this.option.moz;
            },

            reset: function () {
              this.tokens = {
                prev: null,
                next: null,
                curr: null
              };

              this.option = {};
              this.funct = null;
              this.ignored = {};
              this.directive = {};
              this.jsonMode = false;
              this.jsonWarnings = [];
              this.lines = [];
              this.tab = "";
              this.cache = {}; // Node.JS doesn't have Map. Sniff.
              this.ignoredLines = {};
              this.forinifcheckneeded = false;
              this.nameStack = new NameStack();
              this.inClassBody = false;
            }
          };

          exports.state = state;
        }, { "./name-stack.js": "/node_modules/jshint/src/name-stack.js" }], "/node_modules/jshint/src/style.js": [function (_dereq_, module, exports) {
          "use strict";

          exports.register = function (linter) {

            linter.on("Identifier", function style_scanProto(data) {
              if (linter.getOption("proto")) {
                return;
              }

              if (data.name === "__proto__") {
                linter.warn("W103", {
                  line: data.line,
                  char: data.char,
                  data: [data.name, "6"]
                });
              }
            });

            linter.on("Identifier", function style_scanIterator(data) {
              if (linter.getOption("iterator")) {
                return;
              }

              if (data.name === "__iterator__") {
                linter.warn("W103", {
                  line: data.line,
                  char: data.char,
                  data: [data.name]
                });
              }
            });

            linter.on("Identifier", function style_scanCamelCase(data) {
              if (!linter.getOption("camelcase")) {
                return;
              }

              if (data.name.replace(/^_+|_+$/g, "").indexOf("_") > -1 && !data.name.match(/^[A-Z0-9_]*$/)) {
                linter.warn("W106", {
                  line: data.line,
                  char: data.from,
                  data: [data.name]
                });
              }
            });

            linter.on("String", function style_scanQuotes(data) {
              var quotmark = linter.getOption("quotmark");
              var code;

              if (!quotmark) {
                return;
              }

              if (quotmark === "single" && data.quote !== "'") {
                code = "W109";
              }

              if (quotmark === "double" && data.quote !== "\"") {
                code = "W108";
              }

              if (quotmark === true) {
                if (!linter.getCache("quotmark")) {
                  linter.setCache("quotmark", data.quote);
                }

                if (linter.getCache("quotmark") !== data.quote) {
                  code = "W110";
                }
              }

              if (code) {
                linter.warn(code, {
                  line: data.line,
                  char: data.char
                });
              }
            });

            linter.on("Number", function style_scanNumbers(data) {
              if (data.value.charAt(0) === ".") {
                linter.warn("W008", {
                  line: data.line,
                  char: data.char,
                  data: [data.value]
                });
              }

              if (data.value.substr(data.value.length - 1) === ".") {
                linter.warn("W047", {
                  line: data.line,
                  char: data.char,
                  data: [data.value]
                });
              }

              if (/^00+/.test(data.value)) {
                linter.warn("W046", {
                  line: data.line,
                  char: data.char,
                  data: [data.value]
                });
              }
            });

            linter.on("String", function style_scanJavaScriptURLs(data) {
              var re = /^(?:javascript|jscript|ecmascript|vbscript|livescript)\s*:/i;

              if (linter.getOption("scripturl")) {
                return;
              }

              if (re.test(data.value)) {
                linter.warn("W107", {
                  line: data.line,
                  char: data.char
                });
              }
            });
          };
        }, {}], "/node_modules/jshint/src/vars.js": [function (_dereq_, module, exports) {

          "use strict";

          exports.reservedVars = {
            arguments: false,
            NaN: false
          };

          exports.ecmaIdentifiers = {
            3: {
              Array: false,
              Boolean: false,
              Date: false,
              decodeURI: false,
              decodeURIComponent: false,
              encodeURI: false,
              encodeURIComponent: false,
              Error: false,
              "eval": false,
              EvalError: false,
              Function: false,
              hasOwnProperty: false,
              isFinite: false,
              isNaN: false,
              Math: false,
              Number: false,
              Object: false,
              parseInt: false,
              parseFloat: false,
              RangeError: false,
              ReferenceError: false,
              RegExp: false,
              String: false,
              SyntaxError: false,
              TypeError: false,
              URIError: false
            },
            5: {
              JSON: false
            },
            6: {
              Map: false,
              Promise: false,
              Proxy: false,
              Reflect: false,
              Set: false,
              Symbol: false,
              WeakMap: false,
              WeakSet: false
            }
          };

          exports.browser = {
            Audio: false,
            Blob: false,
            addEventListener: false,
            applicationCache: false,
            atob: false,
            blur: false,
            btoa: false,
            cancelAnimationFrame: false,
            CanvasGradient: false,
            CanvasPattern: false,
            CanvasRenderingContext2D: false,
            CSS: false,
            clearInterval: false,
            clearTimeout: false,
            close: false,
            closed: false,
            Comment: false,
            CustomEvent: false,
            DOMParser: false,
            defaultStatus: false,
            Document: false,
            document: false,
            DocumentFragment: false,
            Element: false,
            ElementTimeControl: false,
            Event: false,
            event: false,
            fetch: false,
            FileReader: false,
            FormData: false,
            focus: false,
            frames: false,
            getComputedStyle: false,
            HTMLElement: false,
            HTMLAnchorElement: false,
            HTMLBaseElement: false,
            HTMLBlockquoteElement: false,
            HTMLBodyElement: false,
            HTMLBRElement: false,
            HTMLButtonElement: false,
            HTMLCanvasElement: false,
            HTMLCollection: false,
            HTMLDirectoryElement: false,
            HTMLDivElement: false,
            HTMLDListElement: false,
            HTMLFieldSetElement: false,
            HTMLFontElement: false,
            HTMLFormElement: false,
            HTMLFrameElement: false,
            HTMLFrameSetElement: false,
            HTMLHeadElement: false,
            HTMLHeadingElement: false,
            HTMLHRElement: false,
            HTMLHtmlElement: false,
            HTMLIFrameElement: false,
            HTMLImageElement: false,
            HTMLInputElement: false,
            HTMLIsIndexElement: false,
            HTMLLabelElement: false,
            HTMLLayerElement: false,
            HTMLLegendElement: false,
            HTMLLIElement: false,
            HTMLLinkElement: false,
            HTMLMapElement: false,
            HTMLMenuElement: false,
            HTMLMetaElement: false,
            HTMLModElement: false,
            HTMLObjectElement: false,
            HTMLOListElement: false,
            HTMLOptGroupElement: false,
            HTMLOptionElement: false,
            HTMLParagraphElement: false,
            HTMLParamElement: false,
            HTMLPreElement: false,
            HTMLQuoteElement: false,
            HTMLScriptElement: false,
            HTMLSelectElement: false,
            HTMLStyleElement: false,
            HTMLTableCaptionElement: false,
            HTMLTableCellElement: false,
            HTMLTableColElement: false,
            HTMLTableElement: false,
            HTMLTableRowElement: false,
            HTMLTableSectionElement: false,
            HTMLTemplateElement: false,
            HTMLTextAreaElement: false,
            HTMLTitleElement: false,
            HTMLUListElement: false,
            HTMLVideoElement: false,
            history: false,
            Image: false,
            Intl: false,
            length: false,
            localStorage: false,
            location: false,
            matchMedia: false,
            MessageChannel: false,
            MessageEvent: false,
            MessagePort: false,
            MouseEvent: false,
            moveBy: false,
            moveTo: false,
            MutationObserver: false,
            name: false,
            Node: false,
            NodeFilter: false,
            NodeList: false,
            Notification: false,
            navigator: false,
            onbeforeunload: true,
            onblur: true,
            onerror: true,
            onfocus: true,
            onload: true,
            onresize: true,
            onunload: true,
            open: false,
            openDatabase: false,
            opener: false,
            Option: false,
            parent: false,
            performance: false,
            print: false,
            Range: false,
            requestAnimationFrame: false,
            removeEventListener: false,
            resizeBy: false,
            resizeTo: false,
            screen: false,
            scroll: false,
            scrollBy: false,
            scrollTo: false,
            sessionStorage: false,
            setInterval: false,
            setTimeout: false,
            SharedWorker: false,
            status: false,
            SVGAElement: false,
            SVGAltGlyphDefElement: false,
            SVGAltGlyphElement: false,
            SVGAltGlyphItemElement: false,
            SVGAngle: false,
            SVGAnimateColorElement: false,
            SVGAnimateElement: false,
            SVGAnimateMotionElement: false,
            SVGAnimateTransformElement: false,
            SVGAnimatedAngle: false,
            SVGAnimatedBoolean: false,
            SVGAnimatedEnumeration: false,
            SVGAnimatedInteger: false,
            SVGAnimatedLength: false,
            SVGAnimatedLengthList: false,
            SVGAnimatedNumber: false,
            SVGAnimatedNumberList: false,
            SVGAnimatedPathData: false,
            SVGAnimatedPoints: false,
            SVGAnimatedPreserveAspectRatio: false,
            SVGAnimatedRect: false,
            SVGAnimatedString: false,
            SVGAnimatedTransformList: false,
            SVGAnimationElement: false,
            SVGCSSRule: false,
            SVGCircleElement: false,
            SVGClipPathElement: false,
            SVGColor: false,
            SVGColorProfileElement: false,
            SVGColorProfileRule: false,
            SVGComponentTransferFunctionElement: false,
            SVGCursorElement: false,
            SVGDefsElement: false,
            SVGDescElement: false,
            SVGDocument: false,
            SVGElement: false,
            SVGElementInstance: false,
            SVGElementInstanceList: false,
            SVGEllipseElement: false,
            SVGExternalResourcesRequired: false,
            SVGFEBlendElement: false,
            SVGFEColorMatrixElement: false,
            SVGFEComponentTransferElement: false,
            SVGFECompositeElement: false,
            SVGFEConvolveMatrixElement: false,
            SVGFEDiffuseLightingElement: false,
            SVGFEDisplacementMapElement: false,
            SVGFEDistantLightElement: false,
            SVGFEFloodElement: false,
            SVGFEFuncAElement: false,
            SVGFEFuncBElement: false,
            SVGFEFuncGElement: false,
            SVGFEFuncRElement: false,
            SVGFEGaussianBlurElement: false,
            SVGFEImageElement: false,
            SVGFEMergeElement: false,
            SVGFEMergeNodeElement: false,
            SVGFEMorphologyElement: false,
            SVGFEOffsetElement: false,
            SVGFEPointLightElement: false,
            SVGFESpecularLightingElement: false,
            SVGFESpotLightElement: false,
            SVGFETileElement: false,
            SVGFETurbulenceElement: false,
            SVGFilterElement: false,
            SVGFilterPrimitiveStandardAttributes: false,
            SVGFitToViewBox: false,
            SVGFontElement: false,
            SVGFontFaceElement: false,
            SVGFontFaceFormatElement: false,
            SVGFontFaceNameElement: false,
            SVGFontFaceSrcElement: false,
            SVGFontFaceUriElement: false,
            SVGForeignObjectElement: false,
            SVGGElement: false,
            SVGGlyphElement: false,
            SVGGlyphRefElement: false,
            SVGGradientElement: false,
            SVGHKernElement: false,
            SVGICCColor: false,
            SVGImageElement: false,
            SVGLangSpace: false,
            SVGLength: false,
            SVGLengthList: false,
            SVGLineElement: false,
            SVGLinearGradientElement: false,
            SVGLocatable: false,
            SVGMPathElement: false,
            SVGMarkerElement: false,
            SVGMaskElement: false,
            SVGMatrix: false,
            SVGMetadataElement: false,
            SVGMissingGlyphElement: false,
            SVGNumber: false,
            SVGNumberList: false,
            SVGPaint: false,
            SVGPathElement: false,
            SVGPathSeg: false,
            SVGPathSegArcAbs: false,
            SVGPathSegArcRel: false,
            SVGPathSegClosePath: false,
            SVGPathSegCurvetoCubicAbs: false,
            SVGPathSegCurvetoCubicRel: false,
            SVGPathSegCurvetoCubicSmoothAbs: false,
            SVGPathSegCurvetoCubicSmoothRel: false,
            SVGPathSegCurvetoQuadraticAbs: false,
            SVGPathSegCurvetoQuadraticRel: false,
            SVGPathSegCurvetoQuadraticSmoothAbs: false,
            SVGPathSegCurvetoQuadraticSmoothRel: false,
            SVGPathSegLinetoAbs: false,
            SVGPathSegLinetoHorizontalAbs: false,
            SVGPathSegLinetoHorizontalRel: false,
            SVGPathSegLinetoRel: false,
            SVGPathSegLinetoVerticalAbs: false,
            SVGPathSegLinetoVerticalRel: false,
            SVGPathSegList: false,
            SVGPathSegMovetoAbs: false,
            SVGPathSegMovetoRel: false,
            SVGPatternElement: false,
            SVGPoint: false,
            SVGPointList: false,
            SVGPolygonElement: false,
            SVGPolylineElement: false,
            SVGPreserveAspectRatio: false,
            SVGRadialGradientElement: false,
            SVGRect: false,
            SVGRectElement: false,
            SVGRenderingIntent: false,
            SVGSVGElement: false,
            SVGScriptElement: false,
            SVGSetElement: false,
            SVGStopElement: false,
            SVGStringList: false,
            SVGStylable: false,
            SVGStyleElement: false,
            SVGSwitchElement: false,
            SVGSymbolElement: false,
            SVGTRefElement: false,
            SVGTSpanElement: false,
            SVGTests: false,
            SVGTextContentElement: false,
            SVGTextElement: false,
            SVGTextPathElement: false,
            SVGTextPositioningElement: false,
            SVGTitleElement: false,
            SVGTransform: false,
            SVGTransformList: false,
            SVGTransformable: false,
            SVGURIReference: false,
            SVGUnitTypes: false,
            SVGUseElement: false,
            SVGVKernElement: false,
            SVGViewElement: false,
            SVGViewSpec: false,
            SVGZoomAndPan: false,
            Text: false,
            TextDecoder: false,
            TextEncoder: false,
            TimeEvent: false,
            top: false,
            URL: false,
            WebGLActiveInfo: false,
            WebGLBuffer: false,
            WebGLContextEvent: false,
            WebGLFramebuffer: false,
            WebGLProgram: false,
            WebGLRenderbuffer: false,
            WebGLRenderingContext: false,
            WebGLShader: false,
            WebGLShaderPrecisionFormat: false,
            WebGLTexture: false,
            WebGLUniformLocation: false,
            WebSocket: false,
            window: false,
            Window: false,
            Worker: false,
            XDomainRequest: false,
            XMLHttpRequest: false,
            XMLSerializer: false,
            XPathEvaluator: false,
            XPathException: false,
            XPathExpression: false,
            XPathNamespace: false,
            XPathNSResolver: false,
            XPathResult: false
          };

          exports.devel = {
            alert: false,
            confirm: false,
            console: false,
            Debug: false,
            opera: false,
            prompt: false
          };

          exports.worker = {
            importScripts: true,
            postMessage: true,
            self: true,
            FileReaderSync: true
          };
          exports.nonstandard = {
            escape: false,
            unescape: false
          };

          exports.couch = {
            "require": false,
            respond: false,
            getRow: false,
            emit: false,
            send: false,
            start: false,
            sum: false,
            log: false,
            exports: false,
            module: false,
            provides: false
          };

          exports.node = {
            __filename: false,
            __dirname: false,
            GLOBAL: false,
            global: false,
            module: false,
            require: false,

            Buffer: true,
            console: true,
            exports: true,
            process: true,
            setTimeout: true,
            clearTimeout: true,
            setInterval: true,
            clearInterval: true,
            setImmediate: true, // v0.9.1+
            clearImmediate: true // v0.9.1+
          };

          exports.browserify = {
            __filename: false,
            __dirname: false,
            global: false,
            module: false,
            require: false,
            Buffer: true,
            exports: true,
            process: true
          };

          exports.phantom = {
            phantom: true,
            require: true,
            WebPage: true,
            console: true, // in examples, but undocumented
            exports: true // v1.7+
          };

          exports.qunit = {
            asyncTest: false,
            deepEqual: false,
            equal: false,
            expect: false,
            module: false,
            notDeepEqual: false,
            notEqual: false,
            notPropEqual: false,
            notStrictEqual: false,
            ok: false,
            propEqual: false,
            QUnit: false,
            raises: false,
            start: false,
            stop: false,
            strictEqual: false,
            test: false,
            "throws": false
          };

          exports.rhino = {
            defineClass: false,
            deserialize: false,
            gc: false,
            help: false,
            importClass: false,
            importPackage: false,
            "java": false,
            load: false,
            loadClass: false,
            Packages: false,
            print: false,
            quit: false,
            readFile: false,
            readUrl: false,
            runCommand: false,
            seal: false,
            serialize: false,
            spawn: false,
            sync: false,
            toint32: false,
            version: false
          };

          exports.shelljs = {
            target: false,
            echo: false,
            exit: false,
            cd: false,
            pwd: false,
            ls: false,
            find: false,
            cp: false,
            rm: false,
            mv: false,
            mkdir: false,
            test: false,
            cat: false,
            sed: false,
            grep: false,
            which: false,
            dirs: false,
            pushd: false,
            popd: false,
            env: false,
            exec: false,
            chmod: false,
            config: false,
            error: false,
            tempdir: false
          };

          exports.typed = {
            ArrayBuffer: false,
            ArrayBufferView: false,
            DataView: false,
            Float32Array: false,
            Float64Array: false,
            Int16Array: false,
            Int32Array: false,
            Int8Array: false,
            Uint16Array: false,
            Uint32Array: false,
            Uint8Array: false,
            Uint8ClampedArray: false
          };

          exports.wsh = {
            ActiveXObject: true,
            Enumerator: true,
            GetObject: true,
            ScriptEngine: true,
            ScriptEngineBuildVersion: true,
            ScriptEngineMajorVersion: true,
            ScriptEngineMinorVersion: true,
            VBArray: true,
            WSH: true,
            WScript: true,
            XDomainRequest: true
          };

          exports.dojo = {
            dojo: false,
            dijit: false,
            dojox: false,
            define: false,
            "require": false
          };

          exports.jquery = {
            "$": false,
            jQuery: false
          };

          exports.mootools = {
            "$": false,
            "$$": false,
            Asset: false,
            Browser: false,
            Chain: false,
            Class: false,
            Color: false,
            Cookie: false,
            Core: false,
            Document: false,
            DomReady: false,
            DOMEvent: false,
            DOMReady: false,
            Drag: false,
            Element: false,
            Elements: false,
            Event: false,
            Events: false,
            Fx: false,
            Group: false,
            Hash: false,
            HtmlTable: false,
            IFrame: false,
            IframeShim: false,
            InputValidator: false,
            instanceOf: false,
            Keyboard: false,
            Locale: false,
            Mask: false,
            MooTools: false,
            Native: false,
            Options: false,
            OverText: false,
            Request: false,
            Scroller: false,
            Slick: false,
            Slider: false,
            Sortables: false,
            Spinner: false,
            Swiff: false,
            Tips: false,
            Type: false,
            typeOf: false,
            URI: false,
            Window: false
          };

          exports.prototypejs = {
            "$": false,
            "$$": false,
            "$A": false,
            "$F": false,
            "$H": false,
            "$R": false,
            "$break": false,
            "$continue": false,
            "$w": false,
            Abstract: false,
            Ajax: false,
            Class: false,
            Enumerable: false,
            Element: false,
            Event: false,
            Field: false,
            Form: false,
            Hash: false,
            Insertion: false,
            ObjectRange: false,
            PeriodicalExecuter: false,
            Position: false,
            Prototype: false,
            Selector: false,
            Template: false,
            Toggle: false,
            Try: false,
            Autocompleter: false,
            Builder: false,
            Control: false,
            Draggable: false,
            Draggables: false,
            Droppables: false,
            Effect: false,
            Sortable: false,
            SortableObserver: false,
            Sound: false,
            Scriptaculous: false
          };

          exports.yui = {
            YUI: false,
            Y: false,
            YUI_config: false
          };

          exports.mocha = {
            mocha: false,
            describe: false,
            xdescribe: false,
            it: false,
            xit: false,
            context: false,
            xcontext: false,
            before: false,
            after: false,
            beforeEach: false,
            afterEach: false,
            suite: false,
            test: false,
            setup: false,
            teardown: false,
            suiteSetup: false,
            suiteTeardown: false
          };

          exports.jasmine = {
            jasmine: false,
            describe: false,
            xdescribe: false,
            it: false,
            xit: false,
            beforeEach: false,
            afterEach: false,
            setFixtures: false,
            loadFixtures: false,
            spyOn: false,
            expect: false,
            runs: false,
            waitsFor: false,
            waits: false,
            beforeAll: false,
            afterAll: false,
            fail: false,
            fdescribe: false,
            fit: false,
            pending: false
          };
        }, {}] }, {}, ["/node_modules/jshint/src/jshint.js"]);
    });

    ace.define("ace/mode/javascript_worker", ["require", "exports", "module", "ace/lib/oop", "ace/worker/mirror", "ace/mode/javascript/jshint"], function (require, exports, module) {
      "use strict";

      var oop = require("../lib/oop");
      var Mirror = require("../worker/mirror").Mirror;
      var lint = require("./javascript/jshint").JSHINT;

      function startRegex(arr) {
        return RegExp("^(" + arr.join("|") + ")");
      }

      var disabledWarningsRe = startRegex(["Bad for in variable '(.+)'.", 'Missing "use strict"']);
      var errorsRe = startRegex(["Unexpected", "Expected ", "Confusing (plus|minus)", "\\{a\\} unterminated regular expression", "Unclosed ", "Unmatched ", "Unbegun comment", "Bad invocation", "Missing space after", "Missing operator at"]);
      var infoRe = startRegex(["Expected an assignment", "Bad escapement of EOL", "Unexpected comma", "Unexpected space", "Missing radix parameter.", "A leading decimal point can", "\\['{a}'\\] is better written in dot notation.", "'{a}' used out of scope"]);

      var JavaScriptWorker = exports.JavaScriptWorker = function (sender) {
        Mirror.call(this, sender);
        this.setTimeout(500);
        this.setOptions();
      };

      oop.inherits(JavaScriptWorker, Mirror);

      (function () {
        this.setOptions = function (options) {
          this.options = options || {
            esnext: true,
            moz: true,
            devel: true,
            browser: true,
            node: true,
            laxcomma: true,
            laxbreak: true,
            lastsemic: true,
            onevar: false,
            passfail: false,
            maxerr: 100,
            expr: true,
            multistr: true,
            globalstrict: true
          };
          this.doc.getValue() && this.deferredUpdate.schedule(100);
        };

        this.changeOptions = function (newOptions) {
          oop.mixin(this.options, newOptions);
          this.doc.getValue() && this.deferredUpdate.schedule(100);
        };

        this.isValidJS = function (str) {
          try {
            eval("throw 0;" + str);
          } catch (e) {
            if (e === 0) return true;
          }
          return false;
        };

        this.onUpdate = function () {
          var value = this.doc.getValue();
          value = value.replace(/^#!.*\n/, "\n");
          if (!value) return this.sender.emit("annotate", []);

          var errors = [];
          var maxErrorLevel = this.isValidJS(value) ? "warning" : "error";
          lint(value, this.options, this.options.globals);
          var results = lint.errors;

          var errorAdded = false;
          for (var i = 0; i < results.length; i++) {
            var error = results[i];
            if (!error) continue;
            var raw = error.raw;
            var type = "warning";

            if (raw == "Missing semicolon.") {
              var str = error.evidence.substr(error.character);
              str = str.charAt(str.search(/\S/));
              if (maxErrorLevel == "error" && str && /[\w\d{(['"]/.test(str)) {
                error.reason = 'Missing ";" before statement';
                type = "error";
              } else {
                type = "info";
              }
            } else if (disabledWarningsRe.test(raw)) {
              continue;
            } else if (infoRe.test(raw)) {
              type = "info";
            } else if (errorsRe.test(raw)) {
              errorAdded = true;
              type = maxErrorLevel;
            } else if (raw == "'{a}' is not defined.") {
              type = "warning";
            } else if (raw == "'{a}' is defined but never used.") {
              type = "info";
            }

            errors.push({
              row: error.line - 1,
              column: error.character - 1,
              text: error.reason,
              type: type,
              raw: raw
            });

            if (errorAdded) {}
          }

          this.sender.emit("annotate", errors);
        };
      }).call(JavaScriptWorker.prototype);
    });

    ace.define("ace/lib/es5-shim", ["require", "exports", "module"], function (require, exports, module) {

      function Empty() {}

      if (!Function.prototype.bind) {
        Function.prototype.bind = function bind(that) {
          // .length is 1
          var target = this;
          if (typeof target != "function") {
            throw new TypeError("Function.prototype.bind called on incompatible " + target);
          }
          var args = slice.call(arguments, 1); // for normal call
          var bound = function () {

            if (this instanceof bound) {

              var result = target.apply(this, args.concat(slice.call(arguments)));
              if (Object(result) === result) {
                return result;
              }
              return this;
            } else {
              return target.apply(that, args.concat(slice.call(arguments)));
            }
          };
          if (target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            Empty.prototype = null;
          }
          return bound;
        };
      }
      var call = Function.prototype.call;
      var prototypeOfArray = Array.prototype;
      var prototypeOfObject = Object.prototype;
      var slice = prototypeOfArray.slice;
      var _toString = call.bind(prototypeOfObject.toString);
      var owns = call.bind(prototypeOfObject.hasOwnProperty);
      var defineGetter;
      var defineSetter;
      var lookupGetter;
      var lookupSetter;
      var supportsAccessors;
      if (supportsAccessors = owns(prototypeOfObject, "__defineGetter__")) {
        defineGetter = call.bind(prototypeOfObject.__defineGetter__);
        defineSetter = call.bind(prototypeOfObject.__defineSetter__);
        lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
        lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
      }
      if ([1, 2].splice(0).length != 2) {
        if (function () {
          // test IE < 9 to splice bug - see issue #138
          function makeArray(l) {
            var a = new Array(l + 2);
            a[0] = a[1] = 0;
            return a;
          }
          var array = [],
              lengthBefore;

          array.splice.apply(array, makeArray(20));
          array.splice.apply(array, makeArray(26));

          lengthBefore = array.length; //46
          array.splice(5, 0, "XXX"); // add one element

          lengthBefore + 1 == array.length;

          if (lengthBefore + 1 == array.length) {
            return true; // has right splice implementation without bugs
          }
        }()) {
          //IE 6/7
          var array_splice = Array.prototype.splice;
          Array.prototype.splice = function (start, deleteCount) {
            if (!arguments.length) {
              return [];
            } else {
              return array_splice.apply(this, [start === void 0 ? 0 : start, deleteCount === void 0 ? this.length - start : deleteCount].concat(slice.call(arguments, 2)));
            }
          };
        } else {
          //IE8
          Array.prototype.splice = function (pos, removeCount) {
            var length = this.length;
            if (pos > 0) {
              if (pos > length) pos = length;
            } else if (pos == void 0) {
              pos = 0;
            } else if (pos < 0) {
              pos = Math.max(length + pos, 0);
            }

            if (!(pos + removeCount < length)) removeCount = length - pos;

            var removed = this.slice(pos, pos + removeCount);
            var insert = slice.call(arguments, 2);
            var add = insert.length;
            if (pos === length) {
              if (add) {
                this.push.apply(this, insert);
              }
            } else {
              var remove = Math.min(removeCount, length - pos);
              var tailOldPos = pos + remove;
              var tailNewPos = tailOldPos + add - remove;
              var tailCount = length - tailOldPos;
              var lengthAfterRemove = length - remove;

              if (tailNewPos < tailOldPos) {
                // case A
                for (var i = 0; i < tailCount; ++i) {
                  this[tailNewPos + i] = this[tailOldPos + i];
                }
              } else if (tailNewPos > tailOldPos) {
                // case B
                for (i = tailCount; i--;) {
                  this[tailNewPos + i] = this[tailOldPos + i];
                }
              } // else, add == remove (nothing to do)

              if (add && pos === lengthAfterRemove) {
                this.length = lengthAfterRemove; // truncate array
                this.push.apply(this, insert);
              } else {
                this.length = lengthAfterRemove + add; // reserves space
                for (i = 0; i < add; ++i) {
                  this[pos + i] = insert[i];
                }
              }
            }
            return removed;
          };
        }
      }
      if (!Array.isArray) {
        Array.isArray = function isArray(obj) {
          return _toString(obj) == "[object Array]";
        };
      }
      var boxedString = Object("a"),
          splitString = boxedString[0] != "a" || !(0 in boxedString);

      if (!Array.prototype.forEach) {
        Array.prototype.forEach = function forEach(fun /*, thisp*/) {
          var object = toObject(this),
              self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
              thisp = arguments[1],
              i = -1,
              length = self.length >>> 0;
          if (_toString(fun) != "[object Function]") {
            throw new TypeError(); // TODO message
          }

          while (++i < length) {
            if (i in self) {
              fun.call(thisp, self[i], i, object);
            }
          }
        };
      }
      if (!Array.prototype.map) {
        Array.prototype.map = function map(fun /*, thisp*/) {
          var object = toObject(this),
              self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
              length = self.length >>> 0,
              result = Array(length),
              thisp = arguments[1];
          if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
          }

          for (var i = 0; i < length; i++) {
            if (i in self) result[i] = fun.call(thisp, self[i], i, object);
          }
          return result;
        };
      }
      if (!Array.prototype.filter) {
        Array.prototype.filter = function filter(fun /*, thisp */) {
          var object = toObject(this),
              self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
              length = self.length >>> 0,
              result = [],
              value,
              thisp = arguments[1];
          if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
          }

          for (var i = 0; i < length; i++) {
            if (i in self) {
              value = self[i];
              if (fun.call(thisp, value, i, object)) {
                result.push(value);
              }
            }
          }
          return result;
        };
      }
      if (!Array.prototype.every) {
        Array.prototype.every = function every(fun /*, thisp */) {
          var object = toObject(this),
              self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
              length = self.length >>> 0,
              thisp = arguments[1];
          if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
          }

          for (var i = 0; i < length; i++) {
            if (i in self && !fun.call(thisp, self[i], i, object)) {
              return false;
            }
          }
          return true;
        };
      }
      if (!Array.prototype.some) {
        Array.prototype.some = function some(fun /*, thisp */) {
          var object = toObject(this),
              self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
              length = self.length >>> 0,
              thisp = arguments[1];
          if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
          }

          for (var i = 0; i < length; i++) {
            if (i in self && fun.call(thisp, self[i], i, object)) {
              return true;
            }
          }
          return false;
        };
      }
      if (!Array.prototype.reduce) {
        Array.prototype.reduce = function reduce(fun /*, initial*/) {
          var object = toObject(this),
              self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
              length = self.length >>> 0;
          if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
          }
          if (!length && arguments.length == 1) {
            throw new TypeError("reduce of empty array with no initial value");
          }

          var i = 0;
          var result;
          if (arguments.length >= 2) {
            result = arguments[1];
          } else {
            do {
              if (i in self) {
                result = self[i++];
                break;
              }
              if (++i >= length) {
                throw new TypeError("reduce of empty array with no initial value");
              }
            } while (true);
          }

          for (; i < length; i++) {
            if (i in self) {
              result = fun.call(void 0, result, self[i], i, object);
            }
          }

          return result;
        };
      }
      if (!Array.prototype.reduceRight) {
        Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {
          var object = toObject(this),
              self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
              length = self.length >>> 0;
          if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
          }
          if (!length && arguments.length == 1) {
            throw new TypeError("reduceRight of empty array with no initial value");
          }

          var result,
              i = length - 1;
          if (arguments.length >= 2) {
            result = arguments[1];
          } else {
            do {
              if (i in self) {
                result = self[i--];
                break;
              }
              if (--i < 0) {
                throw new TypeError("reduceRight of empty array with no initial value");
              }
            } while (true);
          }

          do {
            if (i in this) {
              result = fun.call(void 0, result, self[i], i, object);
            }
          } while (i--);

          return result;
        };
      }
      if (!Array.prototype.indexOf || [0, 1].indexOf(1, 2) != -1) {
        Array.prototype.indexOf = function indexOf(sought /*, fromIndex */) {
          var self = splitString && _toString(this) == "[object String]" ? this.split("") : toObject(this),
              length = self.length >>> 0;

          if (!length) {
            return -1;
          }

          var i = 0;
          if (arguments.length > 1) {
            i = toInteger(arguments[1]);
          }
          i = i >= 0 ? i : Math.max(0, length + i);
          for (; i < length; i++) {
            if (i in self && self[i] === sought) {
              return i;
            }
          }
          return -1;
        };
      }
      if (!Array.prototype.lastIndexOf || [0, 1].lastIndexOf(0, -3) != -1) {
        Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {
          var self = splitString && _toString(this) == "[object String]" ? this.split("") : toObject(this),
              length = self.length >>> 0;

          if (!length) {
            return -1;
          }
          var i = length - 1;
          if (arguments.length > 1) {
            i = Math.min(i, toInteger(arguments[1]));
          }
          i = i >= 0 ? i : length - Math.abs(i);
          for (; i >= 0; i--) {
            if (i in self && sought === self[i]) {
              return i;
            }
          }
          return -1;
        };
      }
      if (!Object.getPrototypeOf) {
        Object.getPrototypeOf = function getPrototypeOf(object) {
          return object.__proto__ || (object.constructor ? object.constructor.prototype : prototypeOfObject);
        };
      }
      if (!Object.getOwnPropertyDescriptor) {
        var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a " + "non-object: ";
        Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
          if (typeof object != "object" && typeof object != "function" || object === null) throw new TypeError(ERR_NON_OBJECT + object);
          if (!owns(object, property)) return;

          var descriptor, getter, setter;
          descriptor = { enumerable: true, configurable: true };
          if (supportsAccessors) {
            var prototype = object.__proto__;
            object.__proto__ = prototypeOfObject;

            var getter = lookupGetter(object, property);
            var setter = lookupSetter(object, property);
            object.__proto__ = prototype;

            if (getter || setter) {
              if (getter) descriptor.get = getter;
              if (setter) descriptor.set = setter;
              return descriptor;
            }
          }
          descriptor.value = object[property];
          return descriptor;
        };
      }
      if (!Object.getOwnPropertyNames) {
        Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
          return Object.keys(object);
        };
      }
      if (!Object.create) {
        var createEmpty;
        if (Object.prototype.__proto__ === null) {
          createEmpty = function () {
            return { "__proto__": null };
          };
        } else {
          createEmpty = function () {
            var empty = {};
            for (var i in empty) empty[i] = null;
            empty.constructor = empty.hasOwnProperty = empty.propertyIsEnumerable = empty.isPrototypeOf = empty.toLocaleString = empty.toString = empty.valueOf = empty.__proto__ = null;
            return empty;
          };
        }

        Object.create = function create(prototype, properties) {
          var object;
          if (prototype === null) {
            object = createEmpty();
          } else {
            if (typeof prototype != "object") throw new TypeError("typeof prototype[" + typeof prototype + "] != 'object'");
            var Type = function () {};
            Type.prototype = prototype;
            object = new Type();
            object.__proto__ = prototype;
          }
          if (properties !== void 0) Object.defineProperties(object, properties);
          return object;
        };
      }

      function doesDefinePropertyWork(object) {
        try {
          Object.defineProperty(object, "sentinel", {});
          return "sentinel" in object;
        } catch (exception) {}
      }
      if (Object.defineProperty) {
        var definePropertyWorksOnObject = doesDefinePropertyWork({});
        var definePropertyWorksOnDom = typeof document == "undefined" || doesDefinePropertyWork(document.createElement("div"));
        if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
          var definePropertyFallback = Object.defineProperty;
        }
      }

      if (!Object.defineProperty || definePropertyFallback) {
        var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
        var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: ";
        var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " + "on this javascript engine";

        Object.defineProperty = function defineProperty(object, property, descriptor) {
          if (typeof object != "object" && typeof object != "function" || object === null) throw new TypeError(ERR_NON_OBJECT_TARGET + object);
          if (typeof descriptor != "object" && typeof descriptor != "function" || descriptor === null) throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
          if (definePropertyFallback) {
            try {
              return definePropertyFallback.call(Object, object, property, descriptor);
            } catch (exception) {}
          }
          if (owns(descriptor, "value")) {

            if (supportsAccessors && (lookupGetter(object, property) || lookupSetter(object, property))) {
              var prototype = object.__proto__;
              object.__proto__ = prototypeOfObject;
              delete object[property];
              object[property] = descriptor.value;
              object.__proto__ = prototype;
            } else {
              object[property] = descriptor.value;
            }
          } else {
            if (!supportsAccessors) throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
            if (owns(descriptor, "get")) defineGetter(object, property, descriptor.get);
            if (owns(descriptor, "set")) defineSetter(object, property, descriptor.set);
          }

          return object;
        };
      }
      if (!Object.defineProperties) {
        Object.defineProperties = function defineProperties(object, properties) {
          for (var property in properties) {
            if (owns(properties, property)) Object.defineProperty(object, property, properties[property]);
          }
          return object;
        };
      }
      if (!Object.seal) {
        Object.seal = function seal(object) {
          return object;
        };
      }
      if (!Object.freeze) {
        Object.freeze = function freeze(object) {
          return object;
        };
      }
      try {
        Object.freeze(function () {});
      } catch (exception) {
        Object.freeze = function freeze(freezeObject) {
          return function freeze(object) {
            if (typeof object == "function") {
              return object;
            } else {
              return freezeObject(object);
            }
          };
        }(Object.freeze);
      }
      if (!Object.preventExtensions) {
        Object.preventExtensions = function preventExtensions(object) {
          return object;
        };
      }
      if (!Object.isSealed) {
        Object.isSealed = function isSealed(object) {
          return false;
        };
      }
      if (!Object.isFrozen) {
        Object.isFrozen = function isFrozen(object) {
          return false;
        };
      }
      if (!Object.isExtensible) {
        Object.isExtensible = function isExtensible(object) {
          if (Object(object) === object) {
            throw new TypeError(); // TODO message
          }
          var name = '';
          while (owns(object, name)) {
            name += '?';
          }
          object[name] = true;
          var returnValue = owns(object, name);
          delete object[name];
          return returnValue;
        };
      }
      if (!Object.keys) {
        var hasDontEnumBug = true,
            dontEnums = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"],
            dontEnumsLength = dontEnums.length;

        for (var key in { "toString": null }) {
          hasDontEnumBug = false;
        }

        Object.keys = function keys(object) {

          if (typeof object != "object" && typeof object != "function" || object === null) {
            throw new TypeError("Object.keys called on a non-object");
          }

          var keys = [];
          for (var name in object) {
            if (owns(object, name)) {
              keys.push(name);
            }
          }

          if (hasDontEnumBug) {
            for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
              var dontEnum = dontEnums[i];
              if (owns(object, dontEnum)) {
                keys.push(dontEnum);
              }
            }
          }
          return keys;
        };
      }
      if (!Date.now) {
        Date.now = function now() {
          return new Date().getTime();
        };
      }
      var ws = "\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003" + "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" + "\u2029\uFEFF";
      if (!String.prototype.trim || ws.trim()) {
        ws = "[" + ws + "]";
        var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),
            trimEndRegexp = new RegExp(ws + ws + "*$");
        String.prototype.trim = function trim() {
          return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
        };
      }

      function toInteger(n) {
        n = +n;
        if (n !== n) {
          // isNaN
          n = 0;
        } else if (n !== 0 && n !== 1 / 0 && n !== -(1 / 0)) {
          n = (n > 0 || -1) * Math.floor(Math.abs(n));
        }
        return n;
      }

      function isPrimitive(input) {
        var type = typeof input;
        return input === null || type === "undefined" || type === "boolean" || type === "number" || type === "string";
      }

      function toPrimitive(input) {
        var val, valueOf, toString;
        if (isPrimitive(input)) {
          return input;
        }
        valueOf = input.valueOf;
        if (typeof valueOf === "function") {
          val = valueOf.call(input);
          if (isPrimitive(val)) {
            return val;
          }
        }
        toString = input.toString;
        if (typeof toString === "function") {
          val = toString.call(input);
          if (isPrimitive(val)) {
            return val;
          }
        }
        throw new TypeError();
      }
      var toObject = function (o) {
        if (o == null) {
          // this matches both null and undefined
          throw new TypeError("can't convert " + o + " to object");
        }
        return Object(o);
      };
    });
  })(this);

  return _retrieveGlobal();
});
System.register('rhythmmeister-website/rhythmmeister-website.js', ['jquery', 'hotkeys', 'ace', 'ace/theme-monokai', 'ace/mode-javascript', 'ace/mode-scss', 'postcss', 'rhythmmeister', 'postcss-nested', 'ace/worker-javascript'], function (_export, _context) {
    "use strict";

    var $, ace, postcss, rhythmmeister, nested;
    return {
        setters: [function (_jquery) {
            $ = _jquery.default;
        }, function (_hotkeys) {}, function (_ace) {
            ace = _ace.default;
        }, function (_aceThemeMonokai) {}, function (_aceModeJavascript) {}, function (_aceModeScss) {}, function (_postcss) {
            postcss = _postcss.default;
        }, function (_rhythmmeister) {
            rhythmmeister = _rhythmmeister.default;
        }, function (_postcssNested) {
            nested = _postcssNested.default;
        }, function (_aceWorkerJavascript) {}],
        execute: function () {

            $(function () {
                var cssStyles;

                fetch('styles/styles.css').then(function (response) {
                    return response.text();
                }).then(function (cssContents) {
                    cssStyles = cssContents;
                    renderCss(cssStyles);
                });

                $(document).bind('keydown', 'ctrl+\\', function () {
                    toggleHtmlClass('has-visible-vertical-rhythm-grid');
                });

                function toggleHtmlClass(className) {
                    var activeClasses = JSON.parse(localStorage.getItem('activeClasses'));
                    if (!activeClasses) {
                        activeClasses = {};
                    }
                    $('html').toggleClass(className);
                    activeClasses[className] = $('html').hasClass(className);
                    localStorage.setItem('activeClasses', JSON.stringify(activeClasses));
                }

                var activeClasses = JSON.parse(localStorage.getItem('activeClasses'));
                $.each(activeClasses, function (className, value) {
                    if (value) {
                        $('html').addClass(className);
                    }
                });

                $('.toggle-grid-visibility').on('click', function () {
                    toggleHtmlClass('has-visible-vertical-rhythm-grid');
                    return false;
                });
                ace.config.set('workerPath', 'jspm_packages/github/ajaxorg/ace-builds@1.2.6');

                var editor1 = ace.edit('code-editor-1');
                editor1.getSession().setTabSize(2);
                editor1.getSession().setMode('ace/mode/javascript');
                editor1.setTheme('ace/theme/monokai');
                document.getElementById('code-editor-1').style.fontSize = '14px';

                editor1.getSession().on('change', function (e) {
                    renderCss(cssStyles);
                });

                var editor2 = ace.edit('code-editor-2');
                editor2.getSession().setTabSize(2);
                editor2.getSession().setMode('ace/mode/javascript');
                editor2.setTheme('ace/theme/monokai');
                document.getElementById('code-editor-2').style.fontSize = '14px';

                editor2.getSession().on('change', function (e) {
                    renderCss(cssStyles);
                });

                var editor3 = ace.edit('code-editor-3');
                editor3.getSession().setTabSize(2);
                editor3.getSession().setMode('ace/mode/scss');
                editor3.setTheme('ace/theme/monokai');
                document.getElementById('code-editor-3').style.fontSize = '14px';

                editor3.getSession().on('change', function (e) {
                    renderCss(cssStyles);
                });

                function renderCss(cssContents) {
                    try {
                        var fontPresets = JSON.parse(editor1.getValue());

                        postcss([nested, rhythmmeister.processor(fontPresets)]).process(cssContents).then(function (result) {
                            $('#dynamic-css').remove();
                            $('<style id="dynamic-css"></style>').appendTo('head').html(result.css);

                            setTimeout(function () {
                                editor1.resize();
                                editor2.resize();
                                editor3.resize();
                            }, 200);
                        });
                    } catch (e) {}
                }
            });
        }
    };
});
//# sourceMappingURL=build.js.map